WEBVTT

00:00.000 --> 00:03.240
 The following is a conversation with Ishan Mizra,

00:03.240 --> 00:05.840
 research scientist at Facebook AI Research,

00:05.840 --> 00:08.600
 who works on self supervised machine learning

00:08.600 --> 00:10.480
 in the domain of computer vision.

00:10.480 --> 00:14.160
 Or in other words, making AI systems understand

00:14.160 --> 00:18.000
 the visual world with minimal help from us humans.

00:18.000 --> 00:21.720
 Transformers and self attention has been successfully used

00:21.720 --> 00:25.600
 by OpenAI GPT3 and other language models

00:25.600 --> 00:28.600
 to do self supervised learning in the domain of language.

00:28.600 --> 00:31.800
 Ishan together with Yan Likun and others

00:31.800 --> 00:33.920
 is trying to achieve the same success

00:33.920 --> 00:36.360
 in the domain of images and video.

00:36.360 --> 00:39.520
 The goal is to leave a robot watching YouTube videos

00:39.520 --> 00:41.240
 all night and in the morning,

00:41.240 --> 00:43.560
 come back to a much smarter robot.

00:43.560 --> 00:45.960
 I read the blog post self supervised learning

00:45.960 --> 00:50.320
 the dark matter of intelligence by Ishan and Yan Likun

00:50.320 --> 00:52.920
 and then listened to Ishan's appearance

00:52.920 --> 00:57.160
 on the excellent machine learning street talk podcast.

00:57.160 --> 00:59.160
 And I knew I had to talk to him.

00:59.160 --> 01:02.840
 By the way, if you're interested in machine learning and AI,

01:02.840 --> 01:07.840
 I cannot recommend the ML street talk podcast highly enough.

01:07.960 --> 01:09.640
 Those guys are great.

01:09.640 --> 01:12.040
 Quick mention of our sponsors on it,

01:12.040 --> 01:15.400
 the information, Grammarly and Athletic Greens.

01:15.400 --> 01:18.640
 Check them out in the description to support this podcast.

01:18.640 --> 01:21.680
 As a side note, let me say that for those of you

01:21.680 --> 01:23.240
 who may have been listening for quite a while,

01:23.240 --> 01:24.960
 this podcast used to be called

01:24.960 --> 01:27.120
 artificial intelligence podcast.

01:27.120 --> 01:29.680
 Because my life passion has always been,

01:29.680 --> 01:32.640
 will always be artificial intelligence,

01:32.640 --> 01:35.440
 both narrowly and broadly defined.

01:35.440 --> 01:39.080
 My goal with this podcast is still to have many conversations

01:39.080 --> 01:41.720
 with world class researchers in AI,

01:41.720 --> 01:45.120
 math, physics, biology and all the other sciences.

01:45.120 --> 01:49.400
 But I also want to talk to historians, musicians, athletes

01:49.400 --> 01:51.520
 and of course, occasionally comedians.

01:51.520 --> 01:53.600
 In fact, I'm trying out doing this podcast

01:53.600 --> 01:56.200
 three times a week now to give me more freedom

01:56.200 --> 01:59.400
 with guest selection and maybe get a chance

01:59.400 --> 02:00.880
 to have a bit more fun.

02:00.880 --> 02:03.160
 Speaking of fun, in this conversation,

02:03.160 --> 02:05.440
 I challenged the listener to count the number of times

02:05.440 --> 02:08.000
 the word banana is mentioned.

02:08.000 --> 02:12.600
 Ishan and I used the word banana as the canonical example

02:12.600 --> 02:15.200
 at the core of the hard problem of computer vision

02:15.200 --> 02:19.880
 and maybe the hard problem of consciousness.

02:19.880 --> 02:22.640
 This is the Lex Friedman podcast

02:22.640 --> 02:27.240
 and here is my conversation with Ishan Mizra.

02:27.240 --> 02:29.880
 What is self supervised learning?

02:29.880 --> 02:32.760
 And maybe even give the bigger basics

02:32.760 --> 02:35.360
 of what is supervised and semi supervised learning.

02:35.360 --> 02:37.640
 And maybe why is self supervised learning

02:37.640 --> 02:40.080
 a better term than unsupervised learning?

02:40.080 --> 02:41.560
 Let's start with supervised learning.

02:41.560 --> 02:43.920
 So typically for machine learning systems,

02:43.920 --> 02:46.920
 the way they're trained is you get a bunch of humans.

02:46.920 --> 02:48.600
 The humans point out particular concepts.

02:48.600 --> 02:50.160
 So if it's in the case of images,

02:50.160 --> 02:51.960
 you want the humans to come and tell you

02:51.960 --> 02:54.400
 what is present in the image,

02:54.400 --> 02:55.800
 draw boxes around them,

02:55.800 --> 02:57.680
 draw masks of things, pixels,

02:57.680 --> 03:00.440
 which are of particular categories or not.

03:00.440 --> 03:03.240
 For NLP, again, there are lots of these particular tasks,

03:03.240 --> 03:04.760
 say about sentiment analysis,

03:04.760 --> 03:06.640
 about entailment and so on.

03:06.640 --> 03:08.080
 So typically for supervised learning,

03:08.080 --> 03:11.280
 we get a big corpus of such annotated or labeled data

03:11.280 --> 03:12.800
 and then we feed that to a system

03:12.800 --> 03:14.800
 and the system is really trying to mimic,

03:14.800 --> 03:16.600
 so it's taking this input of the data

03:16.600 --> 03:18.360
 and then trying to mimic the output.

03:18.360 --> 03:20.680
 So it looks at an image and the human has tagged

03:20.680 --> 03:22.440
 that this image contains a banana

03:22.440 --> 03:24.680
 and now the system is basically trying to mimic that.

03:24.680 --> 03:26.720
 So that's its learning signal.

03:26.720 --> 03:28.040
 And so for supervised learning,

03:28.040 --> 03:30.080
 we try to gather lots of such data

03:30.080 --> 03:31.880
 and we train these machine learning models

03:31.880 --> 03:33.480
 to imitate the input output.

03:33.480 --> 03:35.640
 And the hope is basically by doing so,

03:35.640 --> 03:38.120
 now on unseen or like new kinds of data,

03:38.120 --> 03:41.360
 this model can automatically learn to predict these concepts.

03:41.360 --> 03:43.440
 So this is a standard sort of supervised setting.

03:43.440 --> 03:45.800
 For semi supervised setting,

03:45.800 --> 03:47.640
 the idea typically is that you have,

03:47.640 --> 03:49.320
 of course, all of the supervised data,

03:49.320 --> 03:50.840
 but you have lots of other data

03:50.840 --> 03:53.160
 which is unsupervised or which is like not labeled.

03:53.160 --> 03:55.320
 Now the problem basically with supervised learning

03:55.320 --> 03:57.480
 and why you actually have all of these alternate

03:57.480 --> 03:59.440
 sort of learning paradigms is

03:59.440 --> 04:01.840
 supervised learning just does not scale.

04:01.840 --> 04:03.960
 So if you look at for computer vision,

04:03.960 --> 04:06.320
 the sort of largest one of the most popular datasets

04:06.320 --> 04:07.520
 is ImageNet, right?

04:07.520 --> 04:09.360
 So the entire ImageNet dataset

04:09.360 --> 04:13.840
 has about 22,000 concepts and about 14 million images.

04:13.840 --> 04:16.200
 So these concepts are basically just nouns

04:16.200 --> 04:18.360
 and they're annotated on images.

04:18.360 --> 04:20.840
 And this entire dataset was a mammoth data collection effort.

04:20.840 --> 04:23.800
 It actually gave rise to a lot of powerful learning algorithms

04:23.800 --> 04:25.600
 as credited with like sort of the rise

04:25.600 --> 04:27.200
 of deep learning as well.

04:27.200 --> 04:30.120
 But this dataset took about 22 human years

04:30.120 --> 04:31.920
 to collect, to annotate.

04:31.920 --> 04:33.480
 And it's not even that many concepts, right?

04:33.480 --> 04:34.520
 It's not even that many images.

04:34.520 --> 04:36.760
 14 million is nothing really.

04:36.760 --> 04:39.320
 Like you have about I think 400 million images or so

04:39.320 --> 04:41.880
 or even more than that uploaded to most of the popular

04:41.880 --> 04:44.160
 sort of social media websites today.

04:44.160 --> 04:46.400
 So now supervised learning just doesn't scale.

04:46.400 --> 04:48.640
 If I want to now annotate more concepts,

04:48.640 --> 04:51.280
 if I want to have this various types of fine grained concepts,

04:51.280 --> 04:53.200
 then it won't really scale.

04:53.200 --> 04:55.680
 So now you come up to these sort of different learning paradigms,

04:55.680 --> 04:57.520
 for example, semi supervised learning,

04:57.520 --> 04:58.560
 where the idea is, of course,

04:58.560 --> 05:01.360
 you have this annotated corpus of supervised data

05:01.360 --> 05:03.680
 and you have lots of these unlabeled images.

05:03.680 --> 05:05.840
 And the idea is that the algorithm should basically try

05:05.840 --> 05:07.960
 to measure some kind of consistency

05:07.960 --> 05:10.280
 or really try to measure some kind of signal

05:10.280 --> 05:12.160
 on this sort of unlabeled data

05:12.160 --> 05:14.160
 to make it self more confident

05:14.160 --> 05:16.160
 about what it's really trying to predict.

05:16.160 --> 05:19.640
 So by access to this lots of unlabeled data,

05:19.640 --> 05:22.200
 the idea is that the algorithm actually learns

05:22.200 --> 05:24.520
 to be more confident and actually gets better

05:24.520 --> 05:25.920
 at predicting these concepts.

05:26.880 --> 05:28.480
 And now we come to the other extreme,

05:28.480 --> 05:30.480
 which is like self supervised learning.

05:30.480 --> 05:32.280
 The idea basically is that the machine

05:32.280 --> 05:34.720
 or the algorithm should really discover concepts

05:34.720 --> 05:36.400
 or discover things about the world

05:36.400 --> 05:39.200
 or learn representations about the world which are useful

05:39.200 --> 05:41.760
 without access to explicit human supervision.

05:41.760 --> 05:46.280
 So the word supervision is still in the term self supervised.

05:46.280 --> 05:48.560
 So what is the supervision signal?

05:48.560 --> 05:52.040
 And maybe that perhaps is when Yann LeCun and you argue

05:52.040 --> 05:55.040
 that unsupervised is the incorrect in terminology here.

05:55.040 --> 05:57.440
 So what is the supervision signal

05:57.440 --> 05:59.720
 when the humans aren't part of the picture

05:59.720 --> 06:02.400
 or not a big part of the picture?

06:02.400 --> 06:04.520
 Right, so self supervised,

06:04.520 --> 06:06.800
 the reason it has the term supervised in itself

06:06.800 --> 06:10.360
 is because you're using the data itself as supervision.

06:10.360 --> 06:13.240
 So because the data serves as its own source of supervision

06:13.240 --> 06:15.200
 it's self supervised in that way.

06:15.200 --> 06:16.440
 Now the reason a lot of people,

06:16.440 --> 06:18.440
 I mean, we did it in that blog post with Yann,

06:18.440 --> 06:20.160
 but a lot of other people have also argued

06:20.160 --> 06:22.120
 for using this term self supervised.

06:22.120 --> 06:25.640
 So starting from like 94 from Virginia Desa's group

06:25.640 --> 06:28.840
 at I think UCSD and now she's at UCSD.

06:28.840 --> 06:31.680
 Jitendra Malik has said this a bunch of times as well.

06:31.680 --> 06:33.120
 So you have supervised

06:33.120 --> 06:35.240
 and then unsupervised basically means everything

06:35.240 --> 06:36.440
 which is not supervised,

06:36.440 --> 06:38.680
 but that includes stuff like semi supervised

06:38.680 --> 06:41.320
 that includes other like transductive learning

06:41.320 --> 06:43.040
 lots of other sort of settings.

06:43.040 --> 06:45.520
 So that's the reason like now people

06:45.520 --> 06:47.160
 are preferring this term self supervised

06:47.160 --> 06:49.280
 because it explicitly says what's happening.

06:49.280 --> 06:51.640
 The data itself is the source of supervision

06:51.640 --> 06:53.160
 and any sort of learning algorithm

06:53.160 --> 06:56.960
 which tries to extract just sort of data supervision signals

06:56.960 --> 06:59.520
 from the data itself is a self supervised algorithm.

06:59.520 --> 07:03.200
 But there is within the data a set of tricks

07:03.200 --> 07:05.600
 which unlock the supervision.

07:05.600 --> 07:07.240
 So can you give me some examples?

07:07.240 --> 07:11.400
 And there's innovation, ingenuity required

07:11.400 --> 07:12.880
 to unlock that supervision.

07:12.880 --> 07:15.640
 The data doesn't just speak to you some ground truth.

07:15.640 --> 07:17.800
 You have to do some kind of trick.

07:17.800 --> 07:19.600
 So I don't know what your favorite domain is.

07:19.600 --> 07:23.040
 So you specifically specialize in visual learning

07:23.040 --> 07:24.520
 but is there favorite examples

07:24.520 --> 07:26.560
 maybe in language or other domains?

07:26.560 --> 07:28.320
 Perhaps the most successful applications

07:28.320 --> 07:31.080
 have been in NLP, not language processing.

07:31.080 --> 07:34.040
 So the idea basically being that you can train models

07:34.040 --> 07:37.400
 that you have a sentence and you mask out certain words

07:37.400 --> 07:40.520
 and now these models learn to predict the masked out words.

07:40.520 --> 07:44.040
 So if you have like the cat jumped over the dog.

07:44.040 --> 07:46.000
 So you can basically mask out cat

07:46.000 --> 07:47.920
 and now you're essentially asking the model to predict

07:47.920 --> 07:50.320
 what was missing, what did I mask out?

07:50.320 --> 07:52.480
 So the model is going to predict basically

07:52.480 --> 07:55.360
 a distribution over all the possible words that it knows

07:55.360 --> 07:58.400
 and probably it has like if it's a well trained model

07:58.400 --> 08:00.600
 it has a sort of higher probability density

08:00.600 --> 08:02.600
 for this word cat.

08:02.600 --> 08:05.520
 For vision I would say the sort of more,

08:05.520 --> 08:07.480
 I mean the easier example

08:07.480 --> 08:09.400
 which is not as widely used these days

08:09.400 --> 08:12.040
 is basically say for example video prediction.

08:12.040 --> 08:14.080
 So video is again a sequence of things.

08:14.080 --> 08:15.040
 So you can ask the model.

08:15.040 --> 08:17.440
 So if you have a video of say 10 seconds

08:17.440 --> 08:19.840
 you can feed in the first nine seconds to a model

08:19.840 --> 08:21.960
 and then ask it, hey, what happens basically

08:21.960 --> 08:22.800
 in the 10 second?

08:22.800 --> 08:24.480
 Can you predict what's going to happen?

08:24.480 --> 08:26.760
 And the idea basically is because the model

08:26.760 --> 08:29.440
 is predicting something about the data itself.

08:29.440 --> 08:31.680
 Of course you didn't need any human to tell you

08:31.680 --> 08:33.160
 what was happening because the 10 second video

08:33.160 --> 08:34.600
 was naturally captured.

08:34.600 --> 08:36.680
 Because the model is predicting what's happening there

08:36.680 --> 08:39.040
 it's going to automatically learn something

08:39.040 --> 08:41.240
 about the structure of the world, how objects move,

08:41.240 --> 08:44.000
 object permanence and these kinds of things.

08:44.000 --> 08:45.960
 So like if I have something at the edge of the table

08:45.960 --> 08:47.520
 it'll fall down.

08:47.520 --> 08:48.960
 Things like these which you really don't have

08:48.960 --> 08:50.240
 to sit and annotate.

08:50.240 --> 08:51.320
 In a supervised learning setting

08:51.320 --> 08:52.280
 I would have to sit and annotate.

08:52.280 --> 08:55.200
 This is a cup, now I move this cup, this is still a cup

08:55.200 --> 08:56.640
 and now I move this cup, it's still a cup

08:56.640 --> 08:58.840
 and then it falls down and this is a fallen down cup.

08:58.840 --> 09:00.400
 So I won't have to annotate all of these things

09:00.400 --> 09:02.000
 in a self supervised setting.

09:02.000 --> 09:05.240
 Isn't that kind of a brilliant little trick

09:05.240 --> 09:08.280
 of taking a series of data that is consistent

09:08.280 --> 09:11.880
 and removing one element in that series

09:11.880 --> 09:16.880
 and then teaching the algorithm to predict that element?

09:17.000 --> 09:19.640
 Isn't that, first of all, that's quite brilliant.

09:20.680 --> 09:24.200
 It seems to be applicable in anything that

09:24.200 --> 09:27.880
 has the constraint of being a sequence

09:27.880 --> 09:30.480
 that is consistent with the physical reality.

09:31.760 --> 09:34.400
 The question is, are there other tricks like this

09:34.400 --> 09:37.840
 that can generate the self supervision signal?

09:37.840 --> 09:41.200
 So sequence is possibly the most widely used one in NLP.

09:41.200 --> 09:44.080
 For vision, the one that is actually used for images

09:44.080 --> 09:45.840
 which is very popular these days

09:45.840 --> 09:47.600
 is basically taking an image

09:47.600 --> 09:50.080
 and now taking different crops of that image.

09:50.080 --> 09:53.080
 So you can basically decide to crop say the top left corner

09:53.080 --> 09:55.280
 and you crop say the bottom right corner

09:55.280 --> 09:58.080
 and asking a network to basically present it

09:58.080 --> 10:01.360
 with a choice saying that, okay, now you have this image,

10:01.360 --> 10:04.480
 you have this image, are these the same or not?

10:04.480 --> 10:05.760
 And so the idea basically is that

10:05.760 --> 10:07.480
 because different crop, like in an image,

10:07.480 --> 10:09.800
 different parts of the image are going to be related.

10:09.800 --> 10:12.400
 So for example, if you have a chair and a table,

10:12.400 --> 10:15.080
 basically these things are going to be close by

10:15.080 --> 10:18.360
 versus if you take, again, if you have like a zoomed

10:18.360 --> 10:20.520
 in picture of a chair, if you're taking different crops,

10:20.520 --> 10:22.360
 it's going to be different parts of the chair.

10:22.360 --> 10:25.040
 So the idea basically is that different crops

10:25.040 --> 10:26.200
 of the image are related.

10:26.200 --> 10:27.920
 And so the features or the representations

10:27.920 --> 10:29.080
 that you get from these different crops

10:29.080 --> 10:30.320
 should also be related.

10:30.320 --> 10:32.720
 So this is possibly the most widely used trick

10:32.720 --> 10:35.760
 these days for cell supervised learning and computer vision.

10:35.760 --> 10:38.400
 So again, using the consistency

10:38.400 --> 10:42.040
 that's inherent to physical reality in visual domain,

10:42.040 --> 10:45.640
 that's parts of an image are consistent.

10:45.640 --> 10:49.120
 And then in the language domain or anything

10:49.120 --> 10:51.600
 that has sequences like language or something

10:51.600 --> 10:53.000
 that's like a time series,

10:53.000 --> 10:55.440
 then you can chop off parts in time.

10:55.440 --> 10:59.400
 It's similar to the story of RNNs and CNNs,

11:00.280 --> 11:02.280
 of RNNs and covenants.

11:02.280 --> 11:06.640
 Yuen Yan Likun wrote the blog post in March, 2021,

11:06.640 --> 11:08.840
 titled self supervised learning,

11:08.840 --> 11:11.080
 the dark matter of intelligence.

11:11.080 --> 11:12.640
 Can you summarize this blog post

11:12.640 --> 11:15.640
 and maybe explain the main idea or set of ideas?

11:15.640 --> 11:18.680
 The blog post was mainly about sort of just telling,

11:18.680 --> 11:21.680
 I mean, this is really a accepted fact,

11:21.680 --> 11:22.960
 I would say for a lot of people now,

11:22.960 --> 11:24.360
 that self supervised learning is something

11:24.360 --> 11:26.600
 that is going to be a play

11:26.600 --> 11:28.320
 an important role for machine learning algorithms

11:28.320 --> 11:30.400
 that come in the future and even now.

11:30.400 --> 11:33.840
 Well, let me just comment that we don't yet

11:33.840 --> 11:36.480
 have a good understanding of what dark matter is.

11:36.480 --> 11:37.320
 That's true.

11:37.320 --> 11:40.080
 So the idea basically being.

11:40.080 --> 11:41.840
 Maybe the metaphor doesn't exactly transfer,

11:41.840 --> 11:44.840
 but maybe it's actually perfectly transfers

11:44.840 --> 11:45.680
 that we don't know.

11:45.680 --> 11:49.280
 We have an inkling that it'll be a big part

11:49.280 --> 11:51.200
 of whatever solving intelligence looks like.

11:51.200 --> 11:52.040
 Right.

11:52.040 --> 11:53.000
 I think self supervised learning,

11:53.000 --> 11:54.880
 the way it's done right now is,

11:54.880 --> 11:57.360
 I would say like the first step towards what it probably

11:57.360 --> 11:58.600
 should end up like learning

11:58.600 --> 12:00.520
 or what it should enable us to do.

12:00.520 --> 12:03.760
 So the idea for that particular piece was

12:03.760 --> 12:06.200
 self supervised learning is going to be a very powerful way

12:06.200 --> 12:08.400
 to learn common sense about the world

12:08.400 --> 12:10.800
 or like stuff that is really hard to label.

12:10.800 --> 12:13.760
 For example, like is this piece

12:13.760 --> 12:15.640
 over here heavier than the cup?

12:15.640 --> 12:17.520
 Now, for all these kinds of things,

12:17.520 --> 12:18.760
 you'll have to sit and label these things.

12:18.760 --> 12:21.560
 So supervised learning is clearly not going to scale.

12:21.560 --> 12:23.520
 So what is the thing that's actually going to scale?

12:23.520 --> 12:25.040
 It's probably going to be an agent

12:25.040 --> 12:27.920
 that can either actually interact with it to lift it up

12:27.920 --> 12:29.960
 or observe me doing it.

12:29.960 --> 12:31.560
 So if I'm basically lifting these things up,

12:31.560 --> 12:32.600
 it can probably reason about,

12:32.600 --> 12:34.760
 hey, this is taking him more time to lift up

12:34.760 --> 12:36.200
 or the velocity is different,

12:36.200 --> 12:37.840
 whereas the velocity for this is different,

12:37.840 --> 12:39.600
 probably this one is heavier.

12:39.600 --> 12:42.000
 So essentially by observations of the data,

12:42.000 --> 12:44.240
 you should be able to infer a lot of things

12:44.240 --> 12:46.840
 about the world without someone explicitly telling you,

12:46.840 --> 12:48.720
 this is heavy, this is not,

12:48.720 --> 12:50.000
 this is something that can pour,

12:50.000 --> 12:51.200
 this is something that cannot pour,

12:51.200 --> 12:52.480
 this is somewhere that you can sit,

12:52.480 --> 12:53.920
 this is not somewhere that you can sit.

12:53.920 --> 12:55.520
 But you've just mentioned the ability

12:55.520 --> 12:57.440
 to interact with the world.

12:57.440 --> 13:01.000
 There's so many questions that are yet to be,

13:01.000 --> 13:02.240
 that are still open,

13:02.240 --> 13:04.480
 which is how do you select a set of data

13:04.480 --> 13:08.640
 over which the self supervised learning process works?

13:08.640 --> 13:11.520
 How much interactivity, like in the active learning

13:11.520 --> 13:13.440
 or the machine teaching context,

13:13.440 --> 13:16.480
 is there, what are the reward signals?

13:16.480 --> 13:18.560
 Like how much actual interaction there is

13:18.560 --> 13:20.080
 with the physical world?

13:20.080 --> 13:21.440
 That kind of thing.

13:21.440 --> 13:24.800
 So that could be a huge question.

13:24.800 --> 13:26.720
 And then on top of that,

13:26.720 --> 13:29.000
 which I have a million questions about,

13:29.000 --> 13:30.440
 which we don't know the answers to,

13:30.440 --> 13:32.840
 but it's worth talking about is,

13:32.840 --> 13:35.120
 how much reasoning is involved?

13:35.120 --> 13:38.520
 How much accumulation of knowledge

13:38.520 --> 13:40.800
 versus something that's more akin to learning

13:40.800 --> 13:43.240
 or whether that's the same thing.

13:43.240 --> 13:46.560
 But so we're like, it is truly dark matter.

13:46.560 --> 13:49.200
 We don't know how exactly to do it,

13:49.200 --> 13:52.040
 but we are, I mean, a lot of us are actually convinced

13:52.040 --> 13:54.200
 that it's going to be a sort of major thing

13:54.200 --> 13:55.040
 in machine learning.

13:55.040 --> 13:56.600
 So let me reframe it then,

13:56.600 --> 14:01.160
 that human supervision cannot be at large scale,

14:01.160 --> 14:04.120
 the source of the solution to intelligence.

14:04.120 --> 14:08.000
 So the machines have to discover the supervision

14:08.000 --> 14:10.240
 in the natural signal of the world.

14:10.240 --> 14:12.000
 I mean, the other thing is also that

14:12.000 --> 14:14.200
 humans are not particularly good labors,

14:14.200 --> 14:16.000
 they're not very consistent.

14:16.000 --> 14:17.880
 For example, like, what's the difference

14:17.880 --> 14:19.840
 between a dining table and a table?

14:19.840 --> 14:21.560
 Is it just the fact that one,

14:21.560 --> 14:23.080
 like if you just look at a particular table,

14:23.080 --> 14:24.600
 what makes us say one is dining table

14:24.600 --> 14:26.520
 and the other is not?

14:26.520 --> 14:28.160
 Humans are not particularly consistent,

14:28.160 --> 14:30.120
 they're not like very good sources of supervision

14:30.120 --> 14:32.320
 for a lot of these kind of edge cases.

14:32.320 --> 14:35.880
 So it may be also the fact that if we want,

14:35.880 --> 14:37.960
 like want an algorithm or want a machine

14:37.960 --> 14:39.640
 to solve a particular task for us,

14:39.640 --> 14:42.120
 we can maybe just specify the end goal

14:42.120 --> 14:44.240
 and like the stuff in between,

14:44.240 --> 14:46.080
 we really probably should not be specifying

14:46.080 --> 14:49.320
 because we're not maybe going to confuse it a lot actually.

14:49.320 --> 14:51.440
 Well, humans can't even answer the meaning of life.

14:51.440 --> 14:53.920
 So I'm not sure if we're good supervisors

14:53.920 --> 14:55.240
 of the end goal either.

14:55.240 --> 14:56.960
 So let me ask you about categories.

14:56.960 --> 14:59.040
 Humans are not very good at telling the difference

14:59.040 --> 15:01.960
 between what is and isn't a table, like you mentioned.

15:02.840 --> 15:04.520
 Do you think it's possible,

15:04.520 --> 15:08.120
 let me ask you like a pretend you're a play dough.

15:10.120 --> 15:14.800
 Is it possible to create a pretty good taxonomy

15:14.800 --> 15:16.400
 of objects in the world?

15:16.400 --> 15:19.000
 It seems like a lot of approaches in machine learning

15:19.000 --> 15:21.400
 kind of assume a hopeful vision

15:21.400 --> 15:24.080
 that it's possible to construct a perfect taxonomy

15:24.080 --> 15:26.520
 or it exists perhaps out of our reach,

15:26.520 --> 15:28.840
 but we can always get closer and closer to it.

15:28.840 --> 15:30.400
 Or is that a hopeless pursuit?

15:31.240 --> 15:33.040
 I think it's hopeless in some way.

15:33.040 --> 15:36.080
 So the thing is for any particular categorization

15:36.080 --> 15:36.920
 that you create,

15:36.920 --> 15:38.760
 if you have a discrete sort of categorization,

15:38.760 --> 15:40.520
 I can always take the nearest two concepts

15:40.520 --> 15:42.600
 or I can take a third concept and I can blend it in

15:42.600 --> 15:44.480
 and I can create a new category.

15:44.480 --> 15:46.560
 So if you were to enumerate N categories,

15:46.560 --> 15:48.880
 I will always find an N plus one category for you.

15:48.880 --> 15:50.680
 That's not going to be in the N categories.

15:50.680 --> 15:52.400
 And I can actually create not just N plus one,

15:52.400 --> 15:55.120
 I can very easily create far more than N categories.

15:55.120 --> 15:55.960
 The thing is,

15:55.960 --> 15:58.960
 a lot of things we talk about are actually compositional.

15:58.960 --> 16:01.680
 So it's really hard for us to come and sit

16:01.680 --> 16:03.200
 and enumerate all of these out.

16:03.200 --> 16:05.840
 And they compose in various weird ways, right?

16:05.840 --> 16:07.840
 Like you have a croissant and a doughnut

16:07.840 --> 16:09.680
 come together to form a cronut.

16:09.680 --> 16:12.400
 So if you were to like enumerate all the foods up until,

16:12.400 --> 16:15.160
 I don't know, whenever the cronut was about 10 years ago

16:15.160 --> 16:16.440
 or 15 years ago,

16:16.440 --> 16:19.000
 then this entire thing called cronut would not exist.

16:19.000 --> 16:21.760
 Yeah, I remember there was the most awesome video

16:21.760 --> 16:23.520
 of a cat wearing a monkey costume.

16:23.520 --> 16:26.520
 Yeah, yes.

16:26.520 --> 16:28.240
 People should look it up, it's great.

16:28.240 --> 16:31.000
 So is that a monkey or is that a cat?

16:31.000 --> 16:33.840
 It's a very difficult philosophical question.

16:33.840 --> 16:37.280
 So there is a concept of similarity between objects.

16:37.280 --> 16:39.880
 So you think that can take us very far?

16:39.880 --> 16:43.200
 Just kind of getting a good function,

16:43.200 --> 16:47.920
 a good way to tell which parts of things are similar

16:47.920 --> 16:50.720
 and which parts of things are very different?

16:50.720 --> 16:51.800
 I think so, yeah.

16:51.800 --> 16:54.320
 So you don't necessarily need to name everything

16:54.320 --> 16:57.840
 or assign a name to everything to be able to use it, right?

16:57.840 --> 16:59.560
 So there are like lots of...

16:59.560 --> 17:01.720
 Shakespeare said that, what's in a name?

17:01.720 --> 17:02.560
 What's in a name?

17:02.560 --> 17:03.400
 Yeah, okay.

17:03.400 --> 17:05.840
 I mean, lots of like, for example, animals, right?

17:05.840 --> 17:08.120
 They don't have necessarily a well formed

17:08.120 --> 17:09.520
 like syntactic language,

17:09.520 --> 17:11.800
 but they're able to go about their day perfectly.

17:11.800 --> 17:12.880
 The same thing happens for us.

17:12.880 --> 17:17.040
 So, I mean, we probably look at things and we figure out,

17:17.040 --> 17:19.320
 oh, this is similar to something else that I've seen before.

17:19.320 --> 17:22.000
 And then I can probably learn how to use it.

17:22.000 --> 17:26.280
 So I haven't seen all the possible doorknobs in the world.

17:26.280 --> 17:29.000
 But if you show me, like I was able to get into

17:29.000 --> 17:30.360
 this particular place fairly easily,

17:30.360 --> 17:32.120
 I've never seen that particular doorknob.

17:32.120 --> 17:33.920
 So I, of course, related to all the doorknobs

17:33.920 --> 17:36.520
 that I've seen and I know exactly how it's going to open.

17:36.520 --> 17:39.400
 I have a pretty good idea of how it's going to open.

17:39.400 --> 17:41.800
 And I think this kind of translation between experiences

17:41.800 --> 17:43.680
 only happens because of similarity.

17:43.680 --> 17:45.360
 Because I'm able to relate it to a doorknob.

17:45.360 --> 17:46.560
 If I related it to a hairdryer,

17:46.560 --> 17:48.360
 I would probably be stuck still outside,

17:48.360 --> 17:49.200
 not able to get in.

17:50.360 --> 17:52.200
 Again, a bit of a philosophical question,

17:52.200 --> 17:55.600
 but is, can similarity take us all the way

17:55.600 --> 17:57.680
 to understanding a thing?

17:58.640 --> 18:01.920
 Can having a good function that compares objects

18:01.920 --> 18:04.880
 get us to understand something profound

18:04.880 --> 18:07.160
 about singular objects?

18:07.160 --> 18:08.600
 I think I'll ask you a question back.

18:08.600 --> 18:10.480
 What does it mean to understand objects?

18:11.560 --> 18:13.480
 Well, let me tell you what that's similar to.

18:13.480 --> 18:14.320
 No.

18:14.320 --> 18:17.680
 So there's an idea of sort of reasoning

18:17.680 --> 18:19.760
 by analogy kind of thing.

18:19.760 --> 18:24.760
 I think understanding is the process of placing that thing

18:24.920 --> 18:28.440
 in some kind of network of knowledge that you have.

18:28.440 --> 18:33.160
 That it perhaps is fundamentally related to other concepts.

18:33.160 --> 18:36.480
 So it's not like understanding is fundamentally related

18:36.480 --> 18:39.240
 by composition of other concepts

18:39.240 --> 18:41.480
 and maybe in relation to other concepts.

18:43.160 --> 18:45.800
 And maybe deeper and deeper understanding

18:45.800 --> 18:50.880
 is maybe just adding more edges to that graph somehow.

18:51.840 --> 18:55.080
 So maybe it is a composition of similarities.

18:55.080 --> 18:59.560
 I mean, ultimately, I suppose it is a kind of embedding

18:59.560 --> 19:02.480
 in that wisdom space.

19:02.480 --> 19:06.520
 Yeah, okay, wisdom space is good.

19:06.520 --> 19:08.080
 I think, I do think, right?

19:08.080 --> 19:10.760
 So similarity does get you very, very far.

19:10.760 --> 19:12.360
 Is it the answer to everything?

19:12.360 --> 19:14.160
 I mean, I don't even know what everything is,

19:14.160 --> 19:16.720
 but it's going to take us really far.

19:16.720 --> 19:19.680
 And I think the thing is things are similar

19:19.680 --> 19:21.680
 in very different contexts, right?

19:21.680 --> 19:24.360
 So an elephant is similar to, I don't know,

19:24.360 --> 19:26.280
 another sort of wild animal, let's just pick,

19:26.280 --> 19:28.560
 I don't know, lion in a different way

19:28.560 --> 19:30.560
 because they're both four legged creatures.

19:30.560 --> 19:32.080
 They're also land animals.

19:32.080 --> 19:33.160
 But of course, they're very different

19:33.160 --> 19:34.000
 in a lot of different ways.

19:34.000 --> 19:37.280
 So elephants are like herbivores, lions are not.

19:37.280 --> 19:40.680
 So similarity does, similarity and particularly dissimilarity

19:40.680 --> 19:43.760
 also sort of actually helps us understand a lot about things.

19:43.760 --> 19:45.240
 And so that's actually why I think

19:45.240 --> 19:47.640
 discrete categorization is very hard.

19:47.640 --> 19:50.080
 Just like forming this particular category of elephant

19:50.080 --> 19:51.880
 and a particular category of lion,

19:51.880 --> 19:54.400
 maybe it's good for like just like taxonomy,

19:54.400 --> 19:55.800
 biological taxonomies.

19:55.800 --> 19:57.240
 But when it comes to like other things

19:57.240 --> 20:01.160
 which are not as maybe, for example, like grilled cheese,

20:01.160 --> 20:03.080
 right? I have a grilled cheese I dip it in tomato

20:03.080 --> 20:04.000
 and I keep it outside.

20:04.000 --> 20:05.080
 Now, is that still a grilled cheese

20:05.080 --> 20:06.760
 or is that something else?

20:06.760 --> 20:09.800
 All right, so categorization is still very useful

20:09.800 --> 20:11.280
 for solving problems.

20:11.280 --> 20:15.960
 But is your intuition then sort of the self supervised

20:15.960 --> 20:20.960
 should be the, to borrow Jan Lacoon's terminology,

20:20.960 --> 20:23.680
 should be the cake and then categorization,

20:23.680 --> 20:27.400
 the classification, maybe the supervised like layer

20:27.400 --> 20:29.120
 should be just like the thing on top,

20:29.120 --> 20:31.040
 the cherry or the icing or whatever.

20:31.040 --> 20:35.560
 So if you make it the cake, it gets in the way of learning.

20:35.560 --> 20:37.000
 If you make it the cake, then you don't,

20:37.000 --> 20:39.400
 we won't be able to sit and annotate everything.

20:39.400 --> 20:40.680
 That's as simple as it is.

20:40.680 --> 20:43.120
 Like that's my very practical view on it.

20:43.120 --> 20:44.960
 It's just, I mean, in my PhD,

20:44.960 --> 20:47.040
 I sat down and annotated like a bunch of cars

20:47.040 --> 20:48.520
 for one of my projects.

20:48.520 --> 20:49.920
 And very quickly I was just like,

20:49.920 --> 20:52.200
 it was in a video and I was basically drawing boxes

20:52.200 --> 20:53.600
 around all these cars.

20:53.600 --> 20:55.640
 And I think I spent about a week doing all of that

20:55.640 --> 20:57.680
 and I barely got anything done.

20:57.680 --> 21:00.320
 And basically this was, I think my first year of my PhD

21:00.320 --> 21:02.720
 at like a second year of my master's.

21:02.720 --> 21:04.040
 And then by the end of it, I'm like, okay,

21:04.040 --> 21:05.040
 this is just hopeless.

21:05.040 --> 21:06.000
 I can keep doing it.

21:06.000 --> 21:08.520
 And when I'd done that, someone came up to me

21:08.520 --> 21:09.600
 and they basically told me,

21:09.600 --> 21:10.880
 oh, this is a pickup truck.

21:10.880 --> 21:11.720
 This is not a car.

21:12.800 --> 21:14.840
 And that's like, aha, this actually makes sense

21:14.840 --> 21:16.160
 because a pickup truck is not really like,

21:16.160 --> 21:17.040
 what was I annotating?

21:17.040 --> 21:19.600
 Was I annotating anything that is mobile?

21:19.600 --> 21:21.440
 Or was I annotating particular sedans

21:21.440 --> 21:22.680
 or was I annotating SUVs?

21:22.680 --> 21:23.640
 What was I doing?

21:23.640 --> 21:25.760
 By the way, the annotation was bounding boxes?

21:25.760 --> 21:27.000
 Bounding boxes.

21:27.000 --> 21:30.080
 There's so many deep, profound questions here.

21:30.080 --> 21:32.200
 You're almost cheating your way out of

21:32.200 --> 21:34.440
 by doing self supervised learning, by the way,

21:34.440 --> 21:37.520
 which is like, what makes for an object?

21:37.520 --> 21:39.080
 As opposed to solve intelligence,

21:39.080 --> 21:42.480
 maybe you don't ever need to answer that question.

21:42.480 --> 21:44.160
 I mean, this is the question that anyone

21:44.160 --> 21:47.240
 that's ever done annotation because it's so painful

21:47.240 --> 21:51.960
 gets to ask like, why am I doing a drawing

21:51.960 --> 21:55.480
 very careful line around this object?

21:55.480 --> 21:57.560
 Like what is the value?

21:57.560 --> 22:00.240
 I remember when I first saw semantic segmentation

22:00.240 --> 22:03.680
 where you have like instant segmentation

22:03.680 --> 22:06.280
 where you have a very exact line

22:06.280 --> 22:09.560
 around the object in a 2D plane

22:09.560 --> 22:13.480
 of a fundamentally 3D object projected on a 2D plane.

22:13.480 --> 22:15.840
 So you're drawing a line around a car

22:15.840 --> 22:17.000
 that might be occluded.

22:17.000 --> 22:18.880
 There might be another thing in front of it,

22:18.880 --> 22:20.400
 but you're still drawing the line

22:20.400 --> 22:22.740
 of the part of the car that you see.

22:23.680 --> 22:26.280
 How is that the car?

22:26.280 --> 22:27.920
 Why is that the car?

22:27.920 --> 22:31.080
 Like I had like an existential crisis every time.

22:31.080 --> 22:33.600
 Like how is that going to help us understand

22:33.600 --> 22:35.400
 a solve computer vision?

22:35.400 --> 22:38.320
 I'm not sure I have a good answer to what's better.

22:38.320 --> 22:41.600
 And I'm not sure I share the confidence that you have

22:41.600 --> 22:46.600
 that self supervised learning can take us far.

22:46.760 --> 22:48.680
 I think I'm more and more convinced

22:48.680 --> 22:50.920
 that it's a very important component,

22:50.920 --> 22:54.240
 but I still feel like we need to understand what makes,

22:54.240 --> 22:59.240
 like this dream of maybe what it's called symbolic AI

23:01.440 --> 23:05.600
 of arriving, like once you have this common sense base,

23:05.600 --> 23:09.040
 be able to play with these concepts

23:09.040 --> 23:13.480
 and build graphs or hierarchies of concepts on top

23:13.480 --> 23:18.480
 in order to then form a deep sense

23:18.840 --> 23:22.080
 of this three dimensional world or four dimensional world

23:22.080 --> 23:24.480
 and be able to reason and then project that

23:24.480 --> 23:28.560
 onto 2D playing in order to interpret a 2D image.

23:28.560 --> 23:31.000
 Can I ask you just an out there question?

23:31.000 --> 23:35.040
 I remember, I think Andre Capati had a blog post

23:35.040 --> 23:39.040
 about computer vision, like being really hard.

23:39.040 --> 23:42.120
 I forgot what the title was, but it's many, many years ago.

23:42.120 --> 23:44.800
 And he had, I think President Obama stepping on a scale

23:44.800 --> 23:46.600
 and there was humor and there was a bunch of people

23:46.600 --> 23:48.480
 laughing and whatever.

23:48.480 --> 23:52.040
 And there's a lot of interesting things about that image

23:52.040 --> 23:55.160
 and I think Andre highlighted a bunch of things

23:55.160 --> 23:57.680
 about the image that us humans are able to immediately

23:57.680 --> 24:00.960
 understand, like the idea, I think of gravity

24:00.960 --> 24:04.080
 and that you can, you have the concept of a weight.

24:04.080 --> 24:06.560
 You have a, you immediately project,

24:06.560 --> 24:08.160
 because of our knowledge of pose

24:08.160 --> 24:10.360
 and how human bodies are constructed,

24:10.360 --> 24:13.040
 you understand how the forces are being applied

24:13.040 --> 24:14.600
 with the human body.

24:14.600 --> 24:15.560
 They're really interesting.

24:15.560 --> 24:17.440
 Other thing that you're able to understand

24:17.440 --> 24:20.520
 is multiple people looking at each other in the image.

24:20.520 --> 24:22.360
 You're able to have a mental model

24:22.360 --> 24:23.760
 of what the people are thinking about.

24:23.760 --> 24:26.960
 You're able to infer like, oh, this person is probably

24:26.960 --> 24:31.240
 thinks like is laughing at how humorous the situation is.

24:31.240 --> 24:34.200
 And this person is confused about what the situation is

24:34.200 --> 24:35.600
 because they're looking this way.

24:35.600 --> 24:37.560
 We're able to infer all of that.

24:37.560 --> 24:40.480
 So that's human vision.

24:41.400 --> 24:45.040
 How difficult is computer vision?

24:45.040 --> 24:48.440
 Like in order to achieve that level of understanding

24:48.440 --> 24:51.440
 and maybe how big of a part

24:51.440 --> 24:54.400
 does self supervised learning play in that, do you think?

24:54.400 --> 24:56.440
 And do you still, you know, back,

24:56.440 --> 24:58.440
 that was like over a decade ago,

24:58.440 --> 25:00.960
 I think Andre and I think a lot of people agreed

25:00.960 --> 25:03.360
 is computer vision is really hard.

25:03.360 --> 25:06.000
 Do you still think computer vision is really hard?

25:06.000 --> 25:07.520
 I think it is, yes.

25:07.520 --> 25:10.600
 And getting to that kind of understanding,

25:10.600 --> 25:12.480
 I mean, it's really out there.

25:12.480 --> 25:15.360
 So if you ask me to solve just that particular problem,

25:15.360 --> 25:17.560
 I can do it the supervised learning route.

25:17.560 --> 25:19.720
 I can always construct a data set and basically predict,

25:19.720 --> 25:21.600
 oh, is there humor in this or not?

25:21.600 --> 25:22.600
 And of course I can do it.

25:22.600 --> 25:23.560
 Actually, that's a good question.

25:23.560 --> 25:25.200
 Do you think you can, okay, okay.

25:25.200 --> 25:28.120
 Do you think you can do human supervised annotation

25:28.120 --> 25:29.040
 of humor?

25:29.040 --> 25:29.960
 To some extent, yes.

25:29.960 --> 25:30.880
 I'm sure it'll work.

25:30.880 --> 25:34.400
 I mean, it won't be as bad as like randomly guessing.

25:34.400 --> 25:36.200
 I'm sure it can still predict whether it's humorous

25:36.200 --> 25:37.840
 or not in some way.

25:37.840 --> 25:40.400
 Yeah, maybe like Reddit upvotes is the signal.

25:40.400 --> 25:41.240
 I don't know.

25:41.240 --> 25:43.800
 I mean, it won't do a great job, but it'll do something.

25:43.800 --> 25:46.040
 It may actually be like it may find certain things

25:46.040 --> 25:47.560
 which are not humorous, humorous as well,

25:47.560 --> 25:49.160
 which is going to be bad for us.

25:49.160 --> 25:52.120
 But I mean, it'll do a, it won't be random.

25:52.120 --> 25:54.520
 Yeah, kind of like my sense of humor.

25:54.520 --> 25:55.920
 Okay, so fine.

25:55.920 --> 25:57.520
 So you can, that particular problem, yes.

25:57.520 --> 25:59.600
 But the general problem you're saying is hard.

25:59.600 --> 26:00.480
 The general problem is hard.

26:00.480 --> 26:02.320
 And I mean, self supervised learning

26:02.320 --> 26:03.920
 is not the answer to everything.

26:03.920 --> 26:04.760
 Of course it's not.

26:04.760 --> 26:07.800
 I think if you have machines that are going to communicate

26:07.800 --> 26:08.760
 with humans at the end of it,

26:08.760 --> 26:10.880
 you want to understand what the algorithm is doing, right?

26:10.880 --> 26:13.720
 You want it to be able to like produce an output

26:13.720 --> 26:15.600
 that you can decipher, that you can understand,

26:15.600 --> 26:17.480
 or it's actually useful for something else,

26:17.480 --> 26:19.360
 which again is a human.

26:19.360 --> 26:22.280
 So at some point in this sort of entire loop,

26:22.280 --> 26:23.720
 a human steps in.

26:23.720 --> 26:26.760
 And now this human needs to understand what's going on.

26:26.760 --> 26:28.960
 And at that point, this entire notion of language

26:28.960 --> 26:30.440
 or semantics really comes in.

26:30.440 --> 26:32.600
 If the machine just spits out something,

26:32.600 --> 26:34.000
 and if we can't understand it,

26:34.000 --> 26:36.280
 then it's not really that useful for us.

26:36.280 --> 26:38.440
 So self supervised learning is probably going to be useful

26:38.440 --> 26:40.760
 for a lot of the things before that part.

26:40.760 --> 26:42.880
 Before the machine really needs to communicate

26:42.880 --> 26:46.120
 a particular kind of output with a human.

26:46.120 --> 26:47.840
 Because I mean, otherwise,

26:47.840 --> 26:49.960
 how is it going to do that without language?

26:49.960 --> 26:51.920
 Or some kind of communication,

26:51.920 --> 26:53.680
 but you're saying that it's possible to build

26:53.680 --> 26:57.240
 a big base of understanding or whatever of,

26:57.240 --> 26:58.080
 what's it about?

26:58.080 --> 26:58.920
 Concepts.

26:58.920 --> 26:59.760
 Concepts, yeah.

26:59.760 --> 27:02.320
 Of like common sense concepts.

27:02.320 --> 27:06.160
 Supervised learning in the context of computer vision

27:06.160 --> 27:07.560
 is something you focused on,

27:07.560 --> 27:09.040
 but that's a really hard domain.

27:09.040 --> 27:10.520
 And it's kind of the cutting edge

27:10.520 --> 27:13.080
 of what we're as a community working on today.

27:13.080 --> 27:14.800
 Can we take a little bit of a step back

27:14.800 --> 27:16.360
 and look at language?

27:16.360 --> 27:19.040
 Can you summarize the history of success

27:19.040 --> 27:20.480
 of self supervised learning

27:20.480 --> 27:23.920
 in natural language processing, language modeling?

27:23.920 --> 27:25.640
 What are transformers?

27:25.640 --> 27:28.800
 What is the masking, the sentence completion

27:28.800 --> 27:30.040
 that you mentioned before?

27:31.040 --> 27:33.600
 How does it lead us to understand anything?

27:33.600 --> 27:34.880
 Semantic meaning of words,

27:34.880 --> 27:37.680
 syntactic role of words and sentences.

27:37.680 --> 27:40.760
 So I'm of course not the expert in NLP.

27:40.760 --> 27:43.520
 I kind of follow it a little bit from the sides.

27:43.520 --> 27:45.800
 So the main sort of reason

27:45.800 --> 27:47.440
 why all of this masking stuff works

27:47.440 --> 27:49.920
 is I think it's called the distributional hypothesis

27:49.920 --> 27:50.920
 in NLP.

27:50.920 --> 27:52.680
 The idea basically being that words

27:52.680 --> 27:54.440
 that occur in the same context

27:54.440 --> 27:56.000
 should have similar meaning.

27:56.000 --> 27:59.080
 So if you have the blank jumped over the blank,

27:59.080 --> 28:02.000
 it basically whatever is like in the first blank

28:02.000 --> 28:04.160
 is basically an object that can actually jump

28:04.160 --> 28:05.880
 is going to be something that can jump.

28:05.880 --> 28:08.360
 So a cat or a dog or I don't know, sheep, something,

28:08.360 --> 28:09.720
 all of these things can basically be

28:09.720 --> 28:11.680
 in that particular context.

28:11.680 --> 28:13.440
 And now so essentially the idea is that

28:13.440 --> 28:16.080
 if you have words that are in the same context

28:16.080 --> 28:17.360
 and you predict them,

28:17.360 --> 28:20.040
 you're going to learn a lots of useful things

28:20.040 --> 28:21.520
 about how words are related

28:21.520 --> 28:23.600
 because you're predicting by looking at their context

28:23.600 --> 28:24.920
 what the word is going to be.

28:24.920 --> 28:26.200
 So in this particular case,

28:26.200 --> 28:28.280
 the blank jumped over the fence.

28:28.280 --> 28:29.680
 So now if it's a sheep,

28:29.680 --> 28:30.960
 the sheep jumped over the fence,

28:30.960 --> 28:32.440
 the dog jumped over the fence.

28:32.440 --> 28:34.400
 So essentially the algorithm

28:34.400 --> 28:36.520
 or the representation basically puts together

28:36.520 --> 28:37.640
 these two concepts together.

28:37.640 --> 28:40.280
 So it says, okay, dogs are going to be kind of slated to sheep

28:40.280 --> 28:42.760
 because both of them occur in the same context.

28:42.760 --> 28:44.480
 Of course, now you can decide

28:44.480 --> 28:46.800
 depending on your particular application downstream,

28:46.800 --> 28:49.200
 you can say that dogs are absolutely not related to sheep

28:49.200 --> 28:53.040
 because well, I really care about dog food, for example.

28:53.040 --> 28:54.240
 I'm a dog food person

28:54.240 --> 28:55.640
 and I really want to give this dog food

28:55.640 --> 28:57.320
 to this particular animal.

28:57.320 --> 29:00.120
 So depending on what your downstream application is,

29:00.120 --> 29:02.120
 of course, this notion of similarity

29:02.120 --> 29:03.960
 or this notion or this common sense

29:03.960 --> 29:05.840
 that you've learned may not be applicable.

29:05.840 --> 29:08.080
 But the point is basically that this,

29:08.080 --> 29:09.960
 just predicting what the blanks are

29:09.960 --> 29:11.760
 is going to take you really, really far.

29:11.760 --> 29:14.040
 So there's a nice feature of language

29:14.040 --> 29:18.720
 that the number of words in a particular language

29:18.720 --> 29:20.800
 is very large, but it's finite

29:20.800 --> 29:22.080
 and it's actually not that large

29:22.080 --> 29:24.160
 in the grand scheme of things.

29:24.160 --> 29:26.560
 I still got up because we take it for granted.

29:26.560 --> 29:28.400
 So first of all, when you say masking,

29:28.400 --> 29:30.120
 you're talking about this very process

29:30.120 --> 29:33.440
 of the blank of removing words from a sentence

29:33.440 --> 29:36.760
 and then having the knowledge of what word went there

29:36.760 --> 29:38.520
 in the initial data set.

29:38.520 --> 29:41.080
 That's the ground truth that you're training on

29:41.080 --> 29:43.440
 and then you're asking the neural network

29:43.440 --> 29:45.080
 to predict where it goes there.

29:46.560 --> 29:49.240
 That's like a little trick.

29:49.240 --> 29:50.880
 It's a really powerful trick.

29:50.880 --> 29:53.320
 The question is how far that takes us

29:53.320 --> 29:56.280
 and the other question is, is there other tricks?

29:56.280 --> 29:58.680
 Because to me, it's very possible

29:58.680 --> 30:00.720
 there's other very fascinating tricks.

30:00.720 --> 30:05.200
 I'll give you an example in autonomous driving,

30:05.200 --> 30:06.920
 there's a bunch of tricks

30:06.920 --> 30:10.360
 that give you the self supervised signal back.

30:10.360 --> 30:14.440
 For example, very similar to sentences,

30:14.440 --> 30:18.600
 but not really, which is you have signals

30:18.600 --> 30:20.240
 from humans driving the car

30:20.240 --> 30:23.640
 because a lot of us drive cars to places.

30:23.640 --> 30:27.800
 And so you can ask the neural network to predict

30:27.800 --> 30:30.240
 what's going to happen the next two seconds

30:30.240 --> 30:33.400
 for a safe navigation through the environment.

30:33.400 --> 30:36.200
 And the signal is comes from the fact

30:36.200 --> 30:38.640
 that you also have knowledge of what happened

30:38.640 --> 30:40.040
 in the next two seconds

30:40.040 --> 30:42.160
 because you have video of the data.

30:42.160 --> 30:46.760
 The question in autonomous driving, as it is in language,

30:46.760 --> 30:50.160
 can we learn how to drive autonomously

30:50.160 --> 30:53.480
 based on that kind of self supervision?

30:53.480 --> 30:55.360
 Probably the answer is no.

30:55.360 --> 30:57.760
 The question is how good can we get?

30:57.760 --> 31:00.080
 And the same with language, how good can we get?

31:00.080 --> 31:02.160
 And are there other tricks?

31:02.160 --> 31:03.840
 Like we get sometimes super excited

31:03.840 --> 31:05.720
 by this trick that works really well.

31:05.720 --> 31:09.120
 But I wonder, it's almost like mining for gold.

31:09.120 --> 31:12.760
 I wonder how many signals there are in the data

31:12.760 --> 31:15.760
 that could be leveraged that are like there, right?

31:15.760 --> 31:18.600
 Is that, I just want to kind of linger on that

31:18.600 --> 31:20.840
 because sometimes it's easy to think

31:20.840 --> 31:24.840
 that maybe this masking process is self supervised learning.

31:24.840 --> 31:27.200
 No, it's only one method.

31:27.200 --> 31:29.280
 So there could be many, many other methods,

31:29.280 --> 31:32.160
 many tricky methods,

31:32.160 --> 31:35.440
 maybe interesting ways to leverage human computation

31:35.440 --> 31:36.880
 in very interesting ways

31:36.880 --> 31:39.920
 that might actually border on semi supervised learning,

31:39.920 --> 31:40.840
 something like that.

31:40.840 --> 31:43.480
 Obviously the internet is generated by humans

31:43.480 --> 31:44.720
 at the end of the day.

31:44.720 --> 31:48.760
 So all that to say is what's your sense

31:48.760 --> 31:50.720
 in this particular context of language,

31:50.720 --> 31:54.680
 how far can that masking process take us?

31:54.680 --> 31:56.240
 So it has stood the test of time, right?

31:56.240 --> 31:59.800
 I mean, so Word2Vec, the initial sort of NLP technique

31:59.800 --> 32:02.120
 that was using this to now, for example,

32:02.120 --> 32:04.920
 like all the BERT and all these big models

32:04.920 --> 32:07.560
 that we get, BERT and Roberta, for example,

32:07.560 --> 32:08.760
 all of them are still sort of based

32:08.760 --> 32:10.600
 on the same principle of masking.

32:10.600 --> 32:12.120
 It's taken us really far.

32:12.120 --> 32:14.400
 I mean, you can actually do things like,

32:14.400 --> 32:16.240
 oh, these two sentences are similar or not,

32:16.240 --> 32:18.680
 whether this particular sentence follows this other sentence

32:18.680 --> 32:20.480
 in terms of logic, so entailment.

32:20.480 --> 32:22.440
 You can do a lot of these things with this,

32:22.440 --> 32:23.640
 just this masking trick.

32:23.640 --> 32:28.360
 Yeah, so I'm not sure if I can predict how far it can take us

32:28.360 --> 32:31.520
 because when it first came out, when Word2Vec was out,

32:31.520 --> 32:33.520
 I don't think a lot of us would have imagined

32:33.520 --> 32:36.000
 that this would actually help us do some kind

32:36.000 --> 32:38.560
 of entailment problems and really that well.

32:38.560 --> 32:40.960
 And so just the fact that by just scaling up

32:40.960 --> 32:42.360
 the amount of data that we're training on

32:42.360 --> 32:45.160
 and using better and more powerful neural network

32:45.160 --> 32:47.600
 architectures has taken us from that to this,

32:47.600 --> 32:52.600
 is just showing you how maybe poor predictors we are,

32:52.600 --> 32:54.840
 as humans, how poor we are at predicting

32:54.840 --> 32:57.360
 how successful a particular technique is going to be.

32:57.360 --> 32:58.680
 So I think I can say something now,

32:58.680 --> 33:00.040
 but like 10 years from now,

33:00.040 --> 33:02.760
 I look completely stupid basically predicting this.

33:02.760 --> 33:07.120
 In the language domain, is there something in your work

33:07.120 --> 33:09.520
 that you find useful and insightful

33:09.520 --> 33:12.520
 and transferable to computer vision,

33:12.520 --> 33:15.720
 but also just, I don't know, beautiful and profound

33:15.720 --> 33:18.120
 that I think carries through to the vision domain?

33:18.120 --> 33:21.000
 I mean, the idea of masking has been very powerful.

33:21.000 --> 33:23.720
 It has been used in vision as well for predicting,

33:23.720 --> 33:25.360
 like you say, the next sort of,

33:25.360 --> 33:27.240
 if you have in sort of frames,

33:27.240 --> 33:29.400
 then you predict what's going to happen in the next frame.

33:29.400 --> 33:31.000
 So that's been very powerful.

33:31.000 --> 33:32.920
 In terms of modeling, like in just terms

33:32.920 --> 33:33.800
 in terms of architecture,

33:33.800 --> 33:36.920
 I think you would ask about transformers while back.

33:36.920 --> 33:38.360
 That has really become,

33:38.360 --> 33:40.840
 like it has become super exciting for computer vision now.

33:40.840 --> 33:42.800
 Like in the past, I would say year and a half,

33:42.800 --> 33:44.200
 it's become really powerful.

33:44.200 --> 33:45.240
 What's a transformer?

33:45.240 --> 33:46.080
 Right.

33:46.080 --> 33:47.440
 I mean, the core part of a transformer

33:47.440 --> 33:49.040
 is something called the self attention model.

33:49.040 --> 33:50.480
 So it came out of Google.

33:50.480 --> 33:53.800
 And the idea basically is that if you have N elements,

33:53.800 --> 33:55.280
 what you're creating is a way

33:55.280 --> 33:57.920
 for all of these N elements to talk to each other.

33:57.920 --> 34:01.840
 So the idea basically is that you are paying attention.

34:01.840 --> 34:03.200
 Each element is paying attention

34:03.200 --> 34:05.000
 to each of the other element.

34:05.000 --> 34:06.800
 And basically by doing this,

34:06.800 --> 34:09.000
 it's really trying to figure out,

34:09.000 --> 34:11.480
 you're basically getting a much better view of the data.

34:11.480 --> 34:14.520
 So for example, if you have a sentence of like four words,

34:14.520 --> 34:16.360
 the point is if you get a representation

34:16.360 --> 34:18.360
 or a feature for this entire sentence,

34:18.360 --> 34:19.800
 it's constructed in a way

34:19.800 --> 34:22.120
 such that each word has paid attention

34:22.120 --> 34:23.840
 to everything else.

34:23.840 --> 34:26.120
 Now, the reason it's like different from say,

34:26.120 --> 34:29.000
 what you would do in a ConvNet is basically

34:29.000 --> 34:29.840
 that in the ConvNet,

34:29.840 --> 34:31.400
 you would only pay attention to a local window.

34:31.400 --> 34:33.160
 So each word would only pay attention

34:33.160 --> 34:36.160
 to its next neighbor or like one neighbor after that.

34:36.160 --> 34:37.880
 And the same thing goes for images.

34:37.880 --> 34:40.120
 In images, you would basically pay attention to pixels

34:40.120 --> 34:42.800
 in a three cross three or a seven cross seven neighborhood.

34:42.800 --> 34:43.680
 And that's it.

34:43.680 --> 34:44.840
 Whereas with the transformer,

34:44.840 --> 34:47.400
 that self attention mainly the sort of idea

34:47.400 --> 34:49.680
 is that each element needs to pay attention

34:49.680 --> 34:50.520
 to each other element.

34:50.520 --> 34:52.040
 And when you say attention,

34:52.040 --> 34:53.440
 maybe another way to phrase that

34:53.440 --> 34:57.720
 is you're considering a context,

34:57.720 --> 35:01.600
 a wide context in terms of the wide context of the sentence

35:01.600 --> 35:05.200
 in understanding the meaning of a particular word

35:05.200 --> 35:06.200
 and a computer vision.

35:06.200 --> 35:07.920
 That's understanding a larger context

35:07.920 --> 35:10.080
 to understand the local pattern

35:10.080 --> 35:13.120
 of a particular local part of an image.

35:13.120 --> 35:13.960
 Right.

35:13.960 --> 35:15.000
 So basically if you have say,

35:15.000 --> 35:16.560
 again a banana in the image,

35:16.560 --> 35:18.640
 you're looking at the full image first.

35:18.640 --> 35:19.960
 So whether it's like,

35:19.960 --> 35:22.200
 you're looking at all the pixels that are off a kitchen

35:22.200 --> 35:23.800
 or for dining table and so on.

35:23.800 --> 35:25.960
 And then you're basically looking at the banana also.

35:25.960 --> 35:26.800
 Yeah.

35:26.800 --> 35:28.200
 By the way, in terms of if we were to train

35:28.200 --> 35:29.240
 the funny classifier,

35:29.240 --> 35:32.000
 there's something funny about the word banana.

35:32.000 --> 35:34.600
 Just wanted to anticipate that my my

35:34.600 --> 35:36.280
 I am wearing a banana shirt.

35:36.280 --> 35:37.480
 Is there bananas on it?

35:39.760 --> 35:42.440
 Okay. So masking has worked for the vision context as well.

35:42.440 --> 35:44.320
 And so this transformer idea has worked as well.

35:44.320 --> 35:46.280
 So basically looking at all the elements

35:46.280 --> 35:48.120
 to understand a particular element

35:48.120 --> 35:49.880
 has been really powerful in vision.

35:49.880 --> 35:52.040
 The reason is like a lot of things

35:52.040 --> 35:53.440
 when you're looking at them in isolation.

35:53.440 --> 35:55.560
 So if you look at just a blob of pixels.

35:55.560 --> 35:57.600
 So Antonio Torralba at MIT used to have this

35:57.600 --> 35:58.920
 like really famous image,

35:58.920 --> 36:01.000
 which I looked at when I was a PhD student,

36:01.000 --> 36:02.800
 where he would basically have a blob of pixels

36:02.800 --> 36:03.640
 and he would ask you,

36:03.640 --> 36:04.920
 Hey, what is this?

36:04.920 --> 36:06.800
 And it looked basically like a shoe

36:06.800 --> 36:08.840
 or like it could look like a TV remote.

36:08.840 --> 36:10.040
 It could look like anything.

36:10.040 --> 36:12.320
 And it turns out it was a beer bottle.

36:12.320 --> 36:13.160
 But I'm not sure.

36:13.160 --> 36:14.080
 It was one of these three things,

36:14.080 --> 36:15.400
 but basically he showed you the full picture

36:15.400 --> 36:17.520
 and then it was very obvious what it was.

36:17.520 --> 36:18.440
 But the point is,

36:18.440 --> 36:20.560
 just by looking at that particular local window,

36:20.560 --> 36:21.880
 you couldn't figure out

36:21.880 --> 36:22.880
 because of resolution,

36:22.880 --> 36:23.880
 because of other things,

36:23.880 --> 36:26.080
 it's just not easy always to just figure out

36:26.080 --> 36:27.960
 by looking at just the neighborhood of pixels,

36:27.960 --> 36:29.680
 what these pixels are.

36:29.680 --> 36:32.000
 And the same thing happens for language as well.

36:32.000 --> 36:33.920
 For the parameters that have to learn

36:33.920 --> 36:35.160
 something about the data,

36:35.160 --> 36:37.160
 you need to give it the capacity

36:37.160 --> 36:39.160
 to learn the essential things.

36:39.160 --> 36:42.680
 Like if it's not actually able to receive the signal at all,

36:42.680 --> 36:44.280
 then it's not going to be able to learn that signal.

36:44.280 --> 36:45.920
 And in order to understand images,

36:45.920 --> 36:47.280
 to understand language,

36:47.280 --> 36:50.680
 you have to be able to see words in their full context.

36:50.680 --> 36:52.000
 Okay.

36:52.000 --> 36:53.280
 What is harder to solve?

36:53.280 --> 36:54.920
 Vision or language?

36:54.920 --> 36:57.840
 Visual intelligence or linguistic intelligence?

36:57.840 --> 36:59.800
 So I'm going to say computer vision is harder.

36:59.800 --> 37:01.520
 My reason for this is basically that

37:02.760 --> 37:04.960
 language of course has a big structure to it

37:04.960 --> 37:06.840
 because we developed it.

37:06.840 --> 37:08.680
 Whereas vision is something that is common

37:08.680 --> 37:09.920
 in a lot of animals.

37:09.920 --> 37:11.440
 Everyone is able to get by,

37:11.440 --> 37:12.880
 a lot of these animals on Earth

37:12.880 --> 37:15.080
 are actually able to get by without language.

37:15.080 --> 37:16.480
 And a lot of these animals,

37:16.480 --> 37:18.280
 we also deem to be intelligent.

37:18.280 --> 37:20.920
 So clearly intelligence does have

37:20.920 --> 37:22.520
 like a visual component to it.

37:22.520 --> 37:24.240
 And yes, of course in the case of humans,

37:24.240 --> 37:26.400
 it of course also has a linguistic component.

37:26.400 --> 37:28.720
 But it means that there is something far more fundamental

37:28.720 --> 37:30.840
 about vision than there is about language.

37:30.840 --> 37:32.960
 And I'm sorry to anyone who disagrees,

37:32.960 --> 37:34.400
 but yes, this is what I feel.

37:34.400 --> 37:36.960
 So that's being a little bit reflected

37:36.960 --> 37:40.800
 in the challenges that have to do with the progress

37:40.800 --> 37:42.520
 of self supervised learning, would you say?

37:42.520 --> 37:45.560
 Or is that just the peculiar accidents

37:45.560 --> 37:47.400
 of the progress of the AI community

37:47.400 --> 37:48.640
 that we focused on?

37:48.640 --> 37:50.280
 Or we discovered self attention

37:50.280 --> 37:53.640
 and transformers in the context of language first.

37:53.640 --> 37:57.320
 So like the self supervised learning success was actually,

37:57.320 --> 37:59.960
 for vision has not much to do with the transformers part.

37:59.960 --> 38:02.480
 I would say it's actually been independent a little bit.

38:02.480 --> 38:03.960
 I think it's just that the signal

38:03.960 --> 38:06.760
 was a little bit different for vision

38:06.760 --> 38:08.120
 than there was for like NLP

38:08.120 --> 38:11.240
 and probably NLP folks discovered it before.

38:11.240 --> 38:12.680
 So for vision, the main success

38:12.680 --> 38:14.800
 has basically been this like crops so far,

38:14.800 --> 38:16.960
 like taking different crops of images.

38:16.960 --> 38:18.920
 Whereas for NLP, it was this masking thing.

38:18.920 --> 38:20.480
 But also the level of success

38:20.480 --> 38:22.080
 is still much higher for language.

38:22.080 --> 38:22.920
 Yes, it has.

38:22.920 --> 38:24.760
 So that has a lot to do with,

38:24.760 --> 38:26.920
 I mean, I can get into a lot of details.

38:26.920 --> 38:28.520
 For this particular question, let's go for it.

38:28.520 --> 38:32.240
 Okay, so the first thing is language is very structured.

38:32.240 --> 38:34.040
 So you are going to produce a distribution

38:34.040 --> 38:35.920
 over a finite vocabulary.

38:35.920 --> 38:37.680
 English has a finite number of words.

38:37.680 --> 38:39.520
 It's actually not that large.

38:39.520 --> 38:41.600
 And you need to produce basically,

38:41.600 --> 38:42.760
 when you're doing this masking thing,

38:42.760 --> 38:44.160
 all you need to do is basically tell me

38:44.160 --> 38:46.440
 which one of these like 50,000 words it is.

38:46.440 --> 38:47.280
 That's it.

38:47.280 --> 38:49.560
 Now for vision, let's imagine doing the same thing.

38:49.560 --> 38:51.480
 Okay, we're basically going to blank out

38:51.480 --> 38:52.600
 a particular part of the image.

38:52.600 --> 38:54.680
 And we ask the network or this neural network

38:54.680 --> 38:58.080
 to predict what is present in this missing patch.

38:58.080 --> 38:59.960
 It's combinatorially large, right?

38:59.960 --> 39:02.560
 You have 256 pixel values.

39:02.560 --> 39:04.840
 If you're even producing basically a seven cross seven

39:04.840 --> 39:08.000
 or a 14 cross 14 like window of pixels

39:08.000 --> 39:11.360
 at each of these 169 or each of these 49 locations,

39:11.360 --> 39:13.760
 you have 256 values to predict.

39:13.760 --> 39:15.280
 And so it's really, really large.

39:15.280 --> 39:19.000
 And very quickly, the kind of like prediction problems

39:19.000 --> 39:20.840
 that we're setting up are going to be extremely

39:20.840 --> 39:22.800
 like intractable for us.

39:22.800 --> 39:25.000
 And so the thing is for NLP, it has been really successful

39:25.000 --> 39:27.560
 because we are very good at predicting,

39:27.560 --> 39:30.880
 like doing this like distribution over a finite set.

39:30.880 --> 39:33.520
 And the problem is when this set becomes really large,

39:33.520 --> 39:35.560
 we're going to become really, really bad

39:35.560 --> 39:37.000
 at making these predictions.

39:37.000 --> 39:41.040
 And at solving basically this particular set of problems.

39:41.040 --> 39:44.240
 So if you were to do it exactly in the same way

39:44.240 --> 39:47.040
 as NLP for vision, there is very limited success.

39:47.040 --> 39:49.000
 The way stuff is working right now

39:49.000 --> 39:51.680
 is actually not by predicting these masks.

39:51.680 --> 39:53.680
 It's basically by saying that you take these two

39:53.680 --> 39:55.160
 like crops from the image,

39:55.160 --> 39:57.080
 you get a feature representation from it.

39:57.080 --> 39:58.680
 And just saying that these two features,

39:58.680 --> 40:00.440
 so they're like vectors,

40:00.440 --> 40:02.040
 just saying that the distance between these vectors

40:02.040 --> 40:03.240
 should be small.

40:03.240 --> 40:06.600
 And so it's a very different way of learning

40:06.600 --> 40:09.160
 from the visual signal than there is from NLP.

40:09.160 --> 40:11.320
 Okay, the other reason is the distributional hypothesis

40:11.320 --> 40:12.920
 that we talked about for NLP, right?

40:12.920 --> 40:15.160
 So a word given its context,

40:15.160 --> 40:16.760
 basically the context actually supplies a lot

40:16.760 --> 40:18.440
 of meaning to the word.

40:18.440 --> 40:22.280
 Now, because there are just finite number of words

40:22.280 --> 40:25.760
 and there is a finite way in which we compose them,

40:25.760 --> 40:27.440
 of course, the same thing holds for pixels,

40:27.440 --> 40:29.760
 but in language, there's a lot of structure, right?

40:29.760 --> 40:31.000
 So I always say whatever,

40:31.000 --> 40:33.760
 the dash jumped over the fence, for example.

40:33.760 --> 40:36.720
 There are lots of these sentences that you'll get.

40:36.720 --> 40:38.680
 And from this, you can actually look at

40:38.680 --> 40:40.160
 this particular sentence might occur

40:40.160 --> 40:41.480
 in a lot of different contexts as well.

40:41.480 --> 40:44.080
 This exact same sentence might occur in a different context.

40:44.080 --> 40:45.560
 So the sheep jumped over the fence,

40:45.560 --> 40:46.800
 the cat jumped over the fence,

40:46.800 --> 40:48.160
 the dog jumped over the fence.

40:48.160 --> 40:50.440
 So you immediately get a lot of these words,

40:50.440 --> 40:52.720
 which are, because this particular token itself

40:52.720 --> 40:54.840
 has so much meaning, you get a lot of these tokens

40:54.840 --> 40:57.440
 or these words which are actually going to have

40:57.440 --> 41:00.560
 sort of this related meaning across, given this context.

41:00.560 --> 41:02.640
 Whereas for vision, it's much harder.

41:02.640 --> 41:05.600
 Because just by pure, the way we capture images,

41:05.600 --> 41:07.440
 lighting can be different.

41:07.440 --> 41:09.800
 There might be different noise in the sensor.

41:09.800 --> 41:12.200
 So the thing is you're capturing a physical phenomenon

41:12.200 --> 41:13.840
 and then you're basically going through

41:13.840 --> 41:16.360
 a very complicated pipeline of image processing

41:16.360 --> 41:17.440
 and then you're translating that

41:17.440 --> 41:20.400
 into some kind of digital signal.

41:20.400 --> 41:23.520
 Whereas with language, you write it down

41:23.520 --> 41:25.040
 and you transfer it to a digital signal,

41:25.040 --> 41:27.520
 almost like it's a lossless transfer.

41:27.520 --> 41:30.160
 And each of these tokens are very, very well defined.

41:30.160 --> 41:32.840
 There could be a little bit of an argument there

41:32.840 --> 41:36.120
 because language has written down

41:36.120 --> 41:39.400
 is a projection of thought.

41:39.400 --> 41:42.560
 This is one of the open questions is

41:42.560 --> 41:45.480
 if you perfectly can solve language,

41:46.320 --> 41:49.360
 are you getting close to being able to solve,

41:49.360 --> 41:51.840
 easily with flying colors past the Turing test

41:51.840 --> 41:52.840
 kind of thing.

41:52.840 --> 41:56.560
 So that's, it's similar, but different

41:56.560 --> 41:59.760
 and the computer vision problem is in the 2D plane

41:59.760 --> 42:02.680
 is a projection to be to mention a world.

42:02.680 --> 42:05.680
 So perhaps there are similar problems there.

42:05.680 --> 42:06.680
 Maybe this is a good, yeah.

42:06.680 --> 42:08.600
 I think what I'm saying is NLP is not easy.

42:08.600 --> 42:09.560
 Of course, don't get me wrong.

42:09.560 --> 42:12.960
 Like abstract thought expressed in knowledge

42:12.960 --> 42:14.640
 or knowledge basically expressed in language

42:14.640 --> 42:16.760
 is really hard to understand, right?

42:16.760 --> 42:19.200
 I mean, we've been communicating with language for so long

42:19.200 --> 42:22.040
 and it's, it is of course a very complicated concept.

42:22.040 --> 42:25.600
 The thing is, at least getting like some,

42:25.600 --> 42:28.600
 somewhat reasonable, like being able to solve

42:28.600 --> 42:30.960
 some kind of reasonable tasks with language,

42:30.960 --> 42:32.480
 I would say slightly easier than it is

42:32.480 --> 42:33.680
 with computer vision.

42:33.680 --> 42:35.400
 Yeah, I would say, yeah.

42:35.400 --> 42:36.640
 So that's well put.

42:36.640 --> 42:40.880
 I would say getting impressive performance on language

42:40.880 --> 42:43.400
 is easier.

42:43.400 --> 42:45.360
 I feel like for both language and computer vision,

42:45.360 --> 42:49.480
 there's going to be this wall of like,

42:49.480 --> 42:52.280
 like this hump you have to overcome

42:52.280 --> 42:54.840
 to achieve super human level performance

42:54.840 --> 42:56.640
 or human level performance.

42:56.640 --> 43:00.240
 And I feel like for language, that wall is farther away.

43:00.240 --> 43:01.920
 So you can get pretty nice.

43:01.920 --> 43:04.120
 You can do a lot of tricks.

43:04.120 --> 43:06.560
 You can show really impressive performance.

43:06.560 --> 43:09.720
 You can even fool people that you're tweeting

43:09.720 --> 43:11.520
 or you're blog posts writing

43:11.520 --> 43:16.520
 or your question answering has intelligence behind it.

43:16.920 --> 43:21.920
 But to truly demonstrate understanding of dialogue,

43:22.400 --> 43:25.040
 of continuous long form dialogue,

43:25.040 --> 43:28.600
 that would require perhaps big breakthroughs.

43:28.600 --> 43:30.440
 In the same way in computer vision,

43:30.440 --> 43:33.400
 I think the big breakthroughs need to happen earlier

43:33.400 --> 43:36.640
 to achieve impressive performance.

43:36.640 --> 43:38.760
 This might be a good place to, you already mentioned it,

43:38.760 --> 43:41.120
 but what is contrastive learning

43:41.120 --> 43:43.840
 and what are energy based models?

43:43.840 --> 43:46.840
 Contrastive learning is sort of the paradigm of learning

43:46.840 --> 43:50.680
 where the idea is that you are learning this embedding space

43:50.680 --> 43:52.680
 or so you're learning this sort of vector space

43:52.680 --> 43:54.520
 of all your concepts.

43:54.520 --> 43:56.800
 And the way you learn that is basically by contrasting.

43:56.800 --> 43:59.120
 So the idea is that you have a sample,

43:59.120 --> 44:01.000
 you have another sample that's related to it.

44:01.000 --> 44:02.880
 So that's called the positive

44:02.880 --> 44:05.080
 and you have another sample that's not related to it.

44:05.080 --> 44:06.080
 So that's negative.

44:06.080 --> 44:08.320
 So for example, let's just take an NLP

44:08.320 --> 44:10.960
 or in a simple example in computer vision.

44:10.960 --> 44:12.760
 So you have an image of a cat,

44:12.760 --> 44:14.480
 you have an image of a dog

44:14.480 --> 44:16.520
 and for whatever application that you're doing,

44:16.520 --> 44:18.880
 say you're trying to figure out what pets are,

44:18.880 --> 44:20.280
 you think that these two images are related.

44:20.280 --> 44:22.280
 So image of a cat and dog are related,

44:22.280 --> 44:25.400
 but now you have another third image of a banana

44:25.400 --> 44:27.000
 because you don't like that word.

44:27.000 --> 44:28.920
 So now you basically have this banana.

44:28.920 --> 44:30.640
 Thank you for speaking to the crowd.

44:30.640 --> 44:32.560
 And so you take both of these images

44:32.560 --> 44:34.440
 and you take the image from the cat,

44:34.440 --> 44:35.280
 the image from the dog,

44:35.280 --> 44:36.760
 you get a feature from both of them.

44:36.760 --> 44:38.160
 And now what you're training the network to do

44:38.160 --> 44:42.080
 is basically pull both of these features together

44:42.080 --> 44:44.720
 while pushing them away from the feature of a banana.

44:44.720 --> 44:45.840
 So this is the contrastive part.

44:45.840 --> 44:47.840
 So you're contrasting against the banana.

44:47.840 --> 44:51.520
 So there's always this notion of a negative and a positive.

44:51.520 --> 44:54.160
 Now, energy based models are like one way

44:54.160 --> 44:57.480
 that Jan sort of explains a lot of these methods.

44:57.480 --> 45:00.920
 So Jan basically, I think a couple of years or more

45:00.920 --> 45:02.840
 than that, like when I joined Facebook,

45:02.840 --> 45:05.080
 Jan used to keep mentioning this word energy based models.

45:05.080 --> 45:07.200
 And of course, I had no idea what he was talking about.

45:07.200 --> 45:09.680
 So then one day I caught him in one of the conference rooms

45:09.680 --> 45:11.240
 and I'm like, can you please tell me what this is?

45:11.240 --> 45:13.120
 So then like very patiently,

45:13.120 --> 45:15.960
 he sat down with like a marker and a whiteboard.

45:15.960 --> 45:18.280
 And his idea basically is that

45:18.280 --> 45:20.280
 rather than talking about probability distributions,

45:20.280 --> 45:21.920
 you can talk about energies of models.

45:21.920 --> 45:23.960
 So models are trying to minimize certain energies

45:23.960 --> 45:24.960
 in certain space,

45:24.960 --> 45:28.200
 or they're trying to maximize a certain kind of energy.

45:28.200 --> 45:29.760
 And the idea basically is that

45:29.760 --> 45:32.200
 you can explain a lot of the contrastive models,

45:32.200 --> 45:33.880
 GANs for example, which are like

45:33.880 --> 45:36.000
 generative adversarial networks.

45:36.000 --> 45:37.880
 A lot of these modern learning methods

45:37.880 --> 45:39.920
 or VAEs, which are variational autoencoders,

45:39.920 --> 45:41.840
 you can really explain them very nicely

45:41.840 --> 45:43.160
 in terms of an energy function

45:43.160 --> 45:45.320
 that they're trying to minimize or maximize.

45:45.320 --> 45:48.360
 And so by putting this common sort of language

45:48.360 --> 45:49.720
 for all of these models,

45:49.720 --> 45:51.800
 what looks very different in machine learning

45:51.800 --> 45:54.160
 that OVAEs are very different from what GANs are,

45:54.160 --> 45:56.440
 are very different from what contrastive models are,

45:56.440 --> 45:57.560
 you actually get a sense of like,

45:57.560 --> 46:00.120
 oh, these are actually very, very related.

46:00.120 --> 46:02.520
 It's just that the way or the mechanism

46:02.520 --> 46:04.200
 in which they're sort of maximizing

46:04.200 --> 46:07.000
 or minimizing this energy function is slightly different.

46:07.000 --> 46:10.400
 It's revealing the commonalities between all these approaches

46:10.400 --> 46:12.960
 and putting a sexy word on top of it, like energy.

46:12.960 --> 46:15.520
 And so similarities, two things that are similar

46:15.520 --> 46:16.720
 have low energy.

46:16.720 --> 46:20.320
 Like the low energy signifying similarity.

46:20.320 --> 46:21.160
 Right, exactly.

46:21.160 --> 46:23.520
 So basically the idea is that if you were to imagine

46:23.520 --> 46:26.440
 like the embedding as a manifold, a 2D manifold,

46:26.440 --> 46:28.880
 you would get a hill or like a high sort of peak

46:28.880 --> 46:30.560
 in the energy manifold,

46:30.560 --> 46:32.360
 wherever two things are not related.

46:32.360 --> 46:34.040
 And basically you would have like a dip

46:34.040 --> 46:35.480
 where two things are related.

46:35.480 --> 46:37.040
 So you'd get a dip in the manner.

46:37.040 --> 46:40.160
 And in the self supervised context,

46:40.160 --> 46:42.240
 how do you know two things are related

46:42.240 --> 46:44.080
 and two things are not related?

46:44.080 --> 46:44.920
 Right.

46:44.920 --> 46:47.360
 This is where all the sort of ingenuity or tricks comes in,

46:47.360 --> 46:48.200
 right?

46:48.200 --> 46:51.720
 So for example, like you can take the fill in the blank

46:51.720 --> 46:54.400
 problem or you can take in the context problem.

46:54.400 --> 46:55.960
 And what you can say is two words

46:55.960 --> 46:57.840
 that are in the same context are related.

46:57.840 --> 47:00.600
 Two words that are in different contexts are not related.

47:00.600 --> 47:03.040
 For images, basically two crops from the same image

47:03.040 --> 47:06.520
 are related and whereas a third image is not related at all.

47:06.520 --> 47:08.840
 For a video, it can be two frames from that video

47:08.840 --> 47:10.840
 are related because they're likely to contain

47:10.840 --> 47:12.760
 the same sort of concepts in them.

47:12.760 --> 47:14.480
 Whereas a third frame from a different video

47:14.480 --> 47:15.640
 is not related.

47:15.640 --> 47:18.360
 So it basically is, it's a very general term.

47:18.360 --> 47:19.720
 Contrasting learning is nothing really

47:19.720 --> 47:20.920
 to do with self supervised learning.

47:20.920 --> 47:23.280
 It actually is very popular in, for example,

47:23.280 --> 47:25.240
 like any kind of metric learning

47:25.240 --> 47:26.960
 or any kind of embedding learning.

47:26.960 --> 47:28.960
 So it's also used in supervised learning.

47:28.960 --> 47:31.360
 It's also, and the thing is because we are not really

47:31.360 --> 47:34.600
 using labels to get these positive or negative pairs,

47:34.600 --> 47:37.680
 it can basically also be used for self supervised learning.

47:37.680 --> 47:41.080
 So you mentioned one of the ideas in the vision context

47:41.080 --> 47:45.280
 to that works is to have different crops.

47:45.280 --> 47:47.840
 So you could think of that as a way to sort of

47:47.840 --> 47:53.320
 manipulating the data to generate examples that are similar.

47:53.320 --> 47:55.800
 Obviously, there's a bunch of other techniques.

47:55.800 --> 47:59.480
 You mentioned lighting as a very, in images,

47:59.480 --> 48:01.680
 lighting is something that varies a lot

48:01.680 --> 48:04.520
 and you can artificially change those kinds of things.

48:04.520 --> 48:07.720
 There's the whole broad field of data augmentation

48:07.720 --> 48:11.800
 which manipulates images in order to increase arbitrarily

48:11.800 --> 48:13.400
 the size of the data set.

48:13.400 --> 48:15.840
 First of all, what is data augmentation?

48:15.840 --> 48:18.120
 And second of all, what's the role of data augmentation

48:18.120 --> 48:22.000
 in self supervised learning and contrastive learning?

48:22.000 --> 48:24.800
 So data augmentation is just a way, like you said,

48:24.800 --> 48:26.680
 it's basically a way to augment the data.

48:26.680 --> 48:29.320
 So you have say N samples and what you do is

48:29.320 --> 48:32.280
 you basically define some kind of transforms for the sample.

48:32.280 --> 48:34.880
 So you take your say image and then you define a transform

48:34.880 --> 48:38.680
 where you can just increase the colors or the brightness

48:38.680 --> 48:41.320
 of the image or increase or decrease the contrast of the image,

48:41.320 --> 48:44.520
 for example, or take different crops of it.

48:44.520 --> 48:46.240
 So data augmentation is just a process

48:46.240 --> 48:51.080
 to basically perturb the data or augment the data.

48:51.080 --> 48:53.160
 And so it has played a fundamental role

48:53.160 --> 48:55.320
 for computer vision for self supervised learning,

48:55.320 --> 48:58.920
 especially the way most of the current methods

48:58.920 --> 49:02.720
 work contrastive or otherwise is by taking an image,

49:02.720 --> 49:05.320
 in the case of images, is by taking an image

49:05.320 --> 49:08.560
 and then computing basically two perturbations of it.

49:08.560 --> 49:11.480
 So these can be two different crops of the image

49:11.480 --> 49:12.920
 with like different types of lighting

49:12.920 --> 49:15.000
 or different contrast or different colors.

49:15.000 --> 49:17.840
 So you jitter the colors a little bit and so on.

49:17.840 --> 49:21.720
 And now the idea is basically because it's the same object

49:21.720 --> 49:23.440
 or because it's like related concepts

49:23.440 --> 49:25.240
 in both of these perturbations,

49:25.240 --> 49:27.960
 you want the features from both of these perturbations

49:27.960 --> 49:28.920
 to be similar.

49:28.920 --> 49:31.320
 So now you can use a variety of different ways

49:31.320 --> 49:34.200
 to enforce this constraint, like these features being similar.

49:34.200 --> 49:36.040
 You can do this by contrastive learning.

49:36.040 --> 49:38.440
 So basically both of these things are positives,

49:38.440 --> 49:40.440
 a third sort of image is negative.

49:40.440 --> 49:43.480
 You can do this basically by like clustering.

49:43.480 --> 49:46.960
 For example, you can say that both of these images should,

49:46.960 --> 49:48.120
 the features from both of these images

49:48.120 --> 49:50.560
 should belong in the same cluster because they're related.

49:50.560 --> 49:52.280
 Whereas image, like another image

49:52.280 --> 49:53.880
 should belong to a different cluster.

49:53.880 --> 49:55.160
 So there's a variety of different ways

49:55.160 --> 49:57.560
 to basically enforce this particular constraint.

49:57.560 --> 49:59.080
 By the way, when you say features,

49:59.080 --> 50:01.680
 it means there's a very large neural network

50:01.680 --> 50:03.640
 that extracting patterns from the image

50:03.640 --> 50:05.160
 and the kind of patterns that extracts

50:05.160 --> 50:08.440
 should be either identical or very similar.

50:08.440 --> 50:09.640
 That's what that means.

50:09.640 --> 50:11.880
 So the neural network basically takes in the image

50:11.880 --> 50:16.600
 and then outputs a set of basically a vector of numbers.

50:16.600 --> 50:17.720
 And that's the feature.

50:17.720 --> 50:20.840
 And you want this feature for both of these different crops

50:20.840 --> 50:22.120
 that you computed to be similar.

50:22.120 --> 50:24.520
 So you want this vector to be identical

50:24.520 --> 50:26.120
 in its entries, for example.

50:26.120 --> 50:30.040
 Be like literally close in this multidimensional space

50:30.040 --> 50:31.640
 to each other.

50:31.640 --> 50:34.760
 And like you said, close can mean part of the same cluster

50:34.760 --> 50:37.440
 or something like that in this large space.

50:37.440 --> 50:40.680
 First of all, that, I wonder if there is connection

50:40.680 --> 50:43.760
 to the way humans learn to this.

50:43.760 --> 50:48.040
 Almost like maybe subconsciously,

50:48.040 --> 50:50.120
 in order to understand a thing,

50:50.120 --> 50:54.680
 you kind of have to see it from two, three multiple angles.

50:54.680 --> 50:58.120
 I wonder, I have a lot of friends who are neuroscientists

50:58.120 --> 50:59.960
 maybe and cognitive scientists.

50:59.960 --> 51:03.200
 I wonder if that's in there somewhere.

51:03.200 --> 51:08.200
 Like in order for us to place a concept in its proper place,

51:08.560 --> 51:12.440
 we have to basically crop it in all kinds of ways,

51:12.440 --> 51:14.400
 do basic data augmentation on it

51:14.400 --> 51:17.640
 in whatever very clever ways that the brain likes to do.

51:17.640 --> 51:19.000
 Right.

51:19.000 --> 51:21.160
 Like spinning around in our mind somehow

51:21.160 --> 51:23.080
 that that is very effective.

51:23.080 --> 51:25.040
 So I think for some of them, we need to do it.

51:25.040 --> 51:27.000
 So like babies, for example, pick up objects,

51:27.000 --> 51:30.120
 like move them, put them, go sit there and whatnot.

51:30.120 --> 51:31.200
 But for certain other things,

51:31.200 --> 51:33.800
 actually we are good at imagining it as well.

51:33.800 --> 51:35.960
 So if you, I have never seen, for example,

51:35.960 --> 51:36.960
 an elephant from the top.

51:36.960 --> 51:39.560
 I've never basically looked at it from top down.

51:39.560 --> 51:40.720
 But if you showed me a picture of it,

51:40.720 --> 51:43.760
 I could very well tell you that that's an elephant.

51:43.760 --> 51:45.320
 So I think some of it, we just like,

51:45.320 --> 51:47.840
 we naturally build it or transfer it from other objects

51:47.840 --> 51:50.960
 that we've seen to imagine what it's going to look like.

51:50.960 --> 51:53.320
 Has anyone done that with the augmentation?

51:53.320 --> 51:56.960
 Like imagine all the possible things

51:56.960 --> 51:59.920
 that are occluded or not there,

51:59.920 --> 52:03.400
 but not just like normal things, like wild things,

52:03.400 --> 52:05.920
 but they're nevertheless physically consistent.

52:07.000 --> 52:10.800
 So I mean, people do kind of like occlusion based

52:10.800 --> 52:11.840
 augmentation as well.

52:11.840 --> 52:14.800
 So you place in like a random like box, gray box

52:14.800 --> 52:17.480
 to sort of mask out a certain part of the image.

52:17.480 --> 52:20.040
 And the thing is basically you're kind of occluding it.

52:20.040 --> 52:23.600
 For example, you place it say on half of a person's face.

52:23.600 --> 52:24.960
 So basically saying that, you know,

52:24.960 --> 52:26.720
 something below their nose is occluded

52:26.720 --> 52:28.280
 because it's grayed out.

52:28.280 --> 52:29.120
 So, this is kind of.

52:29.120 --> 52:31.680
 No, I meant like, you have like, what is it?

52:31.680 --> 52:34.240
 A table and you can't see behind the table.

52:34.240 --> 52:37.040
 And you imagine there's a bunch of elves

52:37.040 --> 52:38.800
 with bananas behind the table.

52:38.800 --> 52:41.920
 Like I wonder if there's useful to have a,

52:41.920 --> 52:44.160
 a wild imagination for the network.

52:44.160 --> 52:45.280
 Because that's possible.

52:45.280 --> 52:47.280
 Well, maybe not elves, but like puppies

52:47.280 --> 52:48.960
 and kittens or something like that.

52:48.960 --> 52:53.080
 Just have a wild imagination and like constantly

52:53.080 --> 52:55.040
 be generating that wild imagination.

52:55.040 --> 52:57.520
 Cause in terms of data augmentation

52:57.520 --> 53:01.160
 that's currently applied, it's super ultra very boring.

53:01.160 --> 53:02.880
 It's very basic data augmentation.

53:02.880 --> 53:05.240
 I wonder if, I wonder if there's a benefit

53:05.240 --> 53:08.880
 to being wildly imaginable while trying to be

53:08.880 --> 53:11.840
 consistent with physical reality.

53:11.840 --> 53:14.160
 I think it's a kind of a chicken and egg problem, right?

53:14.160 --> 53:16.360
 Because to have like amazing data augmentation,

53:16.360 --> 53:18.480
 you need to understand what the scene is.

53:18.480 --> 53:20.600
 And what we're trying to do data augmentation

53:20.600 --> 53:22.000
 to learn what a scene is anyway.

53:22.000 --> 53:23.680
 So it's basically just keeps going on.

53:23.680 --> 53:26.000
 Before you understand it, just put elves with bananas

53:26.000 --> 53:28.080
 until you know it's not to be true.

53:29.320 --> 53:31.640
 Just like children have a wild imagination

53:31.640 --> 53:33.920
 until the adults ruin it all.

53:33.920 --> 53:34.760
 Okay.

53:34.760 --> 53:36.920
 So what are the different kinds of data augmentation

53:36.920 --> 53:40.760
 that you've seen to be effective in visual intelligence?

53:40.760 --> 53:43.600
 For like vision, it's a lot of these image filtering

53:43.600 --> 53:44.440
 operations.

53:44.440 --> 53:46.720
 So like blurring the image, you know,

53:46.720 --> 53:49.400
 all the kind of Instagram filters that you can think of.

53:49.400 --> 53:52.480
 So like arbitrarily like make the red super red,

53:52.480 --> 53:55.800
 make the green super greens, like saturate the image.

53:55.800 --> 53:56.960
 Rotation cropping.

53:56.960 --> 53:58.000
 Rotation cropping.

53:58.000 --> 53:58.840
 Exactly.

53:58.840 --> 53:59.680
 All of these kind of things.

53:59.680 --> 54:02.640
 Like I said, lighting is a really interesting one to me.

54:02.640 --> 54:04.760
 Like that feels like really complicated to do.

54:04.760 --> 54:07.320
 So I mean, they don't, the augmentations that we work on

54:07.320 --> 54:08.840
 aren't like that involved.

54:08.840 --> 54:10.520
 So they're not going to be like physically realistic

54:10.520 --> 54:11.360
 versions of lighting.

54:11.360 --> 54:13.520
 It's not that you're assuming that there's a light source

54:13.520 --> 54:15.080
 up and then you're moving it to the right.

54:15.080 --> 54:17.000
 And then what does the thing look like?

54:17.000 --> 54:19.160
 It's really more about like brightness of the image,

54:19.160 --> 54:21.440
 overall brightness of the image or overall contrast

54:21.440 --> 54:22.480
 of the image and so on.

54:22.480 --> 54:25.080
 But this is a really important point to me.

54:25.080 --> 54:28.680
 I always thought that data augmentation

54:28.680 --> 54:33.120
 holds an important key to big improvements in machine

54:33.120 --> 54:33.840
 learning.

54:33.840 --> 54:36.640
 And it seems that it is an important aspect

54:36.640 --> 54:39.080
 of self supervised learning.

54:39.080 --> 54:41.480
 So I wonder if there's big improvements

54:41.480 --> 54:45.280
 to be achieved on much more intelligent kinds of data

54:45.280 --> 54:46.680
 augmentation.

54:46.680 --> 54:49.240
 For example, currently, maybe you can correct me

54:49.240 --> 54:53.280
 if I'm wrong, data augmentation is not parametrized.

54:53.280 --> 54:54.400
 You're not learning.

54:54.400 --> 54:55.240
 You're not learning.

54:55.240 --> 54:59.760
 To me, it seems like data augmentation potentially

54:59.760 --> 55:03.360
 should involve more learning than the learning process

55:03.360 --> 55:05.320
 itself.

55:05.320 --> 55:08.800
 You're almost like thinking of like generative kind of,

55:08.800 --> 55:10.200
 it's the elves of bananas.

55:10.200 --> 55:13.240
 You're trying to, it's like very active imagination

55:13.240 --> 55:16.480
 of messing with the world and teaching that mechanism

55:16.480 --> 55:20.440
 for messing with the world to be realistic.

55:20.440 --> 55:24.680
 Because that feels like, I mean, it's imagination.

55:24.680 --> 55:27.240
 Just as you said, it feels like us humans

55:27.240 --> 55:30.680
 are able to maybe sometimes subconsciously

55:30.680 --> 55:33.000
 imagine, before we see the thing,

55:33.000 --> 55:35.480
 imagine what we're expecting to see.

55:35.480 --> 55:37.240
 Like maybe several options.

55:37.240 --> 55:40.480
 And especially, we probably forgot, but when we were younger,

55:40.480 --> 55:42.600
 probably the possibilities were wild.

55:42.600 --> 55:44.160
 There are more numerous.

55:44.160 --> 55:47.360
 And then as we get older, we become to understand the world

55:47.360 --> 55:51.000
 and the possibilities of what we might see

55:51.000 --> 55:53.080
 becomes less and less and less.

55:53.080 --> 55:55.800
 So I wonder if you think there's a lot of breakthroughs yet

55:55.800 --> 55:57.160
 to be had in data augmentation.

55:57.160 --> 55:59.760
 And maybe also, can you just comment on the stuff we have?

55:59.760 --> 56:02.080
 Is that a big part of self supervised learning?

56:02.080 --> 56:02.320
 Yes.

56:02.320 --> 56:05.480
 So data augmentation is like key to self supervised learning.

56:05.480 --> 56:08.240
 That has the kind of augmentation that we're using.

56:08.240 --> 56:10.240
 And basically, the fact that we're

56:10.240 --> 56:12.640
 trying to learn these neural networks that

56:12.640 --> 56:14.520
 are predicting these features from images that

56:14.520 --> 56:17.040
 are robust under data augmentation

56:17.040 --> 56:19.480
 has been the key for visual self supervised learning.

56:19.480 --> 56:22.320
 And they play a fairly fundamental role to it.

56:22.320 --> 56:26.120
 Now, the irony of all of this is that deep learning purists

56:26.120 --> 56:28.360
 will say the entire point of deep learning

56:28.360 --> 56:31.120
 is that you feed in the pixels to the neural network.

56:31.120 --> 56:33.080
 And it should figure out the patterns on its own.

56:33.080 --> 56:34.440
 So if it really wants to look at edges,

56:34.440 --> 56:35.640
 it should look at edges.

56:35.640 --> 56:38.600
 You shouldn't really go and handcraft these features.

56:38.600 --> 56:41.160
 You shouldn't go tell it that look at edges.

56:41.160 --> 56:43.080
 So data augmentation should basically

56:43.080 --> 56:44.400
 be in the same category.

56:44.400 --> 56:47.480
 Why should we tell the network or tell this entire learning

56:47.480 --> 56:49.520
 paradigm what kinds of data augmentation

56:49.520 --> 56:50.840
 that we're looking for?

56:50.840 --> 56:55.200
 We are encoding a very sort of human specific bias there

56:55.200 --> 56:59.160
 that we know things are, if you change the contrast of the image,

56:59.160 --> 57:00.240
 it should still be an apple.

57:00.240 --> 57:02.200
 Or it should still be apple, not banana.

57:02.200 --> 57:03.520
 Thank you.

57:03.520 --> 57:05.960
 Basically, if we change colors, it

57:05.960 --> 57:08.040
 should still be the same kind of concept.

57:08.040 --> 57:09.880
 Of course, this is not one.

57:09.880 --> 57:12.480
 This doesn't feel like super satisfactory,

57:12.480 --> 57:15.720
 because a lot of our human knowledge or our human supervision

57:15.720 --> 57:17.600
 is actually going into the data augmentation.

57:17.600 --> 57:19.680
 So although we are calling it self supervised learning,

57:19.680 --> 57:21.360
 a lot of the human knowledge is actually

57:21.360 --> 57:23.520
 being encoded in the data augmentation process.

57:23.520 --> 57:25.480
 So it's really like we've kind of sneaked away

57:25.480 --> 57:27.120
 the supervision at the input.

57:27.120 --> 57:29.680
 And we're really designing these nice list of data

57:29.680 --> 57:31.640
 augmentations that are working very well.

57:31.640 --> 57:33.720
 Of course, the idea is that it's much easier

57:33.720 --> 57:36.600
 to design a list of data augmentation than it is to do.

57:36.600 --> 57:38.160
 So humans are doing, nevertheless,

57:38.160 --> 57:40.600
 doing less and less work, and maybe leveraging

57:40.600 --> 57:42.640
 their creativity more and more.

57:42.640 --> 57:45.040
 And when we say data augmentation is not parameterized,

57:45.040 --> 57:48.200
 it means it's not part of the learning process.

57:48.200 --> 57:51.320
 Do you think it's possible to integrate some of the data

57:51.320 --> 57:53.280
 augmentation into the learning process?

57:53.280 --> 57:53.880
 I think so.

57:53.880 --> 57:54.280
 I think so.

57:54.280 --> 57:57.400
 And in fact, it will be really beneficial for us,

57:57.400 --> 58:00.360
 because a lot of these data augmentation that we use in vision

58:00.360 --> 58:01.840
 are very extreme.

58:01.840 --> 58:07.240
 For example, when you have certain concepts, again, a banana,

58:07.240 --> 58:09.200
 you take the banana and then basically you

58:09.200 --> 58:10.520
 change the color of the banana.

58:10.520 --> 58:12.440
 So you make it a purple banana.

58:12.440 --> 58:14.160
 Now, this data augmentation process

58:14.160 --> 58:16.320
 is actually independent of the, it

58:16.320 --> 58:18.800
 has no notion of what is present in the image.

58:18.800 --> 58:20.480
 So it can change this color arbitrarily.

58:20.480 --> 58:22.520
 It can make it a red banana as well.

58:22.520 --> 58:23.760
 And now what we're doing is we're

58:23.760 --> 58:27.160
 telling the neural network that this red banana and,

58:27.160 --> 58:29.240
 so a crop of this image which has the red banana

58:29.240 --> 58:31.480
 and a crop of this image where I change the color to a purple

58:31.480 --> 58:34.080
 banana should be, the features should be the same.

58:34.080 --> 58:36.680
 Now bananas are in red or purple, mostly.

58:36.680 --> 58:38.520
 So really the data augmentation process

58:38.520 --> 58:41.120
 should take into account what is present in the image

58:41.120 --> 58:43.720
 and what are the kinds of physical realities that are possible.

58:43.720 --> 58:45.840
 It shouldn't be completely independent of the image.

58:45.840 --> 58:49.960
 So you might get big gains if you, instead of being drastic,

58:49.960 --> 58:53.240
 do subtle augmentation, but realistic augmentation.

58:53.240 --> 58:54.040
 Right, realistic.

58:54.040 --> 58:56.280
 I'm not sure if it's subtle, but realistic for sure.

58:56.280 --> 58:59.560
 If it's realistic, then even subtle augmentation

58:59.560 --> 59:00.640
 will give you big benefits.

59:00.640 --> 59:01.840
 Exactly, yeah.

59:01.840 --> 59:05.040
 And it will be, for particular domains,

59:05.040 --> 59:07.480
 you might actually see, if, for example, now

59:07.480 --> 59:09.040
 we're doing medical imaging, there

59:09.040 --> 59:11.400
 are going to be certain kinds of geometric augmentation

59:11.400 --> 59:15.080
 that are not really going to be very valid for the human body.

59:15.080 --> 59:18.280
 So if you were to actually loop in data augmentation

59:18.280 --> 59:20.480
 into the learning process, it will actually be much more

59:20.480 --> 59:21.440
 useful.

59:21.440 --> 59:24.480
 Now, this actually does take us to maybe a semi supervised

59:24.480 --> 59:27.440
 kind of a setting because you do want to understand

59:27.440 --> 59:29.120
 what is it that you're trying to solve.

59:29.120 --> 59:31.200
 So currently self supervised learning kind of

59:31.200 --> 59:32.720
 operates in the wild, right?

59:32.720 --> 59:34.960
 So you do the self supervised learning,

59:34.960 --> 59:37.800
 and the purists and all of us basically say that, OK,

59:37.800 --> 59:39.440
 this should learn useful representations,

59:39.440 --> 59:42.320
 and they should be useful for any kind of end task,

59:42.320 --> 59:44.280
 no matter it's like banana recognition

59:44.280 --> 59:46.200
 or like autonomous driving.

59:46.200 --> 59:47.760
 Now, it's a tall order.

59:47.760 --> 59:50.760
 Maybe the first baby step for us should be that, OK,

59:50.760 --> 59:52.640
 if you're trying to loop in this data augmentation

59:52.640 --> 59:55.040
 into the learning process, then we at least

59:55.040 --> 59:56.880
 need to have some sense of what we're trying to do.

59:56.880 --> 59:58.800
 Are we trying to distinguish between different types

59:58.800 --> 1:00:01.200
 of bananas, or are we trying to distinguish between banana

1:00:01.200 --> 1:00:04.400
 and apple, or are we trying to do all of these things at once?

1:00:04.400 --> 1:00:07.960
 And so some notion of what happens at the end

1:00:07.960 --> 1:00:10.880
 might actually help us do much better at this side.

1:00:10.880 --> 1:00:14.320
 Let me ask you a ridiculous question.

1:00:14.320 --> 1:00:16.280
 If I were to give you like a black box,

1:00:16.280 --> 1:00:19.200
 like a choice to have an arbitrary large data

1:00:19.200 --> 1:00:23.680
 set of real natural data versus really

1:00:23.680 --> 1:00:26.600
 good data augmentation algorithms,

1:00:26.600 --> 1:00:31.280
 which would you like to train in a self supervised way on?

1:00:31.280 --> 1:00:35.040
 So natural data from the internet are arbitrary large,

1:00:35.040 --> 1:00:37.360
 so unlimited data.

1:00:37.360 --> 1:00:41.760
 Or it's like more controlled, good data augmentation

1:00:41.760 --> 1:00:43.600
 on the finite data set.

1:00:43.600 --> 1:00:45.720
 The thing is like because our learning algorithms

1:00:45.720 --> 1:00:49.360
 for vision right now really rely on data augmentation,

1:00:49.360 --> 1:00:51.880
 even if you were to give me like an infinite source of like

1:00:51.880 --> 1:00:54.520
 image data, I still need a good data augmentation algorithm.

1:00:54.520 --> 1:00:56.040
 You need something that tells you

1:00:56.040 --> 1:00:57.360
 that two things are similar.

1:00:57.360 --> 1:00:58.000
 Right.

1:00:58.000 --> 1:00:59.880
 And so something, because you've given me

1:00:59.880 --> 1:01:01.960
 an arbitrarily large data set, I still

1:01:01.960 --> 1:01:05.320
 need to use data augmentation to take that image, construct

1:01:05.320 --> 1:01:08.240
 like these two perturbations of it, and then learn from it.

1:01:08.240 --> 1:01:09.920
 So the thing is our learning paradigm

1:01:09.920 --> 1:01:11.880
 is very primitive right now.

1:01:11.880 --> 1:01:13.760
 Even if you were to give me lots of images,

1:01:13.760 --> 1:01:15.200
 it's still not really useful.

1:01:15.200 --> 1:01:16.520
 A good data augmentation algorithm

1:01:16.520 --> 1:01:18.120
 is actually going to be more useful.

1:01:18.120 --> 1:01:21.160
 So you can reduce down the amount of data

1:01:21.160 --> 1:01:22.560
 that you give me by like 10 times.

1:01:22.560 --> 1:01:25.040
 But if you were to give me a good data augmentation algorithm,

1:01:25.040 --> 1:01:27.920
 that will probably do better than giving me like 10 times

1:01:27.920 --> 1:01:31.240
 the size of that data, but me having to rely on a very

1:01:31.240 --> 1:01:32.840
 primitive data augmentation algorithm.

1:01:32.840 --> 1:01:35.040
 Through tagging and all those kinds of things,

1:01:35.040 --> 1:01:38.200
 is there a way to discover things that are semantically

1:01:38.200 --> 1:01:39.640
 similar on the internet?

1:01:39.640 --> 1:01:42.560
 Obviously there is, but it might be extremely noisy.

1:01:42.560 --> 1:01:45.800
 And the difference might be farther away

1:01:45.800 --> 1:01:47.840
 than you would be comfortable with.

1:01:47.840 --> 1:01:49.720
 So I mean, yes, tagging will help you a lot.

1:01:49.720 --> 1:01:52.160
 It'll actually go a very long way in figuring out

1:01:52.160 --> 1:01:54.360
 what images are related or not.

1:01:54.360 --> 1:01:57.840
 And then so, but then the purists would argue that when

1:01:57.840 --> 1:02:00.320
 you're using human tags, because these tags are like

1:02:00.320 --> 1:02:03.320
 supervision, is it really really self supervised learning

1:02:03.320 --> 1:02:05.840
 now, because you're using human tags to figure out

1:02:05.840 --> 1:02:08.000
 which images are like similar.

1:02:08.000 --> 1:02:10.440
 Hashtag no filter means a lot of things.

1:02:10.440 --> 1:02:11.320
 Yes.

1:02:11.320 --> 1:02:13.000
 I mean, there are certain tags which are going to be

1:02:13.000 --> 1:02:15.360
 applicable pretty much to anything.

1:02:15.360 --> 1:02:18.320
 So they're pretty useless for learning.

1:02:18.320 --> 1:02:20.880
 But I mean, certain tags are actually like

1:02:20.880 --> 1:02:23.880
 DI filter, for example, or the Taj Mahal, for example.

1:02:23.880 --> 1:02:26.520
 These tags are like very indicative of what's going on.

1:02:26.520 --> 1:02:29.520
 And they are, I mean, they are human supervision.

1:02:29.520 --> 1:02:30.360
 Yeah.

1:02:30.360 --> 1:02:32.800
 This is one of the tasks of discovering from human

1:02:32.800 --> 1:02:35.480
 generated data, strong signals that could be

1:02:35.480 --> 1:02:39.600
 leveraged for self supervision.

1:02:39.600 --> 1:02:42.280
 Like humans are doing so much work already.

1:02:42.280 --> 1:02:45.160
 Like many years ago, there was something that was called,

1:02:45.160 --> 1:02:48.040
 I guess, human computation back in the day.

1:02:48.040 --> 1:02:50.320
 Humans are doing so much work.

1:02:50.320 --> 1:02:53.880
 It'd be exciting to discover ways to leverage the work

1:02:53.880 --> 1:02:57.040
 they're doing to teach machines without any extra

1:02:57.040 --> 1:02:58.000
 effort from them.

1:02:58.000 --> 1:03:00.200
 An example could be, like we said, driving.

1:03:00.200 --> 1:03:03.040
 Humans driving and machines can learn from the driving.

1:03:03.040 --> 1:03:06.800
 I always hope that there could be some supervision signal

1:03:06.800 --> 1:03:09.080
 discovered in video games, because there's so many

1:03:09.080 --> 1:03:11.720
 people that play video games that it feels like

1:03:11.720 --> 1:03:16.520
 so much effort is put into video games, into playing

1:03:16.520 --> 1:03:21.120
 video games, and you can design video games somewhat

1:03:21.120 --> 1:03:24.640
 cheaply to include whatever signals you want.

1:03:24.640 --> 1:03:27.560
 It feels like that could be leveraged somehow.

1:03:27.560 --> 1:03:28.680
 So people are using that.

1:03:28.680 --> 1:03:30.840
 Like there are actually folks right here in UT Austin,

1:03:30.840 --> 1:03:33.760
 like Phillip Crainbull is a professor at UT Austin.

1:03:33.760 --> 1:03:36.760
 He's been working on video games as a source of

1:03:36.760 --> 1:03:38.000
 supervision.

1:03:38.000 --> 1:03:40.040
 I mean, it's really fun, like as a PhD student,

1:03:40.040 --> 1:03:42.200
 getting to basically play video games all day.

1:03:42.200 --> 1:03:44.960
 Yeah, but so I do hope that kind of thing scales.

1:03:44.960 --> 1:03:48.720
 And ultimately, it boils down to discovering some

1:03:48.720 --> 1:03:51.600
 undeniably very good signal.

1:03:51.600 --> 1:03:54.040
 It's like masking in an LP.

1:03:54.040 --> 1:03:57.640
 But that said, there's noncontrastive methods.

1:03:57.640 --> 1:04:01.760
 What do noncontrastive, energy based, self supervised

1:04:01.760 --> 1:04:05.640
 learning methods look like, and why are they promising?

1:04:05.640 --> 1:04:07.800
 So like I said about contrastive learning,

1:04:07.800 --> 1:04:10.720
 you have this notion of a positive and a negative.

1:04:10.720 --> 1:04:13.640
 Now, the thing is, this entire learning paradigm

1:04:13.640 --> 1:04:17.560
 really requires access to a lot of negatives to learn

1:04:17.560 --> 1:04:19.040
 a good sort of feature space.

1:04:19.040 --> 1:04:23.080
 The idea is if I tell you, okay, so a cat and a dog

1:04:23.080 --> 1:04:25.680
 are similar, and they're very different from a banana.

1:04:25.680 --> 1:04:28.000
 The thing is, this is a fairly simple analogy, right?

1:04:28.000 --> 1:04:30.840
 Because bananas look visually very different

1:04:30.840 --> 1:04:32.440
 from what cats and dogs do.

1:04:32.440 --> 1:04:34.520
 So very quickly, if this is the only source of

1:04:34.520 --> 1:04:37.400
 supervision that I'm giving you, your learning is not

1:04:37.400 --> 1:04:39.760
 going to be like, after a point, the neural network

1:04:39.760 --> 1:04:41.640
 is really not going to learn a lot.

1:04:41.640 --> 1:04:42.960
 Because the negative that you're getting

1:04:42.960 --> 1:04:43.880
 is going to be so random.

1:04:43.880 --> 1:04:46.640
 So it can be, oh, a cat and a dog are similar,

1:04:46.640 --> 1:04:49.880
 but they're very different from a Volkswagen Beetle.

1:04:49.880 --> 1:04:51.880
 Now, this car looks very different

1:04:51.880 --> 1:04:52.920
 from these animals again.

1:04:52.920 --> 1:04:54.880
 So the thing is in contrastive learning,

1:04:54.880 --> 1:04:58.120
 the quality of the negative sample really matters a lot.

1:04:58.120 --> 1:05:00.800
 And so what has happened is basically that

1:05:00.800 --> 1:05:02.840
 typically these methods that are contrastive

1:05:02.840 --> 1:05:04.880
 really require access to lots of negatives,

1:05:04.880 --> 1:05:06.880
 which becomes harder and harder to sort of scale

1:05:06.880 --> 1:05:09.000
 when designing a learning algorithm.

1:05:09.000 --> 1:05:10.920
 So that's been one of the reasons

1:05:10.920 --> 1:05:13.680
 why noncontrastive methods have become popular

1:05:13.680 --> 1:05:16.360
 and why people think that they're going to be more useful.

1:05:16.360 --> 1:05:18.440
 So a noncontrastive method, for example,

1:05:18.440 --> 1:05:20.880
 like clustering is one noncontrastive method.

1:05:20.880 --> 1:05:24.640
 The idea basically being that you have two of these samples,

1:05:24.640 --> 1:05:27.640
 so the cat and dog or two crops of this image,

1:05:27.640 --> 1:05:29.120
 they belong to the same cluster.

1:05:30.360 --> 1:05:33.280
 And so essentially you're basically doing clustering online

1:05:33.280 --> 1:05:35.040
 when you're learning this network

1:05:35.040 --> 1:05:36.680
 and which is very different from having access

1:05:36.680 --> 1:05:38.920
 to a lot of negatives explicitly.

1:05:38.920 --> 1:05:40.840
 The other way which has become really popular

1:05:40.840 --> 1:05:43.160
 is something called self distillation.

1:05:43.160 --> 1:05:45.720
 So the idea basically is that you have a teacher network

1:05:45.720 --> 1:05:47.520
 and a student network,

1:05:47.520 --> 1:05:49.520
 and the teacher network produces a feature.

1:05:49.520 --> 1:05:51.080
 So it takes in the image

1:05:51.080 --> 1:05:52.800
 and basically the neural network

1:05:52.800 --> 1:05:55.240
 figures out the patterns, gets the feature out.

1:05:55.240 --> 1:05:56.800
 And there's another neural network

1:05:56.800 --> 1:05:57.960
 which is the student neural network

1:05:57.960 --> 1:05:59.920
 and that also produces a feature.

1:05:59.920 --> 1:06:01.680
 And now all you're doing is basically saying

1:06:01.680 --> 1:06:03.960
 that the features produced by the teacher network

1:06:03.960 --> 1:06:06.120
 and the student network should be very similar.

1:06:06.120 --> 1:06:06.960
 That's it.

1:06:06.960 --> 1:06:09.200
 There is no notion of a negative anymore.

1:06:09.200 --> 1:06:10.040
 And that's it.

1:06:10.040 --> 1:06:11.800
 So it's all about similarity maximization

1:06:11.800 --> 1:06:13.680
 between these two features.

1:06:13.680 --> 1:06:15.760
 And so all I need to now do

1:06:15.760 --> 1:06:18.680
 is figure out how to have these two sorts of parallel networks,

1:06:18.680 --> 1:06:20.600
 a student network and a teacher network.

1:06:20.600 --> 1:06:23.000
 And basically researchers have figured out

1:06:23.000 --> 1:06:24.240
 very cheap methods to do this.

1:06:24.240 --> 1:06:26.760
 So you can actually have for free really

1:06:26.760 --> 1:06:29.000
 two types of neural networks.

1:06:29.000 --> 1:06:30.120
 They're kind of related,

1:06:30.120 --> 1:06:31.400
 but they're different enough

1:06:31.400 --> 1:06:34.000
 that you can actually basically have a learning problem set up.

1:06:34.000 --> 1:06:38.200
 So you can ensure that they always remain different enough

1:06:38.200 --> 1:06:41.040
 so the thing doesn't collapse into something boring.

1:06:41.040 --> 1:06:41.880
 Exactly.

1:06:41.880 --> 1:06:44.360
 So the main sort of enemy of self supervised learning,

1:06:44.360 --> 1:06:47.560
 any kind of similarity maximization technique is collapse.

1:06:47.560 --> 1:06:49.840
 It's a collapse means that you learn

1:06:49.840 --> 1:06:51.560
 the same feature representation

1:06:51.560 --> 1:06:53.160
 for all the images in the world,

1:06:53.160 --> 1:06:54.640
 which is completely useless.

1:06:54.640 --> 1:06:55.640
 Everything is a banana.

1:06:55.640 --> 1:06:56.600
 Everything is a banana.

1:06:56.600 --> 1:06:57.440
 Everything is a cat.

1:06:57.440 --> 1:06:58.280
 Everything is a car.

1:06:58.280 --> 1:06:59.200
 Yeah.

1:06:59.200 --> 1:07:01.720
 And so all we need to do is basically come up

1:07:01.720 --> 1:07:03.320
 with ways to prevent collapse,

1:07:03.320 --> 1:07:05.400
 contrasted learning is one way of doing it.

1:07:05.400 --> 1:07:06.320
 And then for example,

1:07:06.320 --> 1:07:07.880
 like clustering or self distillation

1:07:07.880 --> 1:07:09.280
 or other ways of doing it.

1:07:09.280 --> 1:07:10.440
 We also had a recent paper

1:07:10.440 --> 1:07:13.160
 where we used like decorrelation

1:07:13.160 --> 1:07:16.800
 between like two sets of features to prevent collapse.

1:07:16.800 --> 1:07:17.880
 So that's inspired a little bit

1:07:17.880 --> 1:07:20.760
 by like Horace Barlow's neuroscience principles.

1:07:20.760 --> 1:07:23.600
 By the way, I should comment that whoever counts

1:07:23.600 --> 1:07:26.760
 the number of times then the word banana,

1:07:26.760 --> 1:07:29.000
 apple, cat and dog were using this conversation,

1:07:29.000 --> 1:07:30.160
 wins the internet.

1:07:30.160 --> 1:07:31.200
 I wish you luck.

1:07:31.200 --> 1:07:36.200
 What is SWAV and the main improvement proposed

1:07:36.800 --> 1:07:40.360
 in the paper on supervised learning of visual features

1:07:40.360 --> 1:07:43.000
 by contrasting cluster assignments?

1:07:43.000 --> 1:07:46.400
 SWAV basically is a clustering based technique,

1:07:46.400 --> 1:07:48.400
 which is for again, the same thing

1:07:48.400 --> 1:07:50.760
 for self supervised learning in vision,

1:07:50.760 --> 1:07:52.440
 where we have two crops.

1:07:52.440 --> 1:07:55.280
 And the idea basically is that you want the features

1:07:55.280 --> 1:07:58.920
 from these two crops of an image to lie in the same cluster.

1:07:58.920 --> 1:08:02.560
 And basically crops that are coming from different images

1:08:02.560 --> 1:08:03.960
 to be in different clusters.

1:08:03.960 --> 1:08:05.920
 Now, typically in a sort of,

1:08:05.920 --> 1:08:07.160
 if you were to do this clustering,

1:08:07.160 --> 1:08:09.520
 you would perform clustering offline.

1:08:09.520 --> 1:08:11.040
 What that means is you would,

1:08:11.040 --> 1:08:13.160
 if you have a data set of N examples,

1:08:13.160 --> 1:08:15.360
 you would run over all of these N examples,

1:08:15.360 --> 1:08:17.520
 get features for them, perform clustering.

1:08:17.520 --> 1:08:19.480
 So basically get some clusters

1:08:19.480 --> 1:08:21.960
 and then repeat the process again.

1:08:21.960 --> 1:08:24.280
 So this is offline basically because I need to do one

1:08:24.280 --> 1:08:27.240
 pass through the data to compute its clusters.

1:08:27.240 --> 1:08:30.200
 SWAV is basically just a simple way of doing this online.

1:08:30.200 --> 1:08:31.840
 So as you're going through the data,

1:08:31.840 --> 1:08:34.800
 you're actually computing these clusters online.

1:08:34.800 --> 1:08:37.480
 And so of course, there is like a lot of tricks involved

1:08:37.480 --> 1:08:40.160
 in how to do this in a robust manner without collapsing.

1:08:40.160 --> 1:08:42.440
 But this is the sort of key idea to it.

1:08:42.440 --> 1:08:45.480
 Is there a nice way to say what is the key methodology

1:08:45.480 --> 1:08:47.680
 of the clustering that enables that?

1:08:47.680 --> 1:08:51.000
 Right, so the idea basically is that

1:08:51.000 --> 1:08:52.720
 when you have N samples,

1:08:52.720 --> 1:08:55.160
 we assume that we have access to like,

1:08:55.160 --> 1:08:57.080
 there are always K clusters in a data set.

1:08:57.080 --> 1:08:57.920
 K is a fixed number.

1:08:57.920 --> 1:09:00.160
 So for example, K is 3000.

1:09:00.160 --> 1:09:02.240
 And so if you have any,

1:09:02.240 --> 1:09:04.840
 when you look at any sort of small number of examples,

1:09:04.840 --> 1:09:08.000
 all of them must belong to one of these K clusters.

1:09:08.000 --> 1:09:10.360
 And we impose this equi partition constraint.

1:09:10.360 --> 1:09:13.720
 What this means is that basically,

1:09:15.240 --> 1:09:16.880
 your entire set of N samples

1:09:16.880 --> 1:09:19.440
 should be equally partitioned into K clusters.

1:09:19.440 --> 1:09:21.800
 So all your K clusters are basically equal,

1:09:21.800 --> 1:09:24.400
 they have equal contribution to these N samples.

1:09:24.400 --> 1:09:26.520
 And this ensures that we never collapse.

1:09:26.520 --> 1:09:28.280
 So collapse can be viewed as a way

1:09:28.280 --> 1:09:30.680
 in which all samples belong to one cluster.

1:09:30.680 --> 1:09:33.160
 So all this, if all features become the same,

1:09:33.160 --> 1:09:35.160
 then you have basically just one mega cluster.

1:09:35.160 --> 1:09:38.160
 You don't even have like 10 clusters or 3000 clusters.

1:09:38.160 --> 1:09:41.000
 So SWAP basically ensures that at each point,

1:09:41.000 --> 1:09:42.400
 all these 3000 clusters

1:09:42.400 --> 1:09:45.080
 are being used in the clustering process.

1:09:45.080 --> 1:09:46.280
 And that's it.

1:09:46.280 --> 1:09:48.520
 Basically just figure out how to do this online.

1:09:48.520 --> 1:09:51.000
 And again, basically just make sure

1:09:51.000 --> 1:09:52.600
 that two crops from the same image

1:09:52.600 --> 1:09:55.760
 belong to the same cluster and others don't.

1:09:55.760 --> 1:09:58.880
 And the fact they have a fixed K makes things simpler.

1:09:58.880 --> 1:10:00.400
 Fixed K makes things simpler.

1:10:00.400 --> 1:10:02.600
 Our clustering is not like really hard clustering,

1:10:02.600 --> 1:10:03.760
 it's soft clustering.

1:10:03.760 --> 1:10:06.920
 So basically you can be 0.2 to cluster number one

1:10:06.920 --> 1:10:08.480
 and 0.8 to cluster number two.

1:10:08.480 --> 1:10:09.920
 So it's not really hard.

1:10:09.920 --> 1:10:12.760
 So essentially, even though we have like 3000 clusters,

1:10:12.760 --> 1:10:15.200
 we can actually represent a lot of clusters.

1:10:15.200 --> 1:10:19.240
 What is CER, S E E R?

1:10:19.240 --> 1:10:23.120
 And what are the key results and insights in the paper,

1:10:23.120 --> 1:10:27.440
 self supervised pre training of visual features in the wild?

1:10:27.440 --> 1:10:30.760
 What is this big, beautiful CER system?

1:10:30.760 --> 1:10:33.000
 CER, so I'll first go to SWAP

1:10:33.000 --> 1:10:34.440
 because SWAP is actually like one

1:10:34.440 --> 1:10:35.840
 of the key components for CER.

1:10:35.840 --> 1:10:37.840
 So SWAP was, when we use SWAP,

1:10:37.840 --> 1:10:39.840
 it was demonstrated on ImageNet.

1:10:39.840 --> 1:10:42.960
 So typically like self supervised methods,

1:10:42.960 --> 1:10:45.480
 the way we sort of operate is like

1:10:45.480 --> 1:10:47.240
 in the research community, we kind of cheat.

1:10:47.240 --> 1:10:49.560
 So we take ImageNet, which of course I talked

1:10:49.560 --> 1:10:51.320
 about as having lots of labels.

1:10:51.320 --> 1:10:53.200
 And then we throw away the labels,

1:10:53.200 --> 1:10:54.280
 throw away all the hard work

1:10:54.280 --> 1:10:56.800
 that went behind basically the labeling process.

1:10:56.800 --> 1:11:00.240
 And we pretend that it is self unsupervised.

1:11:00.240 --> 1:11:02.480
 But the problem here is that we have,

1:11:02.480 --> 1:11:05.160
 like when we collected these images,

1:11:05.160 --> 1:11:08.240
 the ImageNet dataset has a particular distribution

1:11:08.240 --> 1:11:09.960
 of concepts, right?

1:11:09.960 --> 1:11:11.800
 So these images are very curated.

1:11:11.800 --> 1:11:13.680
 And what that means is these images,

1:11:14.880 --> 1:11:17.680
 of course, belong to a certain set of noun concepts.

1:11:17.680 --> 1:11:19.320
 And also ImageNet has this bias

1:11:19.320 --> 1:11:21.240
 that all images contain an object

1:11:21.240 --> 1:11:24.120
 which is like very big and it's typically in the center.

1:11:24.120 --> 1:11:25.120
 So when you're talking about a dog,

1:11:25.120 --> 1:11:26.160
 it's a well framed dog.

1:11:26.160 --> 1:11:28.360
 It's towards the center of the image.

1:11:28.360 --> 1:11:29.800
 So a lot of the data augmentation,

1:11:29.800 --> 1:11:31.520
 a lot of the sort of hidden assumptions

1:11:31.520 --> 1:11:33.440
 in self supervised learning,

1:11:33.440 --> 1:11:37.400
 actually really exploit this bias of ImageNet.

1:11:37.400 --> 1:11:39.720
 And so, I mean, a lot of my work,

1:11:39.720 --> 1:11:42.040
 a lot of work from other people always uses ImageNet

1:11:42.040 --> 1:11:43.720
 sort of as the benchmark to show

1:11:43.720 --> 1:11:45.480
 the success of self supervised learning.

1:11:45.480 --> 1:11:47.720
 So you're implying that there's particular limitations

1:11:47.720 --> 1:11:49.240
 to this kind of dataset?

1:11:49.240 --> 1:11:51.880
 Yes, I mean, it's basically because our data augmentation

1:11:51.880 --> 1:11:55.360
 that we designed, like all the augmentation

1:11:55.360 --> 1:11:56.880
 that we designed for self supervised learning

1:11:56.880 --> 1:11:59.400
 and vision are kind of overfed to ImageNet.

1:11:59.400 --> 1:12:02.400
 But you're saying a little bit hard coded

1:12:02.400 --> 1:12:03.840
 in like the cropping.

1:12:03.840 --> 1:12:05.480
 Exactly, the cropping parameters,

1:12:05.480 --> 1:12:07.320
 the kind of lighting that we're using,

1:12:07.320 --> 1:12:08.840
 the kind of blurring that we're using.

1:12:08.840 --> 1:12:12.000
 Yeah, but you would, for a more in the wild dataset,

1:12:12.000 --> 1:12:16.240
 you would need to be clever or more careful

1:12:16.240 --> 1:12:17.520
 in setting the range of parameters

1:12:17.520 --> 1:12:18.960
 and those kinds of things.

1:12:18.960 --> 1:12:21.720
 So for SEER, our main goal was to fold one

1:12:21.720 --> 1:12:24.720
 basically to move away from ImageNet for training.

1:12:24.720 --> 1:12:27.720
 So the images that we used were like uncurated images.

1:12:27.720 --> 1:12:28.640
 Now there's a lot of debate

1:12:28.640 --> 1:12:30.080
 whether they're actually curated or not,

1:12:30.080 --> 1:12:32.360
 but I'll talk about that later.

1:12:32.360 --> 1:12:34.520
 But the idea was basically these are going to be

1:12:34.520 --> 1:12:37.920
 random internet images that we're not going to filter out

1:12:37.920 --> 1:12:40.080
 based on like a particular categories.

1:12:40.080 --> 1:12:42.880
 So we did not say that, oh, images that belong to dogs

1:12:42.880 --> 1:12:44.280
 and cats should be the only images

1:12:44.280 --> 1:12:47.000
 that come in this dataset, banana.

1:12:47.000 --> 1:12:50.040
 And basically other images should be thrown out.

1:12:50.040 --> 1:12:51.800
 So we didn't do any of that.

1:12:51.800 --> 1:12:53.560
 So these are random internet images.

1:12:53.560 --> 1:12:56.040
 And of course, it also goes back to like the problem

1:12:56.040 --> 1:12:57.280
 of scale that you talked about.

1:12:57.280 --> 1:13:00.120
 So these were basically about a billion or so images.

1:13:00.120 --> 1:13:02.320
 And for Context ImageNet, the ImageNet version

1:13:02.320 --> 1:13:04.320
 that we use was one million images earlier.

1:13:04.320 --> 1:13:05.920
 So this is basically going like three orders

1:13:05.920 --> 1:13:07.600
 of magnitude more.

1:13:07.600 --> 1:13:09.360
 The idea was basically to see if we can train

1:13:09.360 --> 1:13:13.320
 a very large convolutional model in a self supervised way

1:13:13.320 --> 1:13:16.400
 on this uncurated, but really large set of images.

1:13:16.400 --> 1:13:18.280
 And how well would this model do?

1:13:18.280 --> 1:13:21.480
 So is self supervised learning really overfit to ImageNet?

1:13:21.480 --> 1:13:23.840
 Or can it actually work in the wild?

1:13:23.840 --> 1:13:25.720
 And it was also out of curiosity,

1:13:25.720 --> 1:13:27.520
 what kind of things will this model learn?

1:13:27.520 --> 1:13:30.080
 Will it actually be able to still figure out,

1:13:30.080 --> 1:13:32.000
 different types of objects and so on?

1:13:32.000 --> 1:13:33.720
 Would there be particular kinds of tasks

1:13:33.720 --> 1:13:38.160
 it would actually do better than an ImageNet trained model?

1:13:38.160 --> 1:13:40.960
 And so for Sierra, one of our main findings was that

1:13:40.960 --> 1:13:43.120
 we can actually train very large models

1:13:43.120 --> 1:13:44.800
 in a completely self supervised way

1:13:44.800 --> 1:13:46.400
 on lots of Internet images

1:13:46.400 --> 1:13:48.640
 without really necessarily filtering them out,

1:13:48.640 --> 1:13:49.800
 which was in itself a good thing

1:13:49.800 --> 1:13:52.000
 because it's a fairly simple process, right?

1:13:52.000 --> 1:13:54.120
 So you get images which are uploaded

1:13:54.120 --> 1:13:55.800
 and you basically can immediately use them

1:13:55.800 --> 1:13:57.720
 to train a model in an unsupervised way.

1:13:57.720 --> 1:13:59.760
 You don't really need to sit and filter them out.

1:13:59.760 --> 1:14:02.080
 These images can be cartoons, these can be memes,

1:14:02.080 --> 1:14:04.480
 these can be actual pictures uploaded by people.

1:14:04.480 --> 1:14:06.200
 And you don't really care about what these images are.

1:14:06.200 --> 1:14:08.560
 You don't even care about what concepts they contain.

1:14:08.560 --> 1:14:10.320
 So this was a very sort of simple setup.

1:14:10.320 --> 1:14:12.920
 What ImageSelection mechanism would you say

1:14:12.920 --> 1:14:17.920
 is there like inherent in some aspect of the process?

1:14:18.880 --> 1:14:21.320
 So you're kind of implying it, there's almost none.

1:14:21.320 --> 1:14:25.000
 But what is there would you say if you were to introspect?

1:14:25.000 --> 1:14:28.960
 Right, so it's not like uncurated can basically like,

1:14:28.960 --> 1:14:30.880
 one way of imagining uncurated is basically

1:14:30.880 --> 1:14:33.800
 you have like cameras that can take pictures

1:14:33.800 --> 1:14:35.240
 at random viewpoints.

1:14:35.240 --> 1:14:37.440
 When people upload pictures to the Internet,

1:14:37.440 --> 1:14:40.360
 they are typically going to care about the framing of it.

1:14:40.360 --> 1:14:41.880
 They're not going to upload, say,

1:14:41.880 --> 1:14:43.840
 the picture of a zoomed in wall, for example.

1:14:43.840 --> 1:14:44.920
 Well, when we say Internet,

1:14:44.920 --> 1:14:46.080
 do you mean social networks?

1:14:46.080 --> 1:14:47.160
 Yes.

1:14:47.160 --> 1:14:48.680
 So these are not going to be like pictures

1:14:48.680 --> 1:14:51.400
 of like a zoomed in table or a zoomed in wall.

1:14:51.400 --> 1:14:53.160
 So it's not really completely uncurated

1:14:53.160 --> 1:14:55.800
 because people do have their like photographers bias,

1:14:55.800 --> 1:14:57.720
 where they do want to keep things towards the center

1:14:57.720 --> 1:14:59.920
 a little bit or like really have like,

1:14:59.920 --> 1:15:02.680
 you know, nice looking things and so on in the picture.

1:15:02.680 --> 1:15:05.640
 So that's the kind of bias that typically exists

1:15:05.640 --> 1:15:06.480
 in this data set.

1:15:06.480 --> 1:15:07.720
 And also the user base, right?

1:15:07.720 --> 1:15:09.320
 You're not going to get lots of pictures

1:15:09.320 --> 1:15:10.520
 from different parts of the world

1:15:10.520 --> 1:15:12.080
 because there are certain parts of the world

1:15:12.080 --> 1:15:14.280
 where people may not actually be uploading

1:15:14.280 --> 1:15:15.400
 a lot of pictures to the Internet

1:15:15.400 --> 1:15:17.360
 or may not even have access to a lot of Internet.

1:15:17.360 --> 1:15:21.720
 So this is a giant data set and a giant neural network.

1:15:21.720 --> 1:15:24.760
 I don't think we've talked about what architectures

1:15:24.760 --> 1:15:29.280
 work well for SSL, for self supervised learning.

1:15:29.280 --> 1:15:30.640
 For Seer and for Swab,

1:15:30.640 --> 1:15:32.440
 we were using convolutional networks,

1:15:32.440 --> 1:15:34.120
 but recently in a work called Dino,

1:15:34.120 --> 1:15:36.840
 we've basically started using transformers for vision.

1:15:36.840 --> 1:15:38.560
 Both seem to work really well,

1:15:38.560 --> 1:15:41.120
 con nets and transformers and depending on what you want to do,

1:15:41.120 --> 1:15:43.520
 you might choose to use a particular formulation.

1:15:43.520 --> 1:15:45.320
 So for Seer, it was a con net.

1:15:45.320 --> 1:15:47.440
 It was particularly a reg net model,

1:15:47.440 --> 1:15:49.680
 which was also work from Facebook.

1:15:49.680 --> 1:15:52.600
 Reg nets are like really good when it comes to compute

1:15:52.600 --> 1:15:54.720
 versus like accuracy.

1:15:54.720 --> 1:15:56.880
 So because it was a very efficient model,

1:15:56.880 --> 1:15:59.640
 compute and memory wise efficient

1:15:59.640 --> 1:16:02.440
 and basically it worked really well in terms of scaling.

1:16:02.440 --> 1:16:04.160
 So we used a very large reg net model

1:16:04.160 --> 1:16:05.440
 and trained it on a billion images.

1:16:05.440 --> 1:16:09.680
 Can you maybe quickly comment on what reg nets are?

1:16:09.680 --> 1:16:10.680
 It comes from this paper,

1:16:10.680 --> 1:16:13.520
 Designing Network Design Spaces.

1:16:13.520 --> 1:16:15.520
 It's just a super interesting concept

1:16:15.520 --> 1:16:18.400
 that emphasizes how to create efficient neural networks,

1:16:18.400 --> 1:16:19.520
 large neural networks.

1:16:19.520 --> 1:16:21.760
 So one of the sort of key takeaways from this paper,

1:16:21.760 --> 1:16:24.160
 which the authors like whenever you hear them present this work,

1:16:24.160 --> 1:16:27.200
 they keep saying is a lot of neural networks

1:16:27.200 --> 1:16:29.040
 are characterized in terms of flops.

1:16:29.040 --> 1:16:31.480
 Flops basically being the floating point operations

1:16:31.480 --> 1:16:33.360
 and people really love to use flops to say,

1:16:33.360 --> 1:16:36.200
 this model is like really computationally heavy

1:16:36.200 --> 1:16:39.000
 or like our model is computationally cheap and so on.

1:16:39.000 --> 1:16:41.880
 Now it turns out that flops are really not a good indicator

1:16:41.880 --> 1:16:43.840
 of how well a particular network is,

1:16:43.840 --> 1:16:45.960
 like how efficient it is really.

1:16:45.960 --> 1:16:49.120
 And what a better indicator is is the activation

1:16:49.120 --> 1:16:52.120
 or the memory that is being used by this particular model.

1:16:52.120 --> 1:16:54.960
 And so designing like one of the key findings

1:16:54.960 --> 1:16:57.360
 from this paper was basically that you need to design

1:16:57.360 --> 1:17:00.120
 network families or neural network architectures

1:17:00.120 --> 1:17:02.760
 that are actually very efficient in the memory space as well,

1:17:02.760 --> 1:17:04.800
 not just in terms of pure flops.

1:17:04.800 --> 1:17:07.560
 So RegNet is basically a network architecture family

1:17:07.560 --> 1:17:08.920
 that came out of this paper

1:17:08.920 --> 1:17:11.160
 that is particularly good at both flops

1:17:11.160 --> 1:17:13.560
 and the sort of memory required for it.

1:17:13.560 --> 1:17:15.760
 And of course it builds upon like earlier work,

1:17:15.760 --> 1:17:18.560
 like ResNet being like the sort of more popular inspiration

1:17:18.560 --> 1:17:20.400
 for it where you have residual connections.

1:17:20.400 --> 1:17:22.400
 But one of the things in this work is basically

1:17:22.400 --> 1:17:25.080
 they also use like squeeze excitation blocks.

1:17:25.080 --> 1:17:27.080
 So it's a lot of nice sort of technical innovation

1:17:27.080 --> 1:17:28.720
 in all of this from prior work

1:17:28.720 --> 1:17:31.400
 and a lot of the ingenuity of these particular authors

1:17:31.400 --> 1:17:34.120
 in how to combine these multiple building blocks.

1:17:34.120 --> 1:17:36.840
 But the key constraint was optimize for both flops

1:17:36.840 --> 1:17:38.320
 and memory when you're basically doing this.

1:17:38.320 --> 1:17:39.560
 Don't just look at flops.

1:17:39.560 --> 1:17:44.040
 And that allows you to what have sort of have very large

1:17:44.040 --> 1:17:49.040
 networks through this process can optimize for low

1:17:49.120 --> 1:17:51.280
 like for efficiency, for low memory.

1:17:51.280 --> 1:17:53.600
 Also in just in terms of pure hardware,

1:17:53.600 --> 1:17:55.880
 they fit very well on GPU memory.

1:17:55.880 --> 1:17:57.920
 So they can be like really powerful neural network

1:17:57.920 --> 1:18:00.200
 architectures with lots of parameters, lots of flops,

1:18:00.200 --> 1:18:02.760
 but also because they're like efficient in terms of

1:18:02.760 --> 1:18:04.040
 the amount of memory that they're using,

1:18:04.040 --> 1:18:05.960
 you can actually fit a lot of these on,

1:18:05.960 --> 1:18:08.120
 like you can fit a very large model

1:18:08.120 --> 1:18:09.600
 on a single GPU for example.

1:18:09.600 --> 1:18:14.600
 Would you say that the choice of architecture matters more

1:18:15.120 --> 1:18:18.560
 than the choice of maybe data augmentation techniques?

1:18:18.560 --> 1:18:21.720
 Is there a possibility to say what matters more?

1:18:21.720 --> 1:18:24.400
 You kind of imply that you can probably go really far

1:18:24.400 --> 1:18:27.600
 with just using basic convenants.

1:18:27.600 --> 1:18:30.600
 All right, I think like data and data augmentation,

1:18:30.600 --> 1:18:33.280
 the algorithm being used for the self supervised training

1:18:33.280 --> 1:18:36.400
 matters a lot more than the particular kind of architecture.

1:18:36.400 --> 1:18:37.680
 With different types of architecture,

1:18:37.680 --> 1:18:39.560
 you will get different like properties

1:18:39.560 --> 1:18:41.720
 in the resulting sort of representation.

1:18:41.720 --> 1:18:44.200
 But really, I mean, the secret sauce is in the data

1:18:44.200 --> 1:18:47.080
 augmentation and the algorithm being used to train them.

1:18:47.080 --> 1:18:49.240
 The architectures, I mean, at this point,

1:18:49.240 --> 1:18:51.680
 a lot of them perform very similarly,

1:18:51.680 --> 1:18:53.840
 depending on like the particular task that you care about,

1:18:53.840 --> 1:18:56.400
 they have certain advantages and disadvantages.

1:18:56.400 --> 1:18:58.120
 Is there something interesting to be said

1:18:58.120 --> 1:19:00.600
 about what it takes with Sears to train

1:19:00.600 --> 1:19:01.920
 a giant neural network?

1:19:01.920 --> 1:19:04.160
 You're talking about a huge amount of data,

1:19:04.160 --> 1:19:05.800
 a huge neural network.

1:19:05.800 --> 1:19:07.800
 Is there something interesting to be said

1:19:07.800 --> 1:19:11.280
 of how to effectively train something like that fast?

1:19:11.280 --> 1:19:12.200
 Lots of GPUs.

1:19:13.040 --> 1:19:13.880
 Okay, so.

1:19:15.480 --> 1:19:18.080
 I mean, so the model was like a billion parameters.

1:19:18.080 --> 1:19:18.920
 Yeah.

1:19:18.920 --> 1:19:20.640
 And it was trained on the billion images.

1:19:20.640 --> 1:19:21.480
 Yeah.

1:19:21.480 --> 1:19:23.360
 So basically the same number of parameters

1:19:23.360 --> 1:19:24.920
 as the number of images.

1:19:24.920 --> 1:19:26.200
 And it took a while.

1:19:26.200 --> 1:19:27.480
 I don't remember the exact number.

1:19:27.480 --> 1:19:28.640
 It's in the paper.

1:19:28.640 --> 1:19:29.480
 But it took a while.

1:19:29.480 --> 1:19:33.760
 I guess I'm trying to get at is

1:19:34.680 --> 1:19:38.680
 when you're thinking of scaling this kind of thing.

1:19:38.680 --> 1:19:41.920
 I mean, one of the exciting possibilities

1:19:41.920 --> 1:19:45.320
 of self supervised learning is the several orders

1:19:45.320 --> 1:19:47.360
 of magnitude scaling of everything,

1:19:47.360 --> 1:19:50.920
 both both the neural network and the size of the data.

1:19:50.920 --> 1:19:52.600
 And so the question is,

1:19:52.600 --> 1:19:55.120
 do you think there's some interesting tricks

1:19:55.120 --> 1:19:57.880
 to do large scale distributed compute?

1:19:57.880 --> 1:19:58.720
 Or is it,

1:19:58.720 --> 1:20:00.920
 or is that really outside of even deep learning?

1:20:00.920 --> 1:20:04.360
 That's more about like hardware engineering.

1:20:04.360 --> 1:20:07.240
 I think more and more there is like this,

1:20:07.240 --> 1:20:10.120
 a lot of like systems are designed,

1:20:10.120 --> 1:20:11.360
 basically taking it to account

1:20:11.360 --> 1:20:12.480
 the machine learning needs, right?

1:20:12.480 --> 1:20:14.640
 So because whenever you're doing this kind

1:20:14.640 --> 1:20:15.480
 of distributed training,

1:20:15.480 --> 1:20:17.760
 there is a lot of inter communication between nodes.

1:20:17.760 --> 1:20:20.600
 So like gradients or the model parameters are being passed.

1:20:20.600 --> 1:20:22.800
 So you really want to minimize communication costs

1:20:22.800 --> 1:20:25.240
 when you really want to scale these models up.

1:20:25.240 --> 1:20:29.160
 You want basically to be able to do as much,

1:20:29.160 --> 1:20:31.440
 like as limited amount of communication as possible.

1:20:31.440 --> 1:20:33.280
 So currently like a dominant paradigm

1:20:33.280 --> 1:20:35.000
 is synchronized sort of training.

1:20:35.000 --> 1:20:38.480
 So essentially after every sort of gradient step,

1:20:38.480 --> 1:20:41.200
 all you basically have like a synchronization step

1:20:41.200 --> 1:20:43.400
 between all the sort of compute chips

1:20:43.400 --> 1:20:44.800
 that you're going on with.

1:20:45.680 --> 1:20:47.840
 I think asynchronous training was popular,

1:20:47.840 --> 1:20:50.400
 but it doesn't seem to perform as well.

1:20:50.400 --> 1:20:53.320
 But in general, I think that's sort of the,

1:20:53.320 --> 1:20:55.280
 I guess it's outside my scope as well.

1:20:55.280 --> 1:20:59.000
 But the main thing is like minimize the amount

1:20:59.000 --> 1:21:01.880
 of synchronization steps that you have.

1:21:01.880 --> 1:21:04.600
 That has been the key take away at least in my experience.

1:21:04.600 --> 1:21:06.640
 The others, I have no idea about how to design the chip.

1:21:06.640 --> 1:21:11.200
 Yeah, there's very few things that I see Jim Keller's eyes

1:21:11.200 --> 1:21:14.160
 light up as much as talking about giant computers doing

1:21:15.360 --> 1:21:17.640
 like that fast communication that you're talking to,

1:21:17.640 --> 1:21:21.200
 well, when they're training machine learning systems.

1:21:21.200 --> 1:21:26.200
 What is Vistle, the ISSL, the PyTorch based SSL library?

1:21:27.880 --> 1:21:30.080
 What are the use cases that you might have?

1:21:30.080 --> 1:21:32.320
 Vistle basically was born out of a lot of us

1:21:32.320 --> 1:21:35.120
 at Facebook doing the self supervised learning research.

1:21:35.120 --> 1:21:38.160
 So it's a common framework in which we have

1:21:38.160 --> 1:21:39.920
 like a lot of self supervised learning methods

1:21:39.920 --> 1:21:41.680
 implemented for vision.

1:21:41.680 --> 1:21:45.920
 It's also, it has in itself like a benchmark of tasks

1:21:45.920 --> 1:21:48.800
 that you can evaluate the self supervised representations on.

1:21:48.800 --> 1:21:51.240
 So the use case for it is basically for anyone

1:21:51.240 --> 1:21:53.760
 who's either trying to evaluate their self supervised model

1:21:53.760 --> 1:21:56.000
 or train their self supervised model

1:21:56.000 --> 1:21:57.800
 or a researcher who's trying to build

1:21:57.800 --> 1:21:59.240
 a new self supervised technique.

1:21:59.240 --> 1:22:01.520
 So it's basically supposed to be all of these things.

1:22:01.520 --> 1:22:04.480
 So as a researcher before Vistle, for example,

1:22:04.480 --> 1:22:06.160
 or like when we started doing this work

1:22:06.160 --> 1:22:07.920
 fairly seriously at Facebook,

1:22:07.920 --> 1:22:09.960
 it was very hard for us to go and implement

1:22:09.960 --> 1:22:11.880
 every self supervised learning model

1:22:11.880 --> 1:22:14.600
 tested out in a like sort of consistent manner.

1:22:14.600 --> 1:22:16.440
 The experimental setup was very different

1:22:16.440 --> 1:22:18.160
 across different groups.

1:22:18.160 --> 1:22:20.800
 Even when someone said that they were reporting image net

1:22:20.800 --> 1:22:23.200
 accuracy, it could mean lots of different things.

1:22:23.200 --> 1:22:25.360
 So with Vistle, we tried to really sort of standardize that

1:22:25.360 --> 1:22:26.400
 as much as possible.

1:22:26.400 --> 1:22:28.240
 And it was a paper like we did in 2019

1:22:28.240 --> 1:22:29.760
 just about benchmarking.

1:22:29.760 --> 1:22:32.240
 And so Vistle basically builds upon a lot of

1:22:32.240 --> 1:22:35.160
 this kind of work that we did about like benchmarking.

1:22:35.160 --> 1:22:37.160
 And then every time we try to like,

1:22:37.160 --> 1:22:39.040
 we come up with a self supervised learning method,

1:22:39.040 --> 1:22:41.200
 a lot of us try to push that into Vistle as well

1:22:41.200 --> 1:22:43.440
 just so that it basically is like the central piece

1:22:43.440 --> 1:22:46.360
 where a lot of these methods can reside.

1:22:46.360 --> 1:22:49.200
 Just out of curiosity, people maybe,

1:22:49.200 --> 1:22:52.000
 so certainly outside of Facebook, but just researchers,

1:22:52.000 --> 1:22:54.920
 or just even people that know how to program in Python

1:22:54.920 --> 1:22:57.120
 and know how to use PyTorch,

1:22:57.120 --> 1:22:58.640
 what would be the use case?

1:22:58.640 --> 1:23:01.320
 What would be a fun thing to play around with Vistle on?

1:23:01.320 --> 1:23:04.320
 Like what's a fun thing to play around

1:23:04.320 --> 1:23:07.920
 with self supervised learning on, would you say?

1:23:07.920 --> 1:23:09.760
 Is there a good Hello World program?

1:23:09.760 --> 1:23:12.440
 Like is it always about big size

1:23:12.440 --> 1:23:14.640
 that's important to have?

1:23:14.640 --> 1:23:18.080
 Or is there a fun little smaller case

1:23:18.080 --> 1:23:19.760
 playgrounds to play around with?

1:23:19.760 --> 1:23:22.440
 So we're trying to like push something towards that.

1:23:22.440 --> 1:23:24.360
 I think there are a few setups out there,

1:23:24.360 --> 1:23:26.760
 but nothing like super standard on the smaller scale.

1:23:26.760 --> 1:23:29.320
 I mean, ImageNet in itself is actually pretty big also.

1:23:29.320 --> 1:23:32.280
 So that is not something which is like feasible

1:23:32.280 --> 1:23:34.920
 for a lot of people, but we are trying to like push up

1:23:34.920 --> 1:23:36.400
 with like smaller sort of use cases.

1:23:36.400 --> 1:23:39.000
 The thing is at a smaller scale,

1:23:39.000 --> 1:23:41.240
 a lot of the observations are a lot of the algorithms

1:23:41.240 --> 1:23:42.800
 that work don't necessarily translate

1:23:42.800 --> 1:23:45.000
 into the medium or the larger scale.

1:23:45.000 --> 1:23:47.480
 So it's really tricky to come up with a good small scale setup

1:23:47.480 --> 1:23:49.160
 where a lot of your empirical observations

1:23:49.160 --> 1:23:51.560
 will really translate to the other setup.

1:23:51.560 --> 1:23:53.280
 So it's been really challenging.

1:23:53.280 --> 1:23:54.920
 I've been trying to do that for a little bit as well

1:23:54.920 --> 1:23:56.840
 because it does take time to train stuff on ImageNet,

1:23:56.840 --> 1:23:59.880
 it does take time to train on like more images,

1:23:59.880 --> 1:24:02.240
 but pretty much every time I've tried to do that,

1:24:02.240 --> 1:24:04.120
 it's been unsuccessful because all the observations

1:24:04.120 --> 1:24:06.880
 I draw from my set of experiments on a smaller dataset

1:24:06.880 --> 1:24:09.240
 don't translate into ImageNet

1:24:09.240 --> 1:24:11.720
 or like don't translate into another sort of dataset.

1:24:11.720 --> 1:24:14.160
 So it's been hard for us to figure this one out,

1:24:14.160 --> 1:24:15.720
 but it's an important problem.

1:24:15.720 --> 1:24:17.920
 So there's this really interesting idea

1:24:17.920 --> 1:24:20.800
 of learning across multiple modalities.

1:24:20.800 --> 1:24:25.800
 You have a CVPR 2021 best paper candidate

1:24:26.320 --> 1:24:29.200
 titled Audiovisual Instance Discrimination

1:24:29.200 --> 1:24:31.360
 with Crossmodal Agreement.

1:24:31.360 --> 1:24:33.840
 What are the key results, insights in this paper

1:24:33.840 --> 1:24:35.880
 and what can you say in general about the promise

1:24:35.880 --> 1:24:37.600
 and power of multimodal learning?

1:24:37.600 --> 1:24:39.960
 For this paper, it actually came as a little bit

1:24:39.960 --> 1:24:41.960
 of a shock to me at how well it worked.

1:24:41.960 --> 1:24:44.120
 So I can describe what the problem setup was.

1:24:44.120 --> 1:24:46.520
 So it's been used in the past by lots of folks,

1:24:46.520 --> 1:24:48.360
 like for example, Andrew Owens from MIT,

1:24:48.360 --> 1:24:49.920
 Alyosha Efros from Berkeley,

1:24:49.920 --> 1:24:51.120
 Andrew Zisserman from Oxford.

1:24:51.120 --> 1:24:53.000
 So a lot of these people have been sort of showing results

1:24:53.000 --> 1:24:54.080
 in this.

1:24:54.080 --> 1:24:55.480
 Of course, I was aware of this result,

1:24:55.480 --> 1:24:58.600
 but I wasn't really sure how well it would work in practice

1:24:58.600 --> 1:25:00.600
 for like other sort of downstream tasks.

1:25:00.600 --> 1:25:02.440
 So the results kept getting better

1:25:02.440 --> 1:25:04.200
 and I wasn't sure if like a lot of our insights

1:25:04.200 --> 1:25:05.920
 from self supervised learning would translate

1:25:05.920 --> 1:25:08.320
 into this multimodal learning problem.

1:25:08.320 --> 1:25:11.880
 So multimodal learning is when you have like,

1:25:12.880 --> 1:25:14.280
 when you have multiple modalities.

1:25:14.280 --> 1:25:15.640
 And that's not equal.

1:25:15.640 --> 1:25:16.960
 Excellent.

1:25:16.960 --> 1:25:20.040
 Okay, so the particular modalities that we worked on

1:25:20.040 --> 1:25:22.040
 in this work were audio and video.

1:25:22.040 --> 1:25:23.920
 So the idea was basically if you have a video,

1:25:23.920 --> 1:25:25.880
 you have it's corresponding audio track.

1:25:25.880 --> 1:25:27.560
 And you want to use both of these signals,

1:25:27.560 --> 1:25:29.280
 the audio signal and the video signal

1:25:29.280 --> 1:25:31.280
 to learn a good representation for video

1:25:31.280 --> 1:25:32.640
 and good representation for audio.

1:25:32.640 --> 1:25:33.680
 Like this podcast.

1:25:33.680 --> 1:25:35.480
 Like this podcast, exactly.

1:25:35.480 --> 1:25:38.160
 So what we did in this work was basically trained

1:25:38.160 --> 1:25:39.400
 two different neural networks,

1:25:39.400 --> 1:25:41.960
 one on the video signal, one on the audio signal.

1:25:41.960 --> 1:25:43.800
 And what we wanted is basically the features

1:25:43.800 --> 1:25:45.400
 that we get from both of these neural networks

1:25:45.400 --> 1:25:46.800
 should be similar.

1:25:46.800 --> 1:25:48.720
 So it should basically be able to produce

1:25:48.720 --> 1:25:51.120
 the same kinds of features from the video

1:25:51.120 --> 1:25:53.240
 and the same kinds of features from the audio.

1:25:53.240 --> 1:25:54.280
 Now, why is this useful?

1:25:54.280 --> 1:25:56.680
 Well, for a lot of these objects that we have,

1:25:56.680 --> 1:25:58.280
 there is a characteristic sound, right?

1:25:58.280 --> 1:25:59.520
 So trains, when they go by,

1:25:59.520 --> 1:26:00.760
 they make a particular kind of sound.

1:26:00.760 --> 1:26:02.480
 Boats make a particular kind of sound.

1:26:02.480 --> 1:26:03.840
 People, when they're jumping around,

1:26:03.840 --> 1:26:06.280
 they will like shout or whatever.

1:26:06.280 --> 1:26:07.320
 Bananas don't make a sound.

1:26:07.320 --> 1:26:09.440
 So well, you can't learn anything about bananas there.

1:26:09.440 --> 1:26:11.680
 Or when humans mention bananas.

1:26:11.680 --> 1:26:12.520
 Well, yes.

1:26:12.520 --> 1:26:13.840
 When they say the word banana, then probably.

1:26:13.840 --> 1:26:15.120
 So you can't trust basically anything

1:26:15.120 --> 1:26:17.160
 that comes out of a human's mouth as a source,

1:26:17.160 --> 1:26:18.960
 that source of audio is useless.

1:26:18.960 --> 1:26:20.680
 So the typical use case is basically like,

1:26:20.680 --> 1:26:22.480
 for example, someone playing a musical instrument.

1:26:22.480 --> 1:26:24.720
 So guitars have a particular kind of sound and so on.

1:26:24.720 --> 1:26:27.160
 So because a lot of these things are correlated,

1:26:27.160 --> 1:26:28.480
 the idea in multimodal learning

1:26:28.480 --> 1:26:30.160
 is to take these two kinds of modalities,

1:26:30.160 --> 1:26:31.360
 video and audio,

1:26:31.360 --> 1:26:33.160
 and learn a common embedding space,

1:26:33.160 --> 1:26:34.480
 a common feature space,

1:26:34.480 --> 1:26:36.120
 where both of these related modalities

1:26:36.120 --> 1:26:38.560
 can basically be close together.

1:26:38.560 --> 1:26:40.600
 And again, you use contrastive learning for this.

1:26:40.600 --> 1:26:42.080
 So in contrastive learning,

1:26:42.080 --> 1:26:45.520
 basically the video and the corresponding audio are positives,

1:26:45.520 --> 1:26:48.200
 and you can take any other video or any other audio,

1:26:48.200 --> 1:26:49.840
 and that becomes a negative.

1:26:49.840 --> 1:26:51.040
 And so basically that's it.

1:26:51.040 --> 1:26:53.720
 It's just a simple application of contrastive learning.

1:26:53.720 --> 1:26:55.760
 The main sort of finding from this work for us

1:26:56.840 --> 1:26:58.680
 was basically that you can actually learn

1:26:58.680 --> 1:27:00.760
 very, very powerful feature representations,

1:27:00.760 --> 1:27:02.840
 very, very powerful video representations.

1:27:02.840 --> 1:27:05.400
 So you can learn the sort of video network

1:27:05.400 --> 1:27:06.520
 that we ended up learning

1:27:06.520 --> 1:27:08.280
 can actually be used for downstream,

1:27:08.280 --> 1:27:11.000
 for example, recognizing human actions,

1:27:11.000 --> 1:27:14.440
 or recognizing different types of sounds, for example.

1:27:14.440 --> 1:27:17.160
 So this was sort of the key finding.

1:27:17.160 --> 1:27:20.200
 Can you give kind of an example of a human action

1:27:20.200 --> 1:27:23.400
 or just so we can build up intuition

1:27:23.400 --> 1:27:24.360
 of what kind of thing?

1:27:24.360 --> 1:27:26.880
 Right, so there is this data set called Kinetics,

1:27:26.880 --> 1:27:28.640
 for example, which has like 400 different types

1:27:28.640 --> 1:27:29.480
 of human actions.

1:27:29.480 --> 1:27:32.360
 So people jumping, people doing different kinds

1:27:32.360 --> 1:27:34.280
 of sports or different types of swimming.

1:27:34.280 --> 1:27:37.640
 So like different strokes and swimming, golf and so on.

1:27:37.640 --> 1:27:40.560
 So there are like just different types of actions right there.

1:27:40.560 --> 1:27:42.640
 And the point is this kind of video network

1:27:42.640 --> 1:27:44.400
 that you learn in a self supervised way

1:27:44.400 --> 1:27:46.960
 can be used very easily to kind of recognize

1:27:46.960 --> 1:27:48.920
 these different types of actions.

1:27:48.920 --> 1:27:50.440
 It can also be used for recognizing

1:27:50.440 --> 1:27:51.760
 different types of objects.

1:27:53.160 --> 1:27:54.800
 And what we did is we tried to visualize

1:27:54.800 --> 1:27:56.120
 whether the network can figure out

1:27:56.120 --> 1:27:57.920
 where the sound is coming from.

1:27:57.920 --> 1:27:59.880
 So basically give it a video

1:27:59.880 --> 1:28:03.040
 and basically play of a person just strumming a guitar,

1:28:03.040 --> 1:28:04.800
 but of course there is no audio in this.

1:28:04.800 --> 1:28:07.200
 And now you give it the sound of a guitar.

1:28:07.200 --> 1:28:08.920
 And you ask like basically try to visualize

1:28:08.920 --> 1:28:12.560
 where the network thinks the sound is coming from.

1:28:12.560 --> 1:28:14.600
 And then it can kind of basically draw like,

1:28:14.600 --> 1:28:15.440
 when you visualize it,

1:28:15.440 --> 1:28:17.520
 you can see that it's basically focusing on the guitar.

1:28:17.520 --> 1:28:18.360
 Yeah, that's so real.

1:28:18.360 --> 1:28:20.200
 And the same thing, for example,

1:28:20.200 --> 1:28:21.520
 for certain people's voices,

1:28:21.520 --> 1:28:22.960
 like famous celebrities voices,

1:28:22.960 --> 1:28:26.080
 it can actually figure out where their mouth is.

1:28:26.080 --> 1:28:28.640
 So it can actually distinguish different people's voices,

1:28:28.640 --> 1:28:30.520
 for example, a little bit as well.

1:28:30.520 --> 1:28:33.680
 Without that ever being annotated in any way.

1:28:33.680 --> 1:28:35.560
 Right, so this is all what it had discovered.

1:28:35.560 --> 1:28:38.240
 We never pointed out that this is a guitar

1:28:38.240 --> 1:28:40.120
 and this is the kind of sound it produces.

1:28:40.120 --> 1:28:41.560
 It can actually naturally figure that out

1:28:41.560 --> 1:28:44.240
 because it's seen so many correlations of this sound

1:28:44.240 --> 1:28:46.720
 coming with this kind of like an object

1:28:46.720 --> 1:28:49.080
 that it basically learns to associate this sound

1:28:49.080 --> 1:28:50.080
 with this kind of an object.

1:28:50.080 --> 1:28:52.840
 Yeah, that's really fascinating, right?

1:28:52.840 --> 1:28:53.680
 That's really interesting.

1:28:53.680 --> 1:28:55.240
 So the idea with this kind of network

1:28:55.240 --> 1:28:57.960
 is then you then fine tune it for a particular task.

1:28:57.960 --> 1:29:01.880
 So this is forming like a really good knowledge base

1:29:01.880 --> 1:29:04.320
 within a neural network based on which you could then,

1:29:04.320 --> 1:29:05.600
 the train a little bit more

1:29:05.600 --> 1:29:08.800
 to accomplish a specific task well.

1:29:08.800 --> 1:29:11.680
 Exactly, so you don't need a lot of videos of humans

1:29:11.680 --> 1:29:12.800
 doing actions annotated.

1:29:12.800 --> 1:29:16.080
 You can just use a few of them to basically get your.

1:29:16.080 --> 1:29:18.520
 How much insight do you draw from the fact

1:29:18.520 --> 1:29:22.600
 that it can figure out where the sound is coming from?

1:29:23.480 --> 1:29:26.160
 I'm trying to see, so that's kind of very,

1:29:26.160 --> 1:29:28.120
 it's very CVPR, beautiful, right?

1:29:28.120 --> 1:29:30.000
 It's a cool little insight.

1:29:30.000 --> 1:29:33.000
 I wonder how profound that is.

1:29:34.240 --> 1:29:39.240
 Does it speak to the idea that multiple modalities

1:29:39.320 --> 1:29:44.120
 are somehow much bigger than the sum of their parts

1:29:44.120 --> 1:29:48.000
 or is it really, really useful to have multiple modalities

1:29:48.000 --> 1:29:50.640
 or is it just that cool thing that there's parts

1:29:50.640 --> 1:29:54.560
 of our world that can be revealed

1:29:54.560 --> 1:29:58.360
 like effectively through multiple modalities,

1:29:58.360 --> 1:30:01.200
 but most of it is really all about vision

1:30:01.200 --> 1:30:03.880
 or about one of the modalities.

1:30:03.880 --> 1:30:07.800
 I would say a little tending more towards the second part.

1:30:07.800 --> 1:30:10.720
 So most of it can be sort of figured out with one modality,

1:30:10.720 --> 1:30:13.200
 but having an extra modality always helps you.

1:30:13.200 --> 1:30:17.720
 So in this case, for example, like one thing is when you're,

1:30:17.720 --> 1:30:19.400
 if you observe someone cutting something

1:30:19.400 --> 1:30:21.960
 and you don't have any sort of sound there,

1:30:21.960 --> 1:30:25.080
 whether it's an apple or whether it's an onion,

1:30:25.080 --> 1:30:26.720
 it's very hard to figure that out.

1:30:26.720 --> 1:30:28.240
 But if you hear someone cutting it,

1:30:28.240 --> 1:30:29.800
 it's very easy to figure it out

1:30:29.800 --> 1:30:32.840
 because apples and onions make a very different kind

1:30:32.840 --> 1:30:34.840
 of characteristics on when they're cutting.

1:30:34.840 --> 1:30:36.880
 So you really figure this out based on audio.

1:30:36.880 --> 1:30:38.240
 It's much easier.

1:30:38.240 --> 1:30:40.040
 So your life will become much easier

1:30:40.040 --> 1:30:42.320
 when you have access to different kinds of modalities.

1:30:42.320 --> 1:30:43.440
 And the other thing is,

1:30:43.440 --> 1:30:45.040
 so I like to relate it in this way,

1:30:45.040 --> 1:30:46.360
 it may be like completely wrong,

1:30:46.360 --> 1:30:49.360
 but the distributional hypothesis in NLP, right?

1:30:49.360 --> 1:30:51.880
 Where context basically gives kind of meaning

1:30:51.880 --> 1:30:53.080
 to that word.

1:30:53.080 --> 1:30:55.080
 Sound kind of does that too, right?

1:30:55.080 --> 1:30:57.040
 So if you have the same sound,

1:30:57.040 --> 1:30:59.880
 so that's the same context across different videos,

1:30:59.880 --> 1:31:01.320
 you're very likely to be observing

1:31:01.320 --> 1:31:03.040
 the same kind of concept.

1:31:03.040 --> 1:31:04.320
 So that's the kind of reason

1:31:04.320 --> 1:31:06.480
 why it figures out the guitar thing, right?

1:31:06.480 --> 1:31:09.800
 It observed the same sound across multiple different videos

1:31:09.800 --> 1:31:11.920
 and it figures out maybe this is the common factor

1:31:11.920 --> 1:31:13.280
 that's actually doing it.

1:31:13.280 --> 1:31:17.480
 I wonder, I used to have this argument with my dad a bunch

1:31:17.480 --> 1:31:19.800
 for creating general intelligence,

1:31:19.800 --> 1:31:22.880
 whether smell is important,

1:31:22.880 --> 1:31:25.520
 like if that's important sensory information.

1:31:25.520 --> 1:31:27.600
 Mostly we're talking about like falling in love

1:31:27.600 --> 1:31:28.960
 with an AI system.

1:31:28.960 --> 1:31:31.440
 And for him, smell and touch are important.

1:31:31.440 --> 1:31:33.880
 And I was arguing that it's not at all,

1:31:33.880 --> 1:31:35.320
 it's nice and everything,

1:31:35.320 --> 1:31:38.400
 but like you can fall in love with just language really,

1:31:38.400 --> 1:31:41.400
 but voice is very powerful and vision is next

1:31:41.400 --> 1:31:43.880
 and smell is not that important.

1:31:43.880 --> 1:31:46.880
 Can I ask you about this process of active learning?

1:31:46.880 --> 1:31:49.160
 You mentioned interactivity.

1:31:49.160 --> 1:31:50.000
 Right.

1:31:50.000 --> 1:31:55.000
 Is there some value within the self supervised learning

1:31:56.000 --> 1:32:01.000
 context to select parts of the data in intelligent ways

1:32:02.240 --> 1:32:06.840
 such that they would most benefit the learning process?

1:32:06.840 --> 1:32:07.680
 So I think so.

1:32:07.680 --> 1:32:10.280
 I mean, I know I'm talking to an active learning fan here,

1:32:10.280 --> 1:32:12.600
 so of course I know the answer.

1:32:12.600 --> 1:32:14.000
 First you were talking bananas

1:32:14.000 --> 1:32:16.720
 and now you're talking about active learning, I love it.

1:32:16.720 --> 1:32:18.760
 I think Yana Koon told me that active learning

1:32:18.760 --> 1:32:20.440
 is not that interesting.

1:32:20.440 --> 1:32:24.360
 And I think back then I didn't want to argue with him too much,

1:32:24.360 --> 1:32:25.680
 but when we talk again,

1:32:25.680 --> 1:32:28.400
 we're gonna spend three hours arguing about active learning.

1:32:28.400 --> 1:32:32.480
 My sense was you can go extremely far with active learning,

1:32:32.480 --> 1:32:34.920
 you know, perhaps farther than anything else.

1:32:34.920 --> 1:32:37.960
 Like the, to me, there's this kind of intuition

1:32:37.960 --> 1:32:40.840
 that similar to data augmentation,

1:32:40.840 --> 1:32:44.160
 you can get a lot from the data,

1:32:44.160 --> 1:32:49.160
 from intelligent optimized usage of the data.

1:32:50.160 --> 1:32:51.000
 Right.

1:32:51.000 --> 1:32:53.240
 I'm trying to speak generally in such a way

1:32:53.240 --> 1:32:57.080
 that includes data augmentation and active learning,

1:32:57.080 --> 1:32:59.920
 that there's something about maybe interactive exploration

1:32:59.920 --> 1:33:04.360
 of the data that at least as part of the solution

1:33:04.360 --> 1:33:07.160
 to intelligence, like an important part.

1:33:07.160 --> 1:33:08.120
 I don't know what your thoughts

1:33:08.120 --> 1:33:09.360
 are on active learning in general.

1:33:09.360 --> 1:33:10.880
 I actually really like active learning.

1:33:10.880 --> 1:33:13.480
 So back in the day we did this largely ignored

1:33:13.480 --> 1:33:16.600
 CVPR paper called Learning by Asking Questions.

1:33:16.600 --> 1:33:18.320
 So the idea was basically you would train an agent

1:33:18.320 --> 1:33:20.160
 that would ask a question about the image,

1:33:20.160 --> 1:33:21.600
 it would get an answer.

1:33:21.600 --> 1:33:23.440
 And basically then it would update itself,

1:33:23.440 --> 1:33:24.440
 it would see the next image,

1:33:24.440 --> 1:33:26.880
 it would decide what's the next hardest question

1:33:26.880 --> 1:33:28.840
 that I can ask to learn the most.

1:33:28.840 --> 1:33:31.360
 And the idea was basically because it was being smart

1:33:31.360 --> 1:33:33.560
 about the kinds of questions it was asking,

1:33:33.560 --> 1:33:35.160
 it would learn in fewer samples,

1:33:35.160 --> 1:33:37.960
 it would be more efficient at using data.

1:33:37.960 --> 1:33:39.480
 And we did find to some extent

1:33:39.480 --> 1:33:42.080
 that it was actually better than randomly asking questions.

1:33:42.080 --> 1:33:43.960
 Kind of weird thing about active learning is

1:33:43.960 --> 1:33:45.240
 it's also a chicken and egg problem

1:33:45.240 --> 1:33:47.200
 because when you look at an image

1:33:47.200 --> 1:33:48.720
 to ask a good question about the image

1:33:48.720 --> 1:33:50.960
 you need to understand something about the image.

1:33:50.960 --> 1:33:53.480
 You can't ask a completely arbitrarily random question,

1:33:53.480 --> 1:33:55.560
 it may not even apply to that particular image.

1:33:55.560 --> 1:33:57.680
 So there is some amount of understanding or knowledge

1:33:57.680 --> 1:33:59.240
 that basically keeps getting built

1:33:59.240 --> 1:34:01.360
 when you're doing active learning.

1:34:01.360 --> 1:34:04.640
 So I think active learning in by itself is really good.

1:34:04.640 --> 1:34:07.280
 And the main thing we need to figure out is basically

1:34:07.280 --> 1:34:09.680
 how do we come up with a technique

1:34:09.680 --> 1:34:13.360
 to first model what the model knows

1:34:13.360 --> 1:34:16.040
 and also model what the model does not know.

1:34:16.040 --> 1:34:18.360
 I think that's the sort of beauty of it, right?

1:34:18.360 --> 1:34:20.520
 Because when you know that there are certain things

1:34:20.520 --> 1:34:22.160
 that you don't know anything about,

1:34:22.160 --> 1:34:23.640
 asking a question about those concepts

1:34:23.640 --> 1:34:26.520
 is actually going to bring you the most value.

1:34:26.520 --> 1:34:28.360
 And I think that's the sort of key challenge.

1:34:28.360 --> 1:34:29.960
 Now self supervised learning by itself,

1:34:29.960 --> 1:34:31.480
 like selecting data for it and so on,

1:34:31.480 --> 1:34:32.680
 that's actually really useful.

1:34:32.680 --> 1:34:34.000
 But I think that's a very narrow view

1:34:34.000 --> 1:34:35.120
 of looking at active learning, right?

1:34:35.120 --> 1:34:36.360
 If you look at it more broadly,

1:34:36.360 --> 1:34:40.080
 it is basically about if the model has a knowledge

1:34:40.080 --> 1:34:41.440
 about end concepts,

1:34:41.440 --> 1:34:43.880
 and it is weak basically about certain things.

1:34:43.880 --> 1:34:46.920
 So it needs to ask questions either to discover new concepts

1:34:46.920 --> 1:34:49.240
 or to basically like increase its knowledge

1:34:49.240 --> 1:34:50.440
 about these end concepts.

1:34:50.440 --> 1:34:53.240
 So at that level, it's a very powerful technique.

1:34:53.240 --> 1:34:56.560
 I actually do think it's going to be really useful.

1:34:56.560 --> 1:34:59.080
 Even in like simple things such as like data labeling,

1:34:59.080 --> 1:35:00.280
 it's super useful.

1:35:00.280 --> 1:35:02.960
 So here is like one simple way

1:35:02.960 --> 1:35:04.320
 that you can use active learning.

1:35:04.320 --> 1:35:06.920
 For example, you have your self supervised model,

1:35:06.920 --> 1:35:08.760
 which is very good at predicting similarities

1:35:08.760 --> 1:35:10.800
 and dissimilarities between things.

1:35:10.800 --> 1:35:14.600
 And so if you label a picture as basically say a banana,

1:35:15.520 --> 1:35:17.760
 now you know that all the images

1:35:17.760 --> 1:35:19.240
 that are very similar to this image

1:35:19.240 --> 1:35:21.480
 are also likely to contain bananas.

1:35:21.480 --> 1:35:24.680
 So probably when you want to understand what else

1:35:24.680 --> 1:35:26.920
 is a banana, you're not going to use these other images.

1:35:26.920 --> 1:35:28.200
 You're actually going to use an image

1:35:28.200 --> 1:35:31.160
 that is not completely dissimilar,

1:35:31.160 --> 1:35:32.360
 but somewhere in between,

1:35:32.360 --> 1:35:33.840
 which is not super similar to this image,

1:35:33.840 --> 1:35:35.640
 but not super dissimilar either.

1:35:35.640 --> 1:35:37.120
 And that's going to tell you a lot more

1:35:37.120 --> 1:35:39.520
 about what this concept of a banana is.

1:35:39.520 --> 1:35:41.840
 So that's kind of a heuristic.

1:35:41.840 --> 1:35:44.240
 I wonder if it's possible to also learn,

1:35:45.320 --> 1:35:50.320
 learn ways to discover the most likely

1:35:50.720 --> 1:35:52.960
 the most beneficial image.

1:35:52.960 --> 1:35:55.000
 So like, so not just looking a thing

1:35:55.000 --> 1:35:58.440
 that's somewhat similar to a banana,

1:35:58.440 --> 1:36:00.000
 but not exactly similar,

1:36:00.000 --> 1:36:03.560
 but have some kind of more complicated learning system,

1:36:03.560 --> 1:36:07.080
 like learned discovery mechanism

1:36:07.080 --> 1:36:09.440
 that tells you what image to look for.

1:36:09.440 --> 1:36:14.360
 Like how, yeah, like actually in a self supervised way,

1:36:14.360 --> 1:36:17.280
 learning strictly a function that says,

1:36:17.280 --> 1:36:20.600
 is this image going to be very useful to me,

1:36:20.600 --> 1:36:22.160
 given what I currently know?

1:36:22.160 --> 1:36:24.040
 I think there is a lot of synergy there.

1:36:24.040 --> 1:36:26.760
 It's just, I think, yeah, it's going to be explored.

1:36:27.680 --> 1:36:29.400
 I think very much related to that.

1:36:29.400 --> 1:36:32.400
 I kind of think of what Tesla autopilot is doing

1:36:32.400 --> 1:36:36.880
 at currently as kind of active learning.

1:36:36.880 --> 1:36:39.280
 There's something that Andre Capati and their team

1:36:39.280 --> 1:36:41.280
 are calling data engine.

1:36:41.280 --> 1:36:45.680
 So you're basically deploying a bunch of instantiations

1:36:45.680 --> 1:36:47.880
 of a neural network into the wild

1:36:47.880 --> 1:36:50.680
 and they're collecting a bunch of edge cases

1:36:50.680 --> 1:36:53.240
 that are then sent back for annotation,

1:36:53.240 --> 1:36:56.720
 for particular, and edge cases as defined as near failure

1:36:56.720 --> 1:37:00.000
 or some weirdness on a particular task

1:37:00.000 --> 1:37:04.000
 that's then sent back, it's that not exactly a banana,

1:37:04.000 --> 1:37:07.200
 but almost a banana cases, send back for annotation

1:37:07.200 --> 1:37:09.200
 and then there's this loop that keeps going

1:37:09.200 --> 1:37:11.600
 and you keep retraining and retraining

1:37:11.600 --> 1:37:13.360
 and the active learning step there,

1:37:13.360 --> 1:37:14.800
 or whatever you want to call it,

1:37:14.800 --> 1:37:19.080
 is the cars themselves that are sending you back the data,

1:37:19.080 --> 1:37:20.760
 like what the hell happened here?

1:37:20.760 --> 1:37:22.800
 This was weird.

1:37:22.800 --> 1:37:26.440
 What are your thoughts about that sort of deployment

1:37:26.440 --> 1:37:28.240
 of neural networks in the wild?

1:37:28.240 --> 1:37:31.320
 Another way to ask a question for first is your thoughts

1:37:31.320 --> 1:37:33.840
 and maybe if you want to comment,

1:37:33.840 --> 1:37:36.960
 is there applications for autonomous driving,

1:37:36.960 --> 1:37:40.160
 like computer vision based autonomous driving,

1:37:40.160 --> 1:37:42.040
 applications of self supervised learning

1:37:42.040 --> 1:37:46.080
 in the context of computer vision based autonomous driving?

1:37:47.520 --> 1:37:48.360
 So I think so.

1:37:48.360 --> 1:37:50.040
 I think for self supervised learning to be used

1:37:50.040 --> 1:37:52.720
 in autonomous driving, there's lots of opportunities.

1:37:52.720 --> 1:37:55.840
 Just like pure consistency in predictions is one way, right?

1:37:55.840 --> 1:38:00.280
 So because you have this nice sequence of data

1:38:00.280 --> 1:38:02.360
 that is coming in a video stream of it,

1:38:02.360 --> 1:38:04.080
 associated of course with the actions

1:38:04.080 --> 1:38:05.440
 that say the car took,

1:38:05.440 --> 1:38:07.640
 you can form a very nice predictive model

1:38:07.640 --> 1:38:08.480
 of what's happening.

1:38:08.480 --> 1:38:10.600
 So for example, like all the way,

1:38:11.440 --> 1:38:14.480
 like one way possibly in which how they're figuring out

1:38:14.480 --> 1:38:15.920
 what data to get labeled is basically

1:38:15.920 --> 1:38:17.480
 through prediction uncertainty, right?

1:38:17.480 --> 1:38:20.400
 So you predict that the car was going to turn right.

1:38:20.400 --> 1:38:21.880
 So this was the action that was going to happen,

1:38:21.880 --> 1:38:24.680
 say in the shadow mode and now the driver turned left.

1:38:24.680 --> 1:38:27.200
 And this is a really big surprise.

1:38:27.200 --> 1:38:30.160
 So basically by forming these good predictive models,

1:38:30.160 --> 1:38:32.760
 you are, I mean, these are kind of self supervised models,

1:38:32.760 --> 1:38:33.600
 right?

1:38:33.600 --> 1:38:34.640
 Prediction models are basically being trained

1:38:34.640 --> 1:38:36.800
 just by looking at what's going to happen next

1:38:36.800 --> 1:38:38.960
 and asking them to predict what's going to happen next.

1:38:38.960 --> 1:38:40.720
 So I would say this is really like one use

1:38:40.720 --> 1:38:42.320
 of self supervised learning.

1:38:42.320 --> 1:38:43.440
 It's a predictive model

1:38:43.440 --> 1:38:44.680
 and you're learning a predictive model

1:38:44.680 --> 1:38:46.880
 basically just by looking at what data you have.

1:38:46.880 --> 1:38:49.600
 Is there something about that active learning context

1:38:49.600 --> 1:38:53.000
 that you find insights from?

1:38:53.000 --> 1:38:54.760
 Like that kind of deployment of the system,

1:38:54.760 --> 1:38:59.120
 seeing cases where it doesn't perform as you expected

1:38:59.120 --> 1:39:01.000
 and then retraining the system based on that?

1:39:01.000 --> 1:39:03.600
 I think that, I mean, that really resonates with me.

1:39:03.600 --> 1:39:05.520
 It's super smart to do it that way.

1:39:05.520 --> 1:39:08.760
 Because I mean, the thing is with any kind of like

1:39:08.760 --> 1:39:11.120
 practical system like autonomous driving,

1:39:11.120 --> 1:39:12.600
 there are those edge cases

1:39:12.600 --> 1:39:14.520
 that are the things that are actually the problem, right?

1:39:14.520 --> 1:39:17.400
 I mean, highway driving or like freeway driving

1:39:17.400 --> 1:39:20.120
 has basically been like, there has been a lot of success

1:39:20.120 --> 1:39:21.800
 in that particular part of autonomous driving

1:39:21.800 --> 1:39:25.520
 for a long time, I would say like since the 80s or something.

1:39:25.520 --> 1:39:28.000
 Now, the point is all these failure cases

1:39:28.000 --> 1:39:30.560
 are the sort of reason why autonomous driving

1:39:30.560 --> 1:39:33.360
 hasn't become like super, super mainstream

1:39:33.360 --> 1:39:35.640
 available like in every possible car right now.

1:39:35.640 --> 1:39:38.200
 And so basically by really scaling this problem out

1:39:38.200 --> 1:39:40.440
 by really trying to get all of these edge cases out

1:39:40.440 --> 1:39:41.840
 as quickly as possible.

1:39:41.840 --> 1:39:43.920
 And then just like using those to improve your model,

1:39:43.920 --> 1:39:45.640
 that's super smart.

1:39:45.640 --> 1:39:47.440
 And prediction uncertainty to do that is like

1:39:47.440 --> 1:39:49.800
 one really nice way of doing it.

1:39:49.800 --> 1:39:52.080
 Let me put you on the spot.

1:39:52.080 --> 1:39:55.320
 So we mentioned offline Jitendra,

1:39:55.320 --> 1:39:58.280
 he thinks that the Tesla computer vision approach

1:39:58.280 --> 1:40:00.840
 or really any approach for autonomous driving

1:40:00.840 --> 1:40:02.720
 is very far away.

1:40:02.720 --> 1:40:07.000
 How many years away, if you have to bet all your money on it,

1:40:07.000 --> 1:40:09.640
 are we just solving autonomous driving

1:40:09.640 --> 1:40:12.040
 with this kind of computer vision only

1:40:12.040 --> 1:40:13.600
 machine learning based approach?

1:40:13.600 --> 1:40:15.440
 Okay, so what does solving autonomous driving mean?

1:40:15.440 --> 1:40:17.240
 Does it mean solving it in the US?

1:40:17.240 --> 1:40:18.520
 Does it mean solving it in India?

1:40:18.520 --> 1:40:20.160
 Because I can tell you that very different types

1:40:20.160 --> 1:40:21.200
 of driving happening.

1:40:21.200 --> 1:40:22.880
 Not India, not Russia.

1:40:22.880 --> 1:40:26.280
 In the United States autonomous,

1:40:26.280 --> 1:40:31.280
 so what solving means is when the car says it has control,

1:40:32.000 --> 1:40:34.200
 it is fully liable.

1:40:34.200 --> 1:40:37.920
 You can go to sleep, is driving by itself.

1:40:37.920 --> 1:40:39.880
 So this is highway and city driving,

1:40:39.880 --> 1:40:42.440
 but not everywhere, but mostly everywhere.

1:40:42.440 --> 1:40:45.160
 And it's let's say significantly better,

1:40:45.160 --> 1:40:50.160
 like say five times less accidents than humans.

1:40:50.600 --> 1:40:54.080
 Sufficiently safer such that the public feels

1:40:54.080 --> 1:40:58.040
 like that transition is enticing beneficial

1:40:58.040 --> 1:40:59.640
 both for our safety and financing,

1:40:59.640 --> 1:41:01.120
 all those kinds of things.

1:41:01.120 --> 1:41:02.360
 Okay, so first disclaimer,

1:41:02.360 --> 1:41:04.320
 I'm not an expert in autonomous driving.

1:41:04.320 --> 1:41:06.040
 So let me put it out there.

1:41:06.040 --> 1:41:08.400
 I would say like at least five to 10 years.

1:41:09.440 --> 1:41:11.840
 This would be mine, I guess from now.

1:41:13.800 --> 1:41:14.760
 I'm actually very impressed.

1:41:14.760 --> 1:41:16.880
 Like when I sat in a friend's Tesla recently

1:41:16.880 --> 1:41:19.240
 and of course like looking,

1:41:19.240 --> 1:41:20.720
 so it can, on the screen,

1:41:20.720 --> 1:41:22.920
 it basically shows all the detections and everything

1:41:22.920 --> 1:41:24.720
 that the car is doing as you're driving by.

1:41:24.720 --> 1:41:26.960
 And that's super distracting for me as a person

1:41:26.960 --> 1:41:29.520
 because all I keep looking at is like the bounding boxes

1:41:29.520 --> 1:41:31.800
 in the cars, it's tracking and it's really impressive.

1:41:31.800 --> 1:41:33.040
 Like especially when it's raining

1:41:33.040 --> 1:41:34.360
 and it's able to do that,

1:41:34.360 --> 1:41:36.040
 that was the most impressive part for me.

1:41:36.040 --> 1:41:38.600
 It's actually able to get through rain and do that.

1:41:38.600 --> 1:41:41.800
 And one of the reasons why like a lot of us believed

1:41:41.800 --> 1:41:44.120
 and I would put myself in that category

1:41:44.120 --> 1:41:46.880
 is LiDAR based sort of technology

1:41:46.880 --> 1:41:48.760
 for autonomous driving was the key driver, right?

1:41:48.760 --> 1:41:51.000
 So Waymo was using it for the longest time.

1:41:51.000 --> 1:41:53.320
 And Tesla then decided to go this completely other route

1:41:53.320 --> 1:41:55.800
 that oh, we're not going to even use LiDAR.

1:41:55.800 --> 1:41:58.720
 So their initial system I think was camera and radar based

1:41:58.720 --> 1:41:59.680
 and now they're actually moving

1:41:59.680 --> 1:42:02.040
 to a completely like vision based system.

1:42:02.040 --> 1:42:04.680
 And so that was just like, it sounded completely crazy.

1:42:04.680 --> 1:42:07.040
 Like LiDAR is very useful in cases

1:42:07.040 --> 1:42:09.280
 where you have low visibility.

1:42:09.280 --> 1:42:11.760
 Of course it comes with its own set of complications.

1:42:11.760 --> 1:42:15.200
 But now to see that happen in like on a live Tesla

1:42:15.200 --> 1:42:17.040
 that basically just proves everyone wrong,

1:42:17.040 --> 1:42:18.200
 I would say in a way.

1:42:18.200 --> 1:42:20.600
 And that's just working really well.

1:42:20.600 --> 1:42:22.800
 I think there were also like a lot of advancements

1:42:22.800 --> 1:42:23.960
 in camera technology.

1:42:23.960 --> 1:42:26.360
 Now there were like, I know at CMU when I was there

1:42:26.360 --> 1:42:28.000
 there was a particular kind of camera

1:42:28.000 --> 1:42:30.120
 that had been developed that was really good

1:42:30.120 --> 1:42:32.800
 at basically low visibility setting.

1:42:32.800 --> 1:42:34.480
 So like lots of snow and lots of rain,

1:42:34.480 --> 1:42:37.720
 it could actually still have a very reasonable visibility.

1:42:37.720 --> 1:42:39.440
 And I think there are lots of these kinds of innovations

1:42:39.440 --> 1:42:41.000
 that will happen on the sensor side itself

1:42:41.000 --> 1:42:42.880
 which is actually going to make this very easy

1:42:42.880 --> 1:42:43.880
 in the future.

1:42:43.880 --> 1:42:46.120
 And so maybe that's actually why I'm more optimistic

1:42:46.120 --> 1:42:49.040
 about vision based self like autonomous driving.

1:42:49.040 --> 1:42:50.440
 It's gonna call it self supervised driving,

1:42:50.440 --> 1:42:53.520
 but vision based autonomous driving,

1:42:53.520 --> 1:42:55.440
 that's the reason I'm quite optimistic about it.

1:42:55.440 --> 1:42:56.640
 Because I think there are going to be lots

1:42:56.640 --> 1:42:58.960
 of these advances on the sensor side itself.

1:42:58.960 --> 1:43:00.720
 So acquiring this data,

1:43:00.720 --> 1:43:02.640
 we're actually going to get much better about it.

1:43:02.640 --> 1:43:05.080
 And then of course when once we're able to scale out

1:43:05.080 --> 1:43:06.800
 and get all of these edge cases in,

1:43:06.800 --> 1:43:08.720
 as like Andre described,

1:43:08.720 --> 1:43:11.720
 I think that's going to make us go very far away.

1:43:11.720 --> 1:43:13.560
 Yeah, so it's funny,

1:43:13.560 --> 1:43:16.280
 I'm very much with you on the five to 10 years,

1:43:16.280 --> 1:43:17.840
 maybe 10 years,

1:43:17.840 --> 1:43:20.080
 but you made it,

1:43:20.080 --> 1:43:21.760
 I'm not sure how you made it sound,

1:43:21.760 --> 1:43:25.320
 but for some people that might seem like really far away,

1:43:25.320 --> 1:43:26.920
 and then for other people,

1:43:27.800 --> 1:43:30.440
 it might seem like very close.

1:43:30.440 --> 1:43:32.320
 There's a lot of fundamental questions

1:43:32.320 --> 1:43:36.880
 about how much game theory is in this whole thing.

1:43:36.880 --> 1:43:41.880
 So how much is this simply collision avoidance problem?

1:43:42.120 --> 1:43:44.360
 And how much of it is,

1:43:44.360 --> 1:43:46.960
 you're still interacting with other humans in the scene,

1:43:46.960 --> 1:43:49.480
 and you're trying to create an experience that's compelling

1:43:49.480 --> 1:43:53.080
 so you want to get from point A to point B quickly,

1:43:53.080 --> 1:43:55.280
 you want to navigate the scene in a safe way,

1:43:55.280 --> 1:43:58.480
 but you also want to show some level of aggression,

1:43:58.480 --> 1:44:02.000
 because, well, certainly this is why you're screwed in India

1:44:02.000 --> 1:44:03.400
 because you have to show aggression.

1:44:03.400 --> 1:44:04.600
 Or Jersey, or New Jersey.

1:44:04.600 --> 1:44:05.440
 Or Jersey.

1:44:05.440 --> 1:44:10.440
 So like, or New York, or basically any major city,

1:44:11.200 --> 1:44:14.440
 but I think it's probably Elon that I talked the most

1:44:14.440 --> 1:44:16.960
 about this, which is a surprise to the level

1:44:16.960 --> 1:44:20.080
 of which they're not considering human beings

1:44:20.080 --> 1:44:22.960
 as a huge problem in this as a source of problem.

1:44:22.960 --> 1:44:27.960
 Like the driving is fundamentally a robot on robot

1:44:29.000 --> 1:44:31.160
 versus the environment problem,

1:44:31.160 --> 1:44:33.960
 versus like you can just consider humans

1:44:33.960 --> 1:44:35.160
 not part of the problem.

1:44:35.160 --> 1:44:38.840
 I used to think humans are almost certainly

1:44:38.840 --> 1:44:41.200
 have to be modeled really well.

1:44:41.200 --> 1:44:44.360
 Pedestrians and cyclists and humans inside of the cars,

1:44:44.360 --> 1:44:46.320
 you have to have like mental models for them.

1:44:46.320 --> 1:44:48.280
 You cannot just see it as objects.

1:44:48.280 --> 1:44:50.480
 But more and more, it's like the,

1:44:51.400 --> 1:44:53.700
 it's the same kind of intuition breaking thing

1:44:53.700 --> 1:44:56.200
 that self supervised learning does,

1:44:56.200 --> 1:44:58.840
 which is, well, maybe through the learning,

1:44:58.840 --> 1:45:01.520
 you'll get all the human,

1:45:01.520 --> 1:45:04.440
 like human information you need, right?

1:45:04.440 --> 1:45:07.320
 Like maybe you'll get it just with enough data.

1:45:07.320 --> 1:45:09.680
 You don't need to have explicit good models

1:45:09.680 --> 1:45:10.800
 of human behavior.

1:45:10.800 --> 1:45:12.120
 Maybe you get it through the data.

1:45:12.120 --> 1:45:14.640
 So I mean, my skepticism also just knowing

1:45:14.640 --> 1:45:16.360
 a lot of automotive companies

1:45:16.360 --> 1:45:18.600
 and how difficult it is to be innovative.

1:45:18.600 --> 1:45:22.520
 I was skeptical that they would be able at scale

1:45:22.520 --> 1:45:27.400
 to convert the driving scene across the world

1:45:27.400 --> 1:45:30.640
 into digital form such that you can create

1:45:30.640 --> 1:45:33.160
 this data engine at scale.

1:45:33.160 --> 1:45:36.640
 And the fact that Tesla is at least getting there

1:45:36.640 --> 1:45:40.400
 or are already there makes me think

1:45:40.400 --> 1:45:43.640
 that it's now starting to be coupled

1:45:43.640 --> 1:45:47.600
 to this self supervised learning vision,

1:45:47.600 --> 1:45:49.840
 which is like, if that's gonna work,

1:45:49.840 --> 1:45:52.920
 if through purely this process you can get really far,

1:45:52.920 --> 1:45:54.880
 then maybe you can solve driving that way.

1:45:54.880 --> 1:45:55.720
 I don't know.

1:45:55.720 --> 1:46:00.000
 I tend to believe we don't give enough credit

1:46:00.000 --> 1:46:05.000
 to the how amazing humans are both at driving

1:46:05.960 --> 1:46:09.400
 and at supervising autonomous systems.

1:46:09.400 --> 1:46:13.240
 And also we don't, I wish we were,

1:46:13.240 --> 1:46:17.160
 I wish there was much more driver sensing inside Teslas

1:46:17.160 --> 1:46:21.240
 and much deeper consideration of human factors,

1:46:21.240 --> 1:46:24.720
 like understanding psychology and drowsiness

1:46:24.720 --> 1:46:26.240
 and all those kinds of things.

1:46:26.240 --> 1:46:28.760
 When the car does more and more of the work,

1:46:28.760 --> 1:46:33.000
 how to keep utilizing the little human supervision

1:46:33.000 --> 1:46:35.120
 that I needed to keep this whole thing safe.

1:46:35.120 --> 1:46:38.480
 I mean, it's a fascinating dance of human robot interaction.

1:46:38.480 --> 1:46:42.160
 To me, autonomous driving for a long time

1:46:42.160 --> 1:46:45.080
 is a human robot interaction problem.

1:46:45.080 --> 1:46:48.080
 It is not a robotics problem or computer vision problem.

1:46:48.080 --> 1:46:50.040
 Like you have to have a human in the loop.

1:46:50.040 --> 1:46:53.360
 But so, which is why I think it's 10 years plus.

1:46:53.360 --> 1:46:56.320
 But I do think there'll be a bunch of cities and contexts

1:46:56.320 --> 1:47:01.320
 where geo restricted, it will work really, really damn well.

1:47:01.800 --> 1:47:02.640
 Yeah.

1:47:02.640 --> 1:47:05.000
 So I think for me, it's five if I'm being optimistic

1:47:05.000 --> 1:47:07.400
 and it's going to be five for a lot of cases.

1:47:07.400 --> 1:47:09.240
 And 10 plus, yeah, I agree with you.

1:47:09.240 --> 1:47:13.160
 10 plus, basically, if we want to recover most of,

1:47:13.160 --> 1:47:15.280
 say, contiguous United States or something.

1:47:15.280 --> 1:47:16.120
 Oh, interesting.

1:47:16.120 --> 1:47:20.320
 So my optimistic is five and pessimistic is 30.

1:47:20.320 --> 1:47:21.160
 30.

1:47:21.160 --> 1:47:22.520
 I have a long tail on this one.

1:47:22.520 --> 1:47:24.440
 I haven't watched enough driving videos.

1:47:24.440 --> 1:47:29.160
 I've watched enough pedestrians to think like we may be,

1:47:29.160 --> 1:47:31.680
 like there's a small part of me still, not a small,

1:47:31.680 --> 1:47:34.360
 like a pretty big part of me that thinks

1:47:34.360 --> 1:47:37.560
 we will have to build AGI to solve driving.

1:47:37.560 --> 1:47:38.440
 Oh well.

1:47:38.440 --> 1:47:40.040
 Like there's something to me like,

1:47:40.040 --> 1:47:41.800
 because humans are part of the picture,

1:47:41.800 --> 1:47:44.000
 deeply part of the picture,

1:47:44.000 --> 1:47:46.080
 and also human society is part of the picture

1:47:46.080 --> 1:47:47.920
 in that human life is at stake.

1:47:47.920 --> 1:47:50.840
 Anytime a robot kills a human,

1:47:50.840 --> 1:47:54.280
 it's not clear to me that that's not a problem

1:47:54.280 --> 1:47:56.360
 that machine learning will also have to solve.

1:47:56.360 --> 1:48:00.080
 Like you have to integrate that into the whole thing.

1:48:00.080 --> 1:48:03.280
 Just like Facebook or social networks,

1:48:03.280 --> 1:48:04.600
 one thing is to say how to make

1:48:04.600 --> 1:48:06.720
 a really good recommender system.

1:48:06.720 --> 1:48:08.640
 And then the other thing is to integrate

1:48:08.640 --> 1:48:10.240
 into that recommender system,

1:48:10.240 --> 1:48:12.080
 all the journalists that will write articles

1:48:12.080 --> 1:48:13.880
 about that recommender system.

1:48:13.880 --> 1:48:15.880
 Like you have to consider the society

1:48:15.880 --> 1:48:18.400
 within which the AI system operates.

1:48:18.400 --> 1:48:21.000
 And in order to, and like politicians too,

1:48:21.000 --> 1:48:24.200
 this is regulatory stuff for autonomous driving.

1:48:24.200 --> 1:48:26.720
 It's kind of fascinating that the more successful

1:48:26.720 --> 1:48:28.720
 your AI system becomes,

1:48:28.720 --> 1:48:31.600
 the more it gets integrated in society

1:48:31.600 --> 1:48:34.600
 and the more precious politicians and the public

1:48:34.600 --> 1:48:36.000
 and the clickbait journalists

1:48:36.000 --> 1:48:38.040
 and all the different fascinating forces

1:48:38.040 --> 1:48:40.360
 of our society start acting on it.

1:48:40.360 --> 1:48:42.200
 And then it's no longer how good you are

1:48:42.200 --> 1:48:43.960
 at doing the initial task.

1:48:43.960 --> 1:48:47.000
 It's also how good you are at navigating human nature,

1:48:47.000 --> 1:48:49.920
 which is a fascinating space.

1:48:49.920 --> 1:48:52.600
 What do you think are the limits of deep learning?

1:48:52.600 --> 1:48:54.800
 If you allow me, we'll zoom out a little bit

1:48:54.800 --> 1:48:58.080
 into the big question of artificial intelligence.

1:48:58.080 --> 1:49:01.240
 You said dark matter of intelligence

1:49:01.240 --> 1:49:04.320
 is self supervised learning, but there could be more.

1:49:04.320 --> 1:49:07.760
 What do you think the limits of self supervised learning

1:49:07.760 --> 1:49:10.720
 and just learning in general, deep learning are?

1:49:10.720 --> 1:49:12.680
 I think like for deep learning in particular,

1:49:12.680 --> 1:49:14.640
 because self supervised learning is I would say

1:49:14.640 --> 1:49:16.800
 a little bit more vague right now.

1:49:16.800 --> 1:49:18.680
 So I wouldn't like for something that's so vague,

1:49:18.680 --> 1:49:21.960
 it's hard to predict what its limits are going to be.

1:49:21.960 --> 1:49:25.240
 But like I said, I think anywhere you want to interact

1:49:25.240 --> 1:49:27.920
 with human self supervised learning kind of hits a boundary

1:49:27.920 --> 1:49:29.960
 very quickly because you need to have an interface

1:49:29.960 --> 1:49:31.600
 to be able to communicate with the human.

1:49:31.600 --> 1:49:35.040
 So really like if you have just like vacuous concepts

1:49:35.040 --> 1:49:38.600
 or like just like nebulous concepts discovered by a network,

1:49:38.600 --> 1:49:40.360
 it's very hard to communicate those for the human

1:49:40.360 --> 1:49:42.440
 without like inserting some kind of human knowledge

1:49:42.440 --> 1:49:44.360
 or some kind of like human bias there.

1:49:45.600 --> 1:49:47.040
 In general, I think for deep learning,

1:49:47.040 --> 1:49:50.680
 the biggest challenge is just like data efficiency.

1:49:50.680 --> 1:49:52.200
 Even with self supervised learning,

1:49:52.200 --> 1:49:53.560
 even with anything else,

1:49:53.560 --> 1:49:57.440
 if you just see a single concept once,

1:49:57.440 --> 1:49:59.840
 like one image of a, like I don't know

1:49:59.840 --> 1:50:02.520
 whatever you want to call it, like any concept,

1:50:02.520 --> 1:50:04.800
 it's really hard for these methods to generalize

1:50:04.800 --> 1:50:07.680
 by looking at just one or two samples of things.

1:50:07.680 --> 1:50:09.760
 And that has been a real challenge.

1:50:09.760 --> 1:50:11.680
 And I think that's actually why like these edge cases,

1:50:11.680 --> 1:50:14.520
 for example, for Tesla are actually that important.

1:50:14.520 --> 1:50:18.040
 Because if you see just one instance of the car failing,

1:50:18.040 --> 1:50:19.320
 and if you just annotate that

1:50:19.320 --> 1:50:21.360
 and you get that into your data set,

1:50:21.360 --> 1:50:23.560
 it's you have like very limited guarantee

1:50:23.560 --> 1:50:25.160
 that it's not going to happen again.

1:50:25.160 --> 1:50:26.720
 And you're actually going to be able to recognize

1:50:26.720 --> 1:50:28.640
 this kind of instance in a very different scenario.

1:50:28.640 --> 1:50:30.320
 So like when it was snowing,

1:50:30.320 --> 1:50:32.040
 so you got that thing labeled when it was snowing,

1:50:32.040 --> 1:50:33.240
 but now when it's raining,

1:50:33.240 --> 1:50:34.640
 you're actually not able to get it.

1:50:34.640 --> 1:50:36.600
 Or you basically have the same scenario

1:50:36.600 --> 1:50:37.440
 in a different part of the world.

1:50:37.440 --> 1:50:39.120
 So the lighting was different or so on.

1:50:39.120 --> 1:50:41.000
 So it's just really hard for these models,

1:50:41.000 --> 1:50:42.720
 like deep learning, especially to do that.

1:50:42.720 --> 1:50:43.560
 What's your intuition?

1:50:43.560 --> 1:50:47.600
 How do we solve Henry and Digi recognition problem

1:50:47.600 --> 1:50:51.240
 when we only have one example for each number?

1:50:51.240 --> 1:50:54.760
 It feels like humans are using something like learning.

1:50:54.760 --> 1:50:56.040
 Right, I think it's,

1:50:56.040 --> 1:50:59.280
 we are good at transferring knowledge a little bit.

1:50:59.280 --> 1:51:01.280
 We are just better at like,

1:51:01.280 --> 1:51:02.680
 for a lot of these problems

1:51:02.680 --> 1:51:04.880
 where we are generalizing from a single sample,

1:51:04.880 --> 1:51:07.000
 recognizing from a single sample,

1:51:07.000 --> 1:51:08.800
 we are using a lot of our own domain knowledge

1:51:08.800 --> 1:51:10.360
 and a lot of our like inductive bias

1:51:10.360 --> 1:51:12.320
 into that one sample to generalize it.

1:51:12.320 --> 1:51:15.360
 So I've never seen you write the number nine, for example.

1:51:15.360 --> 1:51:17.480
 And if you were to write it, I would still get it.

1:51:17.480 --> 1:51:19.320
 And if you were to write a different kind of alphabet

1:51:19.320 --> 1:51:20.880
 and like write it in two different ways,

1:51:20.880 --> 1:51:22.360
 I would still probably be able to figure out

1:51:22.360 --> 1:51:24.720
 that these are the same two characters.

1:51:24.720 --> 1:51:26.960
 It's just that I have been very used to seeing

1:51:26.960 --> 1:51:29.080
 Henry and digits in my life.

1:51:29.080 --> 1:51:31.360
 The other sort of problem with any deep learning system

1:51:31.360 --> 1:51:32.720
 or any kind of machine learning system

1:51:32.720 --> 1:51:34.200
 is like it's guarantees, right?

1:51:34.200 --> 1:51:35.880
 There are no guarantees for it.

1:51:35.880 --> 1:51:38.200
 Now you can argue that humans also don't have any guarantees.

1:51:38.200 --> 1:51:41.160
 Like there is no guarantee that I can recognize a cat

1:51:41.160 --> 1:51:42.280
 in every scenario.

1:51:42.280 --> 1:51:43.920
 I'm sure there are going to be lots of cats

1:51:43.920 --> 1:51:45.040
 that I don't recognize,

1:51:45.040 --> 1:51:47.120
 lots of scenarios in which I don't recognize cats

1:51:47.120 --> 1:51:48.120
 in general.

1:51:48.120 --> 1:51:52.880
 But I think from just a sort of application perspective,

1:51:52.880 --> 1:51:54.800
 you do need guarantees, right?

1:51:54.800 --> 1:51:57.000
 We call these things algorithms.

1:51:57.000 --> 1:51:59.120
 Now algorithms, like traditional CS algorithms

1:51:59.120 --> 1:52:00.000
 have guarantees.

1:52:00.000 --> 1:52:01.520
 Sorting is a guarantee.

1:52:01.520 --> 1:52:05.640
 If you were to call sort on a particular array of numbers,

1:52:05.640 --> 1:52:07.680
 you are guaranteed that it's going to be sorted.

1:52:07.680 --> 1:52:09.360
 Otherwise, it's a bug.

1:52:09.360 --> 1:52:12.480
 Now for machine learning, it's very hard to characterize this.

1:52:12.480 --> 1:52:15.480
 We know for a fact that a cat recognition model

1:52:15.480 --> 1:52:18.040
 is not going to recognize cats, every cat in the world

1:52:18.040 --> 1:52:19.760
 in every circumstance.

1:52:19.760 --> 1:52:22.080
 I think most people would agree with that statement.

1:52:22.080 --> 1:52:23.640
 But we are still OK with it.

1:52:23.640 --> 1:52:25.400
 We still don't call this as a bug.

1:52:25.400 --> 1:52:26.720
 Whereas in traditional computer science

1:52:26.720 --> 1:52:29.520
 or traditional science, if you have this kind of failure case

1:52:29.520 --> 1:52:33.200
 existing, then you think of it as something is wrong.

1:52:33.200 --> 1:52:36.080
 I think there is this sort of notion of nebulous correctness

1:52:36.080 --> 1:52:37.040
 for machine learning.

1:52:37.040 --> 1:52:39.520
 And that's something we just need to be very comfortable with.

1:52:39.520 --> 1:52:42.000
 And for deep learning or for a lot of these machine learning

1:52:42.000 --> 1:52:45.160
 algorithms, it's not clear how do we characterize this notion

1:52:45.160 --> 1:52:46.360
 of correctness.

1:52:46.360 --> 1:52:48.160
 I think limitation in our understanding

1:52:48.160 --> 1:52:51.200
 or at least a limitation in our phrasing of this.

1:52:51.200 --> 1:52:53.080
 And if we were to come up with better ways

1:52:53.080 --> 1:52:55.760
 to understand this limitation, then it would actually

1:52:55.760 --> 1:52:57.240
 help us a lot.

1:52:57.240 --> 1:52:58.840
 Do you think there's a distinction

1:52:58.840 --> 1:53:04.320
 between the concept of learning and the concept of reasoning?

1:53:04.320 --> 1:53:10.320
 Do you think it's possible for neural networks to reason?

1:53:10.320 --> 1:53:11.800
 So I think of it slightly differently.

1:53:11.800 --> 1:53:15.680
 So for me, learning is whenever I can make a snap judgment.

1:53:15.680 --> 1:53:17.200
 So if you show me a picture of a dog,

1:53:17.200 --> 1:53:18.920
 I can immediately say it's a dog.

1:53:18.920 --> 1:53:21.760
 But if you give me a puzzle, whatever,

1:53:21.760 --> 1:53:24.640
 a Goldberg machine of things going to happen,

1:53:24.640 --> 1:53:25.640
 then I have to reason.

1:53:25.640 --> 1:53:27.600
 Because it's a very complicated setup.

1:53:27.600 --> 1:53:29.320
 I've never seen that particular setup.

1:53:29.320 --> 1:53:32.200
 And I really need to draw and imagine in my head

1:53:32.200 --> 1:53:34.680
 what's going to happen to figure it out.

1:53:34.680 --> 1:53:38.920
 So I think, yes, neural networks are really good at recognition,

1:53:38.920 --> 1:53:41.160
 but they're not very good at reasoning.

1:53:41.160 --> 1:53:44.760
 Because if they have seen something before or seen

1:53:44.760 --> 1:53:45.920
 something similar before, they're

1:53:45.920 --> 1:53:48.240
 very good at making those sort of snap judgments.

1:53:48.240 --> 1:53:50.680
 But if you were to give them a very complicated thing

1:53:50.680 --> 1:53:52.600
 that they've not seen before, they

1:53:52.600 --> 1:53:55.280
 have very limited ability right now

1:53:55.280 --> 1:53:56.560
 to compose different things.

1:53:56.560 --> 1:53:58.320
 Like, oh, I've seen this particular part before.

1:53:58.320 --> 1:54:00.040
 I've seen this particular part before.

1:54:00.040 --> 1:54:02.920
 And now probably this is how they're going to work in tandem.

1:54:02.920 --> 1:54:05.200
 It's very hard for them to come up with these kinds of things.

1:54:05.200 --> 1:54:08.800
 Well, there's a certain aspect to reasoning

1:54:08.800 --> 1:54:11.880
 that you can maybe convert into the process of programming.

1:54:11.880 --> 1:54:14.320
 And so there's the whole field of the program synthesis.

1:54:14.320 --> 1:54:17.240
 And people have been applying machine learning

1:54:17.240 --> 1:54:18.920
 to the problem of program synthesis.

1:54:18.920 --> 1:54:22.680
 And the question is, can the step of composition,

1:54:22.680 --> 1:54:25.520
 why can't that be learned?

1:54:25.520 --> 1:54:29.400
 This step of building things on top of it,

1:54:29.400 --> 1:54:33.240
 like little intuitions, concepts on top of each other,

1:54:33.240 --> 1:54:35.320
 can that be learnable?

1:54:35.320 --> 1:54:37.760
 What's your intuition there?

1:54:37.760 --> 1:54:39.480
 I guess a similar set of techniques,

1:54:39.480 --> 1:54:42.080
 do you think that would be applicable?

1:54:42.080 --> 1:54:44.000
 So I think it is, of course, learnable.

1:54:44.000 --> 1:54:47.080
 It is learnable because we are prime examples of machines

1:54:47.080 --> 1:54:49.640
 that have, or individuals that have learned this.

1:54:49.640 --> 1:54:51.120
 Humans have learned this.

1:54:51.120 --> 1:54:52.920
 So it is, of course, it is a technique that

1:54:52.920 --> 1:54:55.920
 is very easy to learn.

1:54:55.920 --> 1:54:58.920
 I think where we are kind of hitting a wall basically

1:54:58.920 --> 1:55:01.280
 with current machine learning is the fact

1:55:01.280 --> 1:55:04.680
 that when the network learns all of this information,

1:55:04.680 --> 1:55:08.200
 we basically are not able to figure out how well it's

1:55:08.200 --> 1:55:10.680
 going to generalize to an unseen thing.

1:55:10.680 --> 1:55:15.080
 And we have no a priori, no way of characterizing that.

1:55:15.080 --> 1:55:19.640
 And I think that's basically telling us a lot about the fact

1:55:19.640 --> 1:55:21.680
 that we really don't know what this model has learned

1:55:21.680 --> 1:55:23.960
 and how well it's basically, because we don't know how well

1:55:23.960 --> 1:55:25.240
 it's going to transfer.

1:55:25.240 --> 1:55:29.400
 There's also a sense in which it feels like we humans may not

1:55:29.400 --> 1:55:35.960
 be aware of how much background, how good our background model

1:55:35.960 --> 1:55:40.080
 is, how much knowledge we just have slowly building

1:55:40.080 --> 1:55:41.240
 on top of each other.

1:55:41.240 --> 1:55:43.760
 It feels like neural networks are constantly throwing stuff

1:55:43.760 --> 1:55:44.240
 out.

1:55:44.240 --> 1:55:45.720
 You'll do some incredible thing where

1:55:45.720 --> 1:55:49.240
 you're learning a particular task in computer vision.

1:55:49.240 --> 1:55:51.440
 You celebrate your state of the art successes,

1:55:51.440 --> 1:55:53.200
 and you throw that out.

1:55:53.200 --> 1:55:56.400
 It feels like you're never using stuff

1:55:56.400 --> 1:56:00.280
 you've learned for your future successes in other domains.

1:56:00.280 --> 1:56:03.400
 And humans are obviously doing that exceptionally well,

1:56:03.400 --> 1:56:06.000
 still throwing stuff away in their mind,

1:56:06.000 --> 1:56:08.000
 but keeping certain kernels of truth.

1:56:08.000 --> 1:56:10.280
 Right, so I think we're like, continual learning

1:56:10.280 --> 1:56:12.280
 is sort of the paradigm for listen machine learning.

1:56:12.280 --> 1:56:15.360
 And I don't think it's a very well explored paradigm.

1:56:15.360 --> 1:56:17.560
 We have things in deep learning, for example.

1:56:17.560 --> 1:56:20.320
 Catastrophic forgetting is one of the standard things.

1:56:20.320 --> 1:56:23.360
 The thing basically being that if you teach a network

1:56:23.360 --> 1:56:25.560
 to recognize dogs, and now you teach

1:56:25.560 --> 1:56:27.520
 that same network to recognize cats,

1:56:27.520 --> 1:56:29.200
 it basically forgets how to recognize dogs.

1:56:29.200 --> 1:56:31.760
 So it forgets very quickly.

1:56:31.760 --> 1:56:33.760
 And whereas a human, if you were to teach someone

1:56:33.760 --> 1:56:36.040
 to recognize dogs and then to recognize cats,

1:56:36.040 --> 1:56:38.600
 they don't forget immediately how to recognize these dogs.

1:56:38.600 --> 1:56:40.800
 I think that's basically what you're trying to get.

1:56:40.800 --> 1:56:44.880
 Yeah, I wonder if the long term memory mechanisms,

1:56:44.880 --> 1:56:47.240
 or the mechanisms that store not just memories,

1:56:47.240 --> 1:56:57.360
 but concepts that allow you to reason and compose concepts,

1:56:57.360 --> 1:57:00.040
 if those things will look very different than your networks,

1:57:00.040 --> 1:57:02.480
 or if you can do that within a single neural network

1:57:02.480 --> 1:57:06.160
 with some particular sort of architecture quirks.

1:57:06.160 --> 1:57:07.840
 That seems to be a really open problem.

1:57:07.840 --> 1:57:09.560
 And of course, I go up and down on that

1:57:09.560 --> 1:57:15.000
 because there's something so compelling to the symbolic AI

1:57:15.000 --> 1:57:20.480
 or to the ideas of logic based sort of expert systems.

1:57:20.480 --> 1:57:22.600
 You have human interpretable facts

1:57:22.600 --> 1:57:24.240
 that built on top of each other.

1:57:24.240 --> 1:57:27.960
 It's really annoying with self supervised learning

1:57:27.960 --> 1:57:31.440
 that the AI is not very explainable.

1:57:31.440 --> 1:57:35.680
 You can't understand all the beautiful things it has learned.

1:57:35.680 --> 1:57:38.520
 You can't ask it questions.

1:57:38.520 --> 1:57:41.680
 But then again, maybe that's a stupid thing for us humans

1:57:41.680 --> 1:57:42.600
 to want.

1:57:42.600 --> 1:57:45.400
 Right, I think whenever we try to understand it,

1:57:45.400 --> 1:57:48.560
 we're putting our own subjective human bias into it.

1:57:48.560 --> 1:57:50.160
 And I think that's the sort of problem.

1:57:50.160 --> 1:57:51.560
 With self supervised learning, the goal

1:57:51.560 --> 1:57:54.400
 is that it should learn naturally from the data.

1:57:54.400 --> 1:57:55.680
 So now if you try to understand it,

1:57:55.680 --> 1:57:58.840
 you are using your own preconceived notions

1:57:58.840 --> 1:58:01.080
 of what this model has learned.

1:58:01.080 --> 1:58:03.560
 That's the problem.

1:58:03.560 --> 1:58:05.200
 High level question, what do you think

1:58:05.200 --> 1:58:09.360
 it takes to build a system with super human,

1:58:09.360 --> 1:58:11.920
 maybe let's say human level or super human level,

1:58:11.920 --> 1:58:13.560
 general intelligence?

1:58:13.560 --> 1:58:15.600
 We've already kind of started talking about this,

1:58:15.600 --> 1:58:18.040
 but what's your intuition?

1:58:18.040 --> 1:58:20.880
 Does this thing have to have a body?

1:58:20.880 --> 1:58:25.440
 Does it have to interact richly with the world?

1:58:25.440 --> 1:58:27.920
 Does it have to have some more human elements

1:58:27.920 --> 1:58:30.520
 like self awareness?

1:58:30.520 --> 1:58:32.280
 I think emotion.

1:58:32.280 --> 1:58:36.560
 I think emotion is something which is like it's not really

1:58:36.560 --> 1:58:38.440
 attributed typically in standard machine learning.

1:58:38.440 --> 1:58:39.760
 It's not something we think about.

1:58:39.760 --> 1:58:41.200
 There is NLP, there is vision, there

1:58:41.200 --> 1:58:42.600
 is no emotion.

1:58:42.600 --> 1:58:44.600
 Emotion is never a part of all of this.

1:58:44.600 --> 1:58:47.080
 And that just seems a little bit weird to me.

1:58:47.080 --> 1:58:50.320
 I think the reason basically being that there is surprise

1:58:50.320 --> 1:58:54.520
 and basically emotion is one of the reasons emotions arises,

1:58:54.520 --> 1:58:57.120
 like what happens and what you expect to happen.

1:58:57.120 --> 1:58:59.400
 There is a mismatch between these things.

1:58:59.400 --> 1:59:02.280
 And so that gives rise like I can either be surprised

1:59:02.280 --> 1:59:05.320
 or I can be saddened or I can be happy and all of this.

1:59:05.320 --> 1:59:08.520
 And so this basically indicates that I already

1:59:08.520 --> 1:59:10.120
 have a predictive model in my head

1:59:10.120 --> 1:59:11.880
 and something that I predicted or something

1:59:11.880 --> 1:59:13.640
 that I thought was likely to happen.

1:59:13.640 --> 1:59:16.000
 And then there was something that I observed that happened.

1:59:16.000 --> 1:59:18.200
 There was a disconnect between these two things.

1:59:18.200 --> 1:59:21.840
 And that basically is like maybe one of the reasons

1:59:21.840 --> 1:59:24.240
 I like you have a lot of emotions.

1:59:24.240 --> 1:59:26.840
 Yeah, I think so I talk to people a lot about them

1:59:26.840 --> 1:59:29.080
 like Lisa Feldman Barrett.

1:59:29.080 --> 1:59:31.680
 I think that's an interesting concept of emotion.

1:59:31.680 --> 1:59:36.800
 But I have a sense that emotion primarily

1:59:36.800 --> 1:59:38.280
 in the way we think about it, which

1:59:38.280 --> 1:59:42.640
 is the display of emotion is a communication mechanism

1:59:42.640 --> 1:59:43.840
 between humans.

1:59:43.840 --> 1:59:48.280
 So it's a part of basically human to human interaction.

1:59:48.280 --> 1:59:50.240
 An important part, but just the part.

1:59:50.240 --> 1:59:55.080
 So it's like I would throw it into the full mix

1:59:55.080 --> 1:59:58.080
 of communication.

1:59:58.080 --> 2:00:01.280
 And to me, communication can be done with objects

2:00:01.280 --> 2:00:04.360
 that don't look at all like humans.

2:00:04.360 --> 2:00:05.480
 OK.

2:00:05.480 --> 2:00:07.600
 I've seen our ability to anthropomorphize,

2:00:07.600 --> 2:00:09.120
 our ability to connect with things

2:00:09.120 --> 2:00:12.000
 that look like a Roomba, our ability to connect.

2:00:12.000 --> 2:00:14.720
 First of all, let's talk about other biological systems

2:00:14.720 --> 2:00:18.200
 like dogs, our ability to love things that are very different

2:00:18.200 --> 2:00:19.400
 than humans.

2:00:19.400 --> 2:00:20.960
 But they do display emotion, right?

2:00:20.960 --> 2:00:23.200
 I mean, dogs do display emotion.

2:00:23.200 --> 2:00:25.640
 So they don't have to be anthropomorphic for them

2:00:25.640 --> 2:00:28.240
 to display the kind of emotions that we don't.

2:00:28.240 --> 2:00:28.720
 Exactly.

2:00:28.720 --> 2:00:33.800
 So I mean, but then the word emotion starts to lose.

2:00:33.800 --> 2:00:35.920
 So then we have to be, I guess, specific.

2:00:35.920 --> 2:00:39.400
 But yeah, so have rich, flavorful communication.

2:00:39.400 --> 2:00:40.240
 Communication, yeah.

2:00:40.240 --> 2:00:42.960
 Yeah, so like, yes, it's full of emotion.

2:00:42.960 --> 2:00:50.040
 It's full of wit and humor and moods and all those kinds of things.

2:00:50.040 --> 2:00:53.640
 Yeah, so you're talking about like flavor.

2:00:53.640 --> 2:00:54.480
 Flavor, yeah.

2:00:54.480 --> 2:00:55.400
 OK, let's follow that.

2:00:55.400 --> 2:00:57.200
 So there's content and then there is flavor

2:00:57.200 --> 2:00:58.400
 and I'm talking about the flavor.

2:00:58.400 --> 2:01:00.240
 Do you think it needs to have a body?

2:01:00.240 --> 2:01:02.800
 Do you think like to interact with the physical world,

2:01:02.800 --> 2:01:04.640
 do you think you can understand the physical world

2:01:04.640 --> 2:01:07.040
 without being able to directly interact with it?

2:01:07.040 --> 2:01:08.440
 I don't think so, yeah.

2:01:08.440 --> 2:01:10.680
 I think at some point we will need to bite the bullet

2:01:10.680 --> 2:01:12.680
 and actually interact with the physical world.

2:01:12.680 --> 2:01:15.880
 As much as I like working on like passive computer vision,

2:01:15.880 --> 2:01:18.160
 where I just like sit in my armchair and look at videos

2:01:18.160 --> 2:01:20.840
 and learn, I do think that we will

2:01:20.840 --> 2:01:22.760
 need to have some kind of embodiment

2:01:22.760 --> 2:01:25.040
 or some kind of interaction to figure out

2:01:25.040 --> 2:01:26.960
 things about the world.

2:01:26.960 --> 2:01:28.640
 What about consciousness?

2:01:28.640 --> 2:01:32.320
 Do you think, how often do you think about consciousness

2:01:32.320 --> 2:01:34.400
 when you think about your work?

2:01:34.400 --> 2:01:36.520
 You could think of it as the more simple thing

2:01:36.520 --> 2:01:40.840
 of self awareness, of being aware that you

2:01:40.840 --> 2:01:46.840
 are a perceiving, sensing, acting thing in this world,

2:01:46.840 --> 2:01:50.320
 or you can think about the bigger version of that,

2:01:50.320 --> 2:01:53.800
 which is consciousness, which is having,

2:01:53.800 --> 2:01:57.200
 it feel like something to be that entity,

2:01:57.200 --> 2:01:59.520
 the subjective experience of being in this world.

2:01:59.520 --> 2:02:02.880
 So I think of self awareness a little bit more than the broader

2:02:02.880 --> 2:02:04.920
 goal of it, because I think self awareness

2:02:04.920 --> 2:02:09.360
 is pretty critical for any kind of AGI or whatever you

2:02:09.360 --> 2:02:11.480
 want to call it that we build, because it

2:02:11.480 --> 2:02:15.520
 needs to contextualize what it is and what role it's playing

2:02:15.520 --> 2:02:17.920
 with respect to all the other things that exist around it.

2:02:17.920 --> 2:02:19.640
 I think that requires self awareness.

2:02:19.640 --> 2:02:23.440
 It needs to understand that it's an autonomous car.

2:02:23.440 --> 2:02:24.880
 And what does that mean?

2:02:24.880 --> 2:02:26.200
 What are its limitations?

2:02:26.200 --> 2:02:29.040
 What are the things that it is supposed to do and so on?

2:02:29.040 --> 2:02:30.680
 What is its role in some way?

2:02:30.680 --> 2:02:34.200
 Or, I mean, these are the kind of things

2:02:34.200 --> 2:02:36.840
 that we kind of expect from it, I would say.

2:02:36.840 --> 2:02:39.320
 And so that's the level of self awareness

2:02:39.320 --> 2:02:42.160
 that's, I would say, basically required at least,

2:02:42.160 --> 2:02:44.240
 if not more than that.

2:02:44.240 --> 2:02:46.400
 Yeah, I tend to, on the emotion side,

2:02:46.400 --> 2:02:52.520
 believe that it has to be able to display consciousness.

2:02:52.520 --> 2:02:54.320
 Display consciousness, what do you mean by that?

2:02:54.320 --> 2:02:57.560
 Meaning for us humans to connect with each other

2:02:57.560 --> 2:03:01.640
 or to connect with other living entities,

2:03:01.640 --> 2:03:06.840
 I think in order for us to truly feel

2:03:06.840 --> 2:03:09.360
 like that there's another being there,

2:03:09.360 --> 2:03:11.400
 we have to believe that they're conscious.

2:03:11.400 --> 2:03:14.960
 And so we won't ever connect with something

2:03:14.960 --> 2:03:17.280
 that doesn't have elements of consciousness.

2:03:17.280 --> 2:03:21.520
 Now, I tend to think that that's easier to achieve

2:03:21.520 --> 2:03:26.320
 than it may sound, because we anthropomorphize stuff so hard.

2:03:26.320 --> 2:03:29.880
 You have a mug that just has wheels and rotates

2:03:29.880 --> 2:03:31.840
 every once in a while and makes a sound.

2:03:31.840 --> 2:03:37.880
 I think a couple of days in, especially if you're,

2:03:37.880 --> 2:03:39.480
 if you don't hang out with humans,

2:03:39.480 --> 2:03:42.160
 you might start to believe that mug on wheels is conscious.

2:03:42.160 --> 2:03:43.960
 So I think we anthropomorphize

2:03:43.960 --> 2:03:46.000
 pretty effectively as human beings.

2:03:46.000 --> 2:03:49.200
 But I do think that it's in the same bucket

2:03:49.200 --> 2:03:50.880
 that we'll call emotion,

2:03:50.880 --> 2:03:58.280
 that show that you're, I think of consciousness as the capacity to suffer.

2:03:58.280 --> 2:04:03.520
 And if you're an entity that's able to feel things in the world

2:04:03.520 --> 2:04:06.600
 and to communicate that to others,

2:04:06.600 --> 2:04:10.880
 I think that's a really powerful way to interact with humans.

2:04:10.880 --> 2:04:13.160
 And in order to create an AGI system,

2:04:13.160 --> 2:04:17.920
 I believe you should be able to richly interact with humans.

2:04:17.920 --> 2:04:21.040
 Like humans would need to want to interact with you.

2:04:21.040 --> 2:04:27.800
 Like it can't be like, it's the self supervised learning versus like,

2:04:27.800 --> 2:04:31.320
 the robot shouldn't have to pay you to interact with me.

2:04:31.320 --> 2:04:33.560
 So it should be a natural, fun thing.

2:04:33.560 --> 2:04:36.040
 And then you're going to scale up significantly

2:04:36.040 --> 2:04:39.040
 how much interaction it gets.

2:04:39.040 --> 2:04:40.800
 It's the elect surprise,

2:04:40.800 --> 2:04:44.360
 which they're trying to give me to be a judge on their contest.

2:04:44.360 --> 2:04:45.960
 I'll see if I want to do that.

2:04:45.960 --> 2:04:50.520
 But their challenge is to talk to you,

2:04:50.520 --> 2:04:53.920
 make the human sufficiently interested

2:04:53.920 --> 2:04:56.120
 that the human keeps talking for 20 minutes.

2:04:56.120 --> 2:04:56.800
 To Alexa.

2:04:56.800 --> 2:04:58.560
 To Alexa, yeah.

2:04:58.560 --> 2:05:00.200
 And right now they're not even close to that

2:05:00.200 --> 2:05:02.520
 because it just gets so boring when you're like,

2:05:02.520 --> 2:05:04.240
 when the intelligence is not there,

2:05:04.240 --> 2:05:06.880
 it gets very not interesting to talk to it.

2:05:06.880 --> 2:05:08.920
 And so the robot needs to be interesting.

2:05:08.920 --> 2:05:10.400
 And one of the ways it can be interesting

2:05:10.400 --> 2:05:14.640
 is display the capacity to love, to suffer.

2:05:14.640 --> 2:05:17.480
 And I would say that essentially means

2:05:17.480 --> 2:05:20.920
 the capacity to display consciousness.

2:05:20.920 --> 2:05:25.160
 Like it is an entity, much like a human being.

2:05:25.160 --> 2:05:27.320
 Of course, what that really means,

2:05:27.320 --> 2:05:30.520
 I don't know if that's fundamentally a robotics problem

2:05:30.520 --> 2:05:33.040
 or some kind of problem that we're not yet even aware.

2:05:33.040 --> 2:05:36.040
 Like if it is truly a hard problem of consciousness,

2:05:36.040 --> 2:05:38.560
 I tend to maybe optimistically think it's a,

2:05:40.000 --> 2:05:42.640
 we can pretty effectively fake it till we make it.

2:05:42.640 --> 2:05:46.400
 So we can display a lot of human like elements for a while.

2:05:46.400 --> 2:05:49.080
 And that will be sufficient to form

2:05:49.080 --> 2:05:50.800
 really close connections with humans.

2:05:52.000 --> 2:05:53.720
 What to use the most beautiful idea

2:05:53.720 --> 2:05:55.840
 in self supervised learning?

2:05:55.840 --> 2:05:59.040
 Like when you sit back with, I don't know,

2:05:59.040 --> 2:06:03.200
 with a glass of wine and armchair

2:06:03.200 --> 2:06:06.080
 and just at a fireplace,

2:06:06.080 --> 2:06:08.320
 just thinking how beautiful this world

2:06:08.320 --> 2:06:10.080
 that you get to explore is,

2:06:10.080 --> 2:06:12.840
 what do you think is the especially beautiful idea?

2:06:13.800 --> 2:06:16.480
 The fact that like object level,

2:06:16.480 --> 2:06:19.960
 what objects are in some notion of objectness emerges

2:06:19.960 --> 2:06:23.680
 from these models by just like self supervised learning.

2:06:23.680 --> 2:06:28.680
 So for example, like one of the things like the dyno paper

2:06:28.920 --> 2:06:31.040
 that I was a part of at Facebook is,

2:06:32.160 --> 2:06:34.240
 the object sort of boundaries emerge

2:06:34.240 --> 2:06:35.600
 from these representations.

2:06:35.600 --> 2:06:38.080
 So if you have like a dog running in the field,

2:06:38.080 --> 2:06:39.440
 the boundaries around the dog,

2:06:39.440 --> 2:06:42.320
 the network is basically able to figure out

2:06:42.320 --> 2:06:45.520
 what the boundaries of this dog are automatically.

2:06:45.520 --> 2:06:47.040
 And it was never trained to do that.

2:06:47.040 --> 2:06:49.120
 It was never trained to,

2:06:49.120 --> 2:06:51.000
 no one taught it that this is a dog

2:06:51.000 --> 2:06:52.680
 and these pixels belong to a dog.

2:06:52.680 --> 2:06:55.000
 It's able to group these things together automatically.

2:06:55.000 --> 2:06:56.160
 So that's one.

2:06:56.160 --> 2:06:58.960
 I think in general that entire notion that

2:06:58.960 --> 2:07:01.400
 this dumb idea that you take like these two crops

2:07:01.400 --> 2:07:03.160
 of an image and then you say that the features

2:07:03.160 --> 2:07:04.120
 should be similar,

2:07:04.120 --> 2:07:06.040
 that has resulted in something like this.

2:07:06.040 --> 2:07:07.920
 Like the model is able to figure out

2:07:07.920 --> 2:07:10.320
 what the dog pixels are and so on.

2:07:10.320 --> 2:07:12.040
 That just seems like so surprising.

2:07:13.440 --> 2:07:15.680
 And I mean, I don't think a lot of us even understand

2:07:15.680 --> 2:07:18.120
 how that is happening really.

2:07:18.120 --> 2:07:20.800
 And it's something we are taking for granted,

2:07:20.800 --> 2:07:23.120
 maybe like a lot in terms of how we're setting up

2:07:23.120 --> 2:07:24.320
 these algorithms,

2:07:24.320 --> 2:07:26.800
 but it's just, it's a very beautiful and powerful idea.

2:07:26.800 --> 2:07:28.720
 So it's really fundamentally telling us something

2:07:28.720 --> 2:07:32.440
 about that there is so much signal in the pixels

2:07:32.440 --> 2:07:34.120
 that we can be super dumb about it

2:07:34.120 --> 2:07:36.040
 about how we're setting up the self supervised learning

2:07:36.040 --> 2:07:39.560
 problem and despite being like super dumb about it,

2:07:39.560 --> 2:07:41.600
 we'll actually get very good,

2:07:41.600 --> 2:07:43.960
 like we'll actually get something that is able to do

2:07:43.960 --> 2:07:45.680
 very like surprising things.

2:07:45.680 --> 2:07:48.240
 I wonder if there's other like objectness,

2:07:48.240 --> 2:07:50.320
 other concepts that can emerge.

2:07:51.560 --> 2:07:53.520
 I don't know if you follow Francois Chollet,

2:07:53.520 --> 2:07:56.600
 he had the competition for intelligence

2:07:56.600 --> 2:07:59.520
 that basically it's kind of like an IQ test

2:07:59.520 --> 2:08:01.200
 but for machines.

2:08:01.200 --> 2:08:04.040
 But for an IQ test, you have to have a few concepts

2:08:04.040 --> 2:08:05.360
 that you want to apply.

2:08:05.360 --> 2:08:07.800
 One of them is objectness.

2:08:07.800 --> 2:08:11.520
 I wonder if those concepts can emerge

2:08:11.520 --> 2:08:14.760
 through self supervised learning on billions of images.

2:08:14.760 --> 2:08:16.320
 I think something like object permanence

2:08:16.320 --> 2:08:17.440
 can definitely emerge, right?

2:08:17.440 --> 2:08:20.280
 So that's like a fundamental concept which we have,

2:08:20.280 --> 2:08:21.480
 maybe not through images, through video,

2:08:21.480 --> 2:08:25.160
 but that's another concept that should be emerging from it.

2:08:25.160 --> 2:08:26.760
 Because it's not something that,

2:08:26.760 --> 2:08:29.120
 like we don't teach humans that this isn't,

2:08:29.120 --> 2:08:31.520
 this is like about this concept of object permanence,

2:08:31.520 --> 2:08:32.480
 it actually emerges.

2:08:32.480 --> 2:08:33.640
 And the same thing for like animals,

2:08:33.640 --> 2:08:36.360
 like dogs I think actually permanence automatically

2:08:36.360 --> 2:08:38.120
 is something that they are born with.

2:08:38.120 --> 2:08:40.320
 So I think it should emerge from the data.

2:08:40.320 --> 2:08:42.440
 It should emerge basically very quickly.

2:08:42.440 --> 2:08:45.880
 I wonder if ideas like symmetry, rotation,

2:08:45.880 --> 2:08:47.920
 these kinds of things might emerge.

2:08:47.920 --> 2:08:51.640
 So I think rotation probably, yes, yeah, rotation, yes.

2:08:51.640 --> 2:08:52.680
 I mean, there's some constraints

2:08:52.680 --> 2:08:54.000
 in the architecture itself.

2:08:54.000 --> 2:08:55.200
 Right.

2:08:55.200 --> 2:08:59.240
 But it's interesting if all of them could be,

2:08:59.240 --> 2:09:01.080
 like counting was another one.

2:09:01.080 --> 2:09:04.880
 You know, being able to kind of understand

2:09:04.880 --> 2:09:07.680
 that there's multiple objects of the same kind in the image

2:09:07.680 --> 2:09:08.960
 and be able to count them.

2:09:10.040 --> 2:09:11.560
 I wonder if all of that could be,

2:09:11.560 --> 2:09:14.360
 if constructed correctly, they can emerge.

2:09:14.360 --> 2:09:16.480
 Cause then you can transfer those concepts

2:09:16.480 --> 2:09:20.680
 to then interpret images at a deeper level.

2:09:20.680 --> 2:09:21.480
 Right.

2:09:21.480 --> 2:09:24.680
 Counting I do believe, I mean, should be possible.

2:09:24.680 --> 2:09:25.920
 You don't know like yet,

2:09:25.920 --> 2:09:29.720
 but I do think it's not that far in the realm of possibility.

2:09:29.720 --> 2:09:30.560
 Yeah, that'd be interesting

2:09:30.560 --> 2:09:33.240
 if using self supervised learning on images

2:09:33.240 --> 2:09:36.520
 can then be applied to then solving those kinds of IQ tests,

2:09:36.520 --> 2:09:38.880
 which seem currently to be kind of impossible.

2:09:40.440 --> 2:09:43.320
 What idea do you believe might be true

2:09:43.320 --> 2:09:46.600
 that most people think is not true

2:09:46.600 --> 2:09:48.560
 or don't agree with you on?

2:09:48.560 --> 2:09:50.040
 Is there something like that?

2:09:50.040 --> 2:09:52.400
 So this is going to be a little controversial,

2:09:52.400 --> 2:09:53.520
 but okay, sure.

2:09:53.520 --> 2:09:55.320
 I don't believe in simulation,

2:09:55.320 --> 2:09:58.840
 like actually using simulation to do things very much.

2:09:58.840 --> 2:10:01.080
 I want to clarify, because this is a podcast

2:10:01.080 --> 2:10:03.640
 where you talk about, are we living in a simulation often?

2:10:03.640 --> 2:10:08.040
 You're referring to using simulation to construct worlds

2:10:08.040 --> 2:10:10.360
 that you then leverage for machine learning.

2:10:10.360 --> 2:10:11.200
 Right. Yeah.

2:10:11.200 --> 2:10:14.000
 For example, like one example would be like to train

2:10:14.000 --> 2:10:15.560
 an autonomous car driving system.

2:10:15.560 --> 2:10:17.480
 You basically first build a simulator,

2:10:17.480 --> 2:10:19.880
 which builds like the environment of the world.

2:10:19.880 --> 2:10:22.720
 And then you basically have a lot of like,

2:10:22.720 --> 2:10:25.360
 you train your machine learning system in that.

2:10:25.360 --> 2:10:27.600
 So I believe it is possible,

2:10:27.600 --> 2:10:30.960
 but I think it's a really expensive way of doing things.

2:10:30.960 --> 2:10:33.800
 And at the end of it, you do need the real world.

2:10:33.800 --> 2:10:35.560
 So I'm not sure.

2:10:35.560 --> 2:10:36.960
 So maybe for certain settings,

2:10:36.960 --> 2:10:38.920
 like maybe the payout is so large,

2:10:38.920 --> 2:10:39.920
 like for autonomous driving,

2:10:39.920 --> 2:10:40.920
 the payout is so large

2:10:40.920 --> 2:10:43.400
 that you can actually invest that much money to build it.

2:10:43.400 --> 2:10:45.520
 But I think as a general sort of principle,

2:10:45.520 --> 2:10:47.080
 it does not apply to a lot of concepts.

2:10:47.080 --> 2:10:49.760
 You can't really build simulations of everything,

2:10:49.760 --> 2:10:51.560
 not only because like one, it's expensive,

2:10:51.560 --> 2:10:54.840
 because second, it's also not possible for a lot of things.

2:10:54.840 --> 2:10:58.760
 So in general, like there is a lot of like,

2:10:58.760 --> 2:11:00.800
 there's a lot of work on like using synthetic data

2:11:00.800 --> 2:11:02.120
 and like synthetic simulators.

2:11:02.120 --> 2:11:05.840
 I generally am not very, like I don't believe in that.

2:11:05.840 --> 2:11:09.040
 So you're saying it's very challenging visually,

2:11:09.040 --> 2:11:11.960
 like to correctly like simulate the visual,

2:11:11.960 --> 2:11:13.600
 like the lighting, all those kinds of things.

2:11:13.600 --> 2:11:15.680
 I mean, I mean, all these companies that you have, right?

2:11:15.680 --> 2:11:17.880
 So like Pixar and like whatever,

2:11:17.880 --> 2:11:19.160
 all these companies are,

2:11:19.160 --> 2:11:21.560
 if they're all this like computer graphic stuff

2:11:21.560 --> 2:11:23.920
 is really about accurately a lot of them

2:11:23.920 --> 2:11:25.200
 is about like accurately trying

2:11:25.200 --> 2:11:27.160
 to figure out how the lighting is

2:11:27.160 --> 2:11:30.440
 and like how things reflect off of one another and so on

2:11:30.440 --> 2:11:32.280
 and like how sparkly things look and so on.

2:11:32.280 --> 2:11:34.000
 So it's a very hard problem.

2:11:34.000 --> 2:11:37.200
 So do we really need to solve that first

2:11:37.200 --> 2:11:39.440
 to be able to like do computer vision?

2:11:39.440 --> 2:11:40.640
 Probably not.

2:11:40.640 --> 2:11:44.800
 And for me, in the context of autonomous driving,

2:11:44.800 --> 2:11:48.040
 it's very tempting to be able to use simulation, right?

2:11:48.040 --> 2:11:50.560
 Because it's a safety critical application,

2:11:50.560 --> 2:11:53.360
 but the other limitation of simulation

2:11:53.360 --> 2:11:58.360
 that perhaps is a bigger one than the visual limitation

2:11:58.400 --> 2:12:00.800
 is the behavior of objects.

2:12:00.800 --> 2:12:03.880
 Because so you're ultimately interested in edge cases.

2:12:03.880 --> 2:12:04.960
 And the question is,

2:12:04.960 --> 2:12:08.760
 how well can you generate edge cases in simulation,

2:12:08.760 --> 2:12:11.040
 especially with human behavior?

2:12:11.040 --> 2:12:13.440
 I think another problem is like for autonomous driving, right?

2:12:13.440 --> 2:12:15.240
 It's a constantly changing world.

2:12:15.240 --> 2:12:18.560
 So say autonomous driving like in 10 years from now,

2:12:18.560 --> 2:12:20.800
 like there are lots of autonomous cars,

2:12:20.800 --> 2:12:22.480
 but there's still going to be humans.

2:12:22.480 --> 2:12:24.360
 So now there are 50% of the agents,

2:12:24.360 --> 2:12:25.280
 say which are humans,

2:12:25.280 --> 2:12:26.920
 50% of the agents that are autonomous,

2:12:26.920 --> 2:12:28.640
 like car driving agents.

2:12:28.640 --> 2:12:30.160
 So now the mixture has changed.

2:12:30.160 --> 2:12:31.520
 So now the kinds of behaviors

2:12:31.520 --> 2:12:34.080
 that you actually expect from the other agents

2:12:34.080 --> 2:12:35.240
 or other cars on the road

2:12:35.240 --> 2:12:36.800
 are actually going to be very different.

2:12:36.800 --> 2:12:39.160
 And as the proportion of the number of autonomous cars

2:12:39.160 --> 2:12:40.520
 to humans keeps changing,

2:12:40.520 --> 2:12:42.680
 this behavior will actually change a lot.

2:12:42.680 --> 2:12:44.120
 So now if you were to build a simulator

2:12:44.120 --> 2:12:46.520
 based on just like right now to build them today,

2:12:46.520 --> 2:12:48.480
 you don't have that many autonomous cars on the road.

2:12:48.480 --> 2:12:50.560
 So you'll try to like make all of the other agents

2:12:50.560 --> 2:12:53.000
 in that simulator behave as humans,

2:12:53.000 --> 2:12:54.680
 but that's not really going to hold true

2:12:54.680 --> 2:12:57.400
 10, 15, 20, 30 years from now.

2:12:57.400 --> 2:12:59.320
 Do you think we're living in a simulation?

2:12:59.320 --> 2:13:00.160
 No.

2:13:01.520 --> 2:13:02.840
 How hard is it?

2:13:02.840 --> 2:13:04.880
 This is why I think it's an interesting question.

2:13:04.880 --> 2:13:07.800
 How hard is it to build a video game,

2:13:07.800 --> 2:13:09.560
 like virtual reality game,

2:13:09.560 --> 2:13:11.880
 where it is so real,

2:13:12.680 --> 2:13:15.240
 forget like ultra realistic

2:13:15.240 --> 2:13:17.400
 to where you can't tell the difference,

2:13:17.400 --> 2:13:20.880
 but like it's so nice that you just want to stay there.

2:13:20.880 --> 2:13:22.960
 You just want to stay there

2:13:22.960 --> 2:13:24.960
 and you don't want to come back.

2:13:24.960 --> 2:13:29.400
 Do you think that's doable within our lifetime?

2:13:29.400 --> 2:13:31.680
 Within our lifetime, probably.

2:13:31.680 --> 2:13:32.520
 Yeah.

2:13:32.520 --> 2:13:33.920
 How you tell they are live long.

2:13:33.920 --> 2:13:35.760
 Ha ha ha ha.

2:13:35.760 --> 2:13:37.240
 Does that make you sad

2:13:37.240 --> 2:13:42.000
 that there will be like population of kids

2:13:42.000 --> 2:13:45.920
 that basically spend 95%, 99% of their time

2:13:45.920 --> 2:13:47.560
 in a virtual world?

2:13:50.120 --> 2:13:52.120
 Very, very hard question to answer.

2:13:53.400 --> 2:13:55.760
 For certain people, it might be something

2:13:55.760 --> 2:13:58.160
 that they really derive a lot of value out of,

2:13:58.160 --> 2:14:00.760
 derive a lot of enjoyment and like happiness out of,

2:14:00.760 --> 2:14:03.120
 and maybe the real world wasn't giving them that,

2:14:03.120 --> 2:14:03.960
 that's why they did that.

2:14:03.960 --> 2:14:06.000
 So maybe it is good for certain people.

2:14:06.000 --> 2:14:09.400
 So ultimately, if it maximizes happiness,

2:14:09.400 --> 2:14:10.760
 or we could judge.

2:14:10.760 --> 2:14:12.760
 Yeah, I think if it's making people happy,

2:14:12.760 --> 2:14:14.440
 maybe it's okay.

2:14:14.440 --> 2:14:16.720
 Again, I think this is a very hard question.

2:14:18.320 --> 2:14:22.600
 So like you've been a part of a lot of amazing papers.

2:14:23.520 --> 2:14:25.640
 What advice would you give to somebody

2:14:25.640 --> 2:14:28.040
 on what it takes to write a good paper?

2:14:29.200 --> 2:14:31.000
 Grad students writing papers now,

2:14:31.000 --> 2:14:34.560
 is there common things that you've learned along the way

2:14:34.560 --> 2:14:35.760
 that you think it takes,

2:14:35.760 --> 2:14:39.000
 both for a good idea and a good paper?

2:14:39.920 --> 2:14:42.840
 Right, so I think both of these

2:14:42.840 --> 2:14:45.440
 I've picked up from like lots of people

2:14:45.440 --> 2:14:46.560
 I've worked with in the past.

2:14:46.560 --> 2:14:48.680
 So one of them is picking the right problem

2:14:48.680 --> 2:14:51.040
 to work on in research is as important

2:14:51.040 --> 2:14:53.680
 as like finding the solution to it.

2:14:53.680 --> 2:14:56.200
 So I mean, there are multiple reasons for this.

2:14:56.200 --> 2:14:58.960
 So one is that there are certain problems

2:14:58.960 --> 2:15:02.360
 that can actually be solved in a particular timeframe.

2:15:02.360 --> 2:15:06.400
 So now say you want to work on finding the meaning of life.

2:15:06.400 --> 2:15:07.400
 This is a great problem.

2:15:07.400 --> 2:15:09.440
 I think most people will agree with that.

2:15:09.440 --> 2:15:12.240
 But do you believe that your talents

2:15:12.240 --> 2:15:13.840
 and like the energy that you'll spend on it

2:15:13.840 --> 2:15:17.280
 will make some kind of meaningful progress

2:15:17.280 --> 2:15:18.840
 in your lifetime?

2:15:18.840 --> 2:15:21.040
 If you are optimistic about it, then like go ahead.

2:15:21.040 --> 2:15:22.120
 That's why I started this podcast.

2:15:22.120 --> 2:15:24.080
 I keep asking people about the meaning of life.

2:15:24.080 --> 2:15:27.480
 I'm hoping by episode like 220, I'll figure it out.

2:15:27.480 --> 2:15:30.360
 Oh, not too many episodes to go then.

2:15:30.360 --> 2:15:33.080
 All right, maybe today, I don't know.

2:15:33.080 --> 2:15:33.920
 But you're right.

2:15:33.920 --> 2:15:36.280
 So that seems intractable at the moment.

2:15:36.280 --> 2:15:38.560
 Right, so I think it's just the fact of

2:15:38.560 --> 2:15:41.080
 like if you're starting a PhD for example,

2:15:41.080 --> 2:15:43.000
 what is one problem that you want to focus on

2:15:43.000 --> 2:15:45.720
 that you do think is interesting enough

2:15:45.720 --> 2:15:47.800
 and you will be able to make a reasonable amount

2:15:47.800 --> 2:15:50.520
 of headway into it that you think you'll be doing a PhD for.

2:15:50.520 --> 2:15:53.080
 So in that kind of a timeframe.

2:15:53.080 --> 2:15:53.920
 So that's one.

2:15:53.920 --> 2:15:54.760
 Of course, there's the second part

2:15:54.760 --> 2:15:56.360
 which is what excites you genuinely.

2:15:56.360 --> 2:15:57.600
 So you shouldn't just pick problems

2:15:57.600 --> 2:15:59.040
 that you are not excited about

2:15:59.040 --> 2:16:01.840
 because as a grad student or as a researcher,

2:16:01.840 --> 2:16:03.200
 you really need to be passionate about it

2:16:03.200 --> 2:16:04.600
 to continue doing that

2:16:04.600 --> 2:16:05.760
 because there are so many other things

2:16:05.760 --> 2:16:07.080
 that you could be doing in life.

2:16:07.080 --> 2:16:08.280
 So you really need to believe in that

2:16:08.280 --> 2:16:10.760
 to be able to do that for that long.

2:16:10.760 --> 2:16:11.600
 In terms of papers,

2:16:11.600 --> 2:16:13.480
 I think the one thing that I've learned is

2:16:14.920 --> 2:16:16.440
 I've like in the past,

2:16:16.440 --> 2:16:17.760
 whenever I used to write things

2:16:17.760 --> 2:16:18.920
 and even now whenever I do that,

2:16:18.920 --> 2:16:21.400
 I try to cram in a lot of things into the paper.

2:16:21.400 --> 2:16:23.840
 Whereas what really matters is just pushing

2:16:23.840 --> 2:16:25.760
 one simple idea, that's it.

2:16:25.760 --> 2:16:28.480
 That's all because that's,

2:16:28.480 --> 2:16:30.320
 the paper is going to be like whatever,

2:16:30.320 --> 2:16:32.200
 eight or nine pages.

2:16:32.200 --> 2:16:34.240
 If you keep cramming in lots of ideas,

2:16:34.240 --> 2:16:36.240
 it's really hard for the single thing

2:16:36.240 --> 2:16:38.000
 that you believe in to stand out.

2:16:38.000 --> 2:16:40.400
 So if you really try to just focus

2:16:40.400 --> 2:16:41.920
 on like especially in terms of writing,

2:16:41.920 --> 2:16:43.840
 really try to focus on one particular idea

2:16:43.840 --> 2:16:46.240
 and articulate it out in multiple different ways.

2:16:46.240 --> 2:16:49.040
 It's far more valuable to the reader as well.

2:16:49.040 --> 2:16:51.600
 And basically to the reader, of course,

2:16:51.600 --> 2:16:53.120
 because they get to,

2:16:53.120 --> 2:16:54.400
 they know that this particular idea

2:16:54.400 --> 2:16:56.160
 is associated with this paper.

2:16:56.160 --> 2:16:59.040
 And also for you because you have,

2:16:59.040 --> 2:17:00.440
 like when you write about a particular idea

2:17:00.440 --> 2:17:02.680
 in different ways, you think about it more deeply.

2:17:02.680 --> 2:17:03.600
 So as a grad student,

2:17:03.600 --> 2:17:07.200
 I used to always wait toward like maybe in the last week

2:17:07.200 --> 2:17:08.680
 or whatever to write the paper

2:17:08.680 --> 2:17:11.320
 because I used to always believe that doing the experiments

2:17:11.320 --> 2:17:13.840
 was actually the bigger part of research than writing.

2:17:13.840 --> 2:17:15.200
 And my advisor always told me

2:17:15.200 --> 2:17:16.600
 that you should start writing very early on.

2:17:16.600 --> 2:17:17.840
 And I thought, oh, it doesn't matter.

2:17:17.840 --> 2:17:19.640
 I don't know what he's talking about.

2:17:19.640 --> 2:17:21.760
 But I think more and more I realized that's the case.

2:17:21.760 --> 2:17:24.000
 Like whenever I write something that I'm doing,

2:17:24.000 --> 2:17:26.400
 I actually think much better about it.

2:17:26.400 --> 2:17:28.800
 And so if you start writing early on,

2:17:28.800 --> 2:17:31.160
 you actually, I think get better ideas

2:17:31.160 --> 2:17:33.760
 or at least you figure out like holes in your theory

2:17:33.760 --> 2:17:35.440
 or like particular experiments

2:17:35.440 --> 2:17:38.680
 that you should run to block those holes and so on.

2:17:38.680 --> 2:17:40.320
 Yeah, I'm continually surprised

2:17:40.320 --> 2:17:43.560
 how many really good papers throughout history

2:17:43.560 --> 2:17:47.360
 are quite short and quite simple.

2:17:48.280 --> 2:17:49.800
 And there's a lesson to that.

2:17:49.800 --> 2:17:52.600
 Like if you want to dream about writing a paper

2:17:52.600 --> 2:17:56.760
 that changes the world and you want to go by example,

2:17:56.760 --> 2:18:01.280
 they're usually simple and that it's not cramming

2:18:01.280 --> 2:18:06.280
 or it's focusing on one idea and thinking deeply

2:18:07.240 --> 2:18:10.360
 and you're right that the writing process itself

2:18:10.360 --> 2:18:12.280
 reveals the idea.

2:18:12.280 --> 2:18:15.320
 It challenges you to really think about what is the idea

2:18:15.320 --> 2:18:18.040
 that explains that the thread that ties it all together.

2:18:19.040 --> 2:18:21.560
 And so like a lot of famous researchers I know

2:18:21.560 --> 2:18:24.120
 actually would start off like,

2:18:24.120 --> 2:18:27.240
 first they were even before the experiments were in,

2:18:27.240 --> 2:18:28.360
 a lot of them would actually start

2:18:28.360 --> 2:18:30.400
 with writing the introduction of the paper

2:18:30.400 --> 2:18:32.160
 with zero experiments in.

2:18:32.160 --> 2:18:33.800
 Because that at least helps them figure out

2:18:33.800 --> 2:18:35.800
 what they're trying to solve

2:18:35.800 --> 2:18:38.640
 and how it fits in like the context of things right now.

2:18:38.640 --> 2:18:40.720
 And that would really guide their entire research.

2:18:40.720 --> 2:18:42.360
 So a lot of them would actually first write in intros

2:18:42.360 --> 2:18:43.560
 with like zero experiments in

2:18:43.560 --> 2:18:46.040
 and that's how they would start projects.

2:18:46.040 --> 2:18:48.240
 Some basic questions about people maybe

2:18:49.800 --> 2:18:51.960
 there are more like beginners in this field.

2:18:51.960 --> 2:18:54.080
 What's the best programming language to learn

2:18:54.080 --> 2:18:56.600
 if you're interested in machine learning?

2:18:56.600 --> 2:19:00.320
 I would say Python just because it's the easiest one to learn.

2:19:00.320 --> 2:19:03.160
 And also a lot of like programming

2:19:03.160 --> 2:19:05.000
 in machine learning happens in Python.

2:19:05.000 --> 2:19:07.600
 So it'll, if you don't know any other programming language

2:19:07.600 --> 2:19:09.560
 Python is actually going to get you a long way.

2:19:09.560 --> 2:19:12.800
 Yeah, it seems like sort of a, it's a toss up question

2:19:12.800 --> 2:19:15.160
 because it seems like Python is so much dominating

2:19:15.160 --> 2:19:18.040
 the space now, but I wonder if there's interesting

2:19:18.040 --> 2:19:19.960
 alternative, obviously there's like Swift

2:19:19.960 --> 2:19:22.720
 and there's a lot of interesting alternatives popping up

2:19:22.720 --> 2:19:27.720
 even JavaScript or R, more like for the data science

2:19:27.720 --> 2:19:31.240
 applications, but it seems like Python more and more

2:19:31.240 --> 2:19:34.160
 is actually being used to teach like introduction

2:19:34.160 --> 2:19:35.880
 to programming at universities.

2:19:35.880 --> 2:19:38.320
 So it just combines everything very nicely.

2:19:39.840 --> 2:19:41.840
 Even harder question.

2:19:41.840 --> 2:19:46.120
 What are the pros and cons of PyTorch versus TensorFlow?

2:19:46.120 --> 2:19:46.960
 I see.

2:19:48.400 --> 2:19:49.360
 Okay, so.

2:19:49.360 --> 2:19:51.320
 You can go with no comment.

2:19:51.320 --> 2:19:53.400
 So a disclaimer to this is that the last time

2:19:53.400 --> 2:19:56.400
 I used TensorFlow was probably like four years ago.

2:19:56.400 --> 2:19:58.160
 And so it was right when it had come out

2:19:58.160 --> 2:20:02.640
 because so I started on like deep learning in 2014 or so

2:20:02.640 --> 2:20:06.440
 and the dominant sort of pattern framework for us then

2:20:06.440 --> 2:20:09.040
 for vision was Cafe, which was out of Berkeley

2:20:09.040 --> 2:20:11.200
 and we used Cafe a lot, it was really nice.

2:20:12.120 --> 2:20:14.080
 And then TensorFlow came in, which was basically

2:20:14.080 --> 2:20:15.080
 like Python first.

2:20:15.080 --> 2:20:18.080
 So Cafe was mainly C++ and it had like very loose

2:20:18.080 --> 2:20:19.040
 kind of Python binding.

2:20:19.040 --> 2:20:21.360
 So Python wasn't really the first language you would use.

2:20:21.360 --> 2:20:24.680
 You would really use either MATLAB or C++

2:20:24.680 --> 2:20:28.240
 like get stuff done in like Cafe.

2:20:28.240 --> 2:20:30.920
 And then Python of course became popular a little bit later.

2:20:30.920 --> 2:20:32.600
 So TensorFlow was basically around that time.

2:20:32.600 --> 2:20:35.240
 So 2015, 2016 is when I last used it.

2:20:36.120 --> 2:20:37.200
 It's been a while.

2:20:37.200 --> 2:20:40.600
 And then what, did you use Torch or did you?

2:20:40.600 --> 2:20:44.000
 So then I moved to Lua Torch, which was the Torch in Lua.

2:20:44.000 --> 2:20:46.760
 And then in 2017, I think basically pretty much

2:20:46.760 --> 2:20:48.400
 to PyTorch completely.

2:20:48.400 --> 2:20:49.240
 Oh, interesting.

2:20:49.240 --> 2:20:50.520
 So you went to Lua, cool.

2:20:50.520 --> 2:20:51.440
 Yeah.

2:20:51.440 --> 2:20:54.160
 Huh, so you were there before it was cool.

2:20:54.160 --> 2:20:56.320
 Yeah, I mean, so Lua Torch was really good

2:20:56.320 --> 2:20:59.520
 because it actually allowed you to do a lot

2:20:59.520 --> 2:21:01.360
 of different kinds of things.

2:21:01.360 --> 2:21:03.880
 So which Cafe was very rigid in terms of its structure.

2:21:03.880 --> 2:21:06.800
 Like you would create a neural network once and that's it.

2:21:06.800 --> 2:21:09.320
 Whereas if you wanted like very dynamic graphs and so on,

2:21:09.320 --> 2:21:10.200
 it was very hard to do that.

2:21:10.200 --> 2:21:11.600
 And Lua Torch was much more friendly

2:21:11.600 --> 2:21:13.560
 for all of these things.

2:21:13.560 --> 2:21:15.600
 Okay, so in terms of PyTorch and TensorFlow,

2:21:15.600 --> 2:21:18.480
 my personal bias is PyTorch just because I've been using it

2:21:18.480 --> 2:21:20.760
 longer and I'm more familiar with it.

2:21:20.760 --> 2:21:23.560
 And also that PyTorch is much easier to debug

2:21:23.560 --> 2:21:26.320
 is what I find because it's imperative in nature

2:21:26.320 --> 2:21:28.680
 compared to like TensorFlow, which is not imperative.

2:21:28.680 --> 2:21:30.520
 But that's telling you a lot that basically

2:21:30.520 --> 2:21:33.920
 the imperative design is sort of a way in which a lot

2:21:33.920 --> 2:21:35.280
 of people are taught programming

2:21:35.280 --> 2:21:38.200
 and that's what actually makes debugging easier for them.

2:21:38.200 --> 2:21:40.520
 So like I learned programming in C++.

2:21:40.520 --> 2:21:42.240
 And so for me, imperative way of programming

2:21:42.240 --> 2:21:44.080
 is more natural.

2:21:44.080 --> 2:21:46.720
 Do you think it's good to have kind of these two communities,

2:21:46.720 --> 2:21:48.520
 this kind of competition?

2:21:48.520 --> 2:21:51.520
 I think PyTorch is kind of more and more becoming dominant

2:21:51.520 --> 2:21:52.560
 in the research community,

2:21:52.560 --> 2:21:54.600
 but TensorFlow is still very popular

2:21:54.600 --> 2:21:57.920
 in the more sort of application machine learning community.

2:21:57.920 --> 2:22:00.480
 So do you think it's good to have that kind of split

2:22:00.480 --> 2:22:04.880
 in code bases or, so like the benefit there

2:22:04.880 --> 2:22:07.800
 is the competition challenges the library developers

2:22:07.800 --> 2:22:10.000
 to step up their game.

2:22:10.000 --> 2:22:12.760
 But the downside is there's these code bases

2:22:12.760 --> 2:22:15.200
 that are in different libraries.

2:22:15.200 --> 2:22:17.080
 Right, so I think the downside is there.

2:22:17.080 --> 2:22:18.480
 I mean, for a lot of research code

2:22:18.480 --> 2:22:19.640
 that's released in one framework

2:22:19.640 --> 2:22:21.600
 and if you're using the other one, it's really hard

2:22:21.600 --> 2:22:23.920
 to like really build on top of it.

2:22:23.920 --> 2:22:25.800
 But thankfully the open source community

2:22:25.800 --> 2:22:27.080
 in machine learning is amazing.

2:22:27.080 --> 2:22:30.840
 So whenever like something pops up in TensorFlow,

2:22:30.840 --> 2:22:33.200
 you wait a few days and someone who's like super sharp

2:22:33.200 --> 2:22:35.360
 will actually come and translate that particular code

2:22:35.360 --> 2:22:38.160
 based into PyTorch and basically have figured

2:22:38.160 --> 2:22:39.720
 that all those nooks and crannies out.

2:22:39.720 --> 2:22:41.800
 So the open source community is amazing

2:22:41.800 --> 2:22:44.280
 and they really like figure out this gap.

2:22:45.240 --> 2:22:47.560
 So I think in terms of like having these two frameworks

2:22:47.560 --> 2:22:49.720
 or multiple, I think of course there are different use cases

2:22:49.720 --> 2:22:51.600
 so there are going to be benefits to using one

2:22:51.600 --> 2:22:52.880
 or the other framework.

2:22:52.880 --> 2:22:54.760
 And like you said, I think competition is just healthy

2:22:54.760 --> 2:22:57.400
 because both of these frameworks keep

2:22:57.400 --> 2:22:59.600
 or like all of these frameworks really sort of keep learning

2:22:59.600 --> 2:23:01.680
 from each other and keep incorporating different things

2:23:01.680 --> 2:23:03.800
 to just make them better and better.

2:23:03.800 --> 2:23:06.360
 What advice would you have for someone

2:23:06.360 --> 2:23:07.760
 new to machine learning?

2:23:09.720 --> 2:23:11.560
 Maybe just started or haven't even started

2:23:11.560 --> 2:23:14.920
 but are curious about it and who want to get in the field.

2:23:14.920 --> 2:23:16.640
 Don't be afraid to get your hands dirty.

2:23:16.640 --> 2:23:17.640
 I think that's the main thing.

2:23:17.640 --> 2:23:20.160
 So if something doesn't work, like really drill

2:23:20.160 --> 2:23:22.200
 into why things are not working.

2:23:22.200 --> 2:23:24.520
 Can you elaborate what your hands dirty means?

2:23:24.520 --> 2:23:27.560
 Right, so for example, like if an algorithm,

2:23:27.560 --> 2:23:29.720
 if you try to train a network and it's not converging,

2:23:29.720 --> 2:23:32.240
 whatever, rather than trying to like Google the answer

2:23:32.240 --> 2:23:34.360
 or trying to do something, like really spend those

2:23:34.360 --> 2:23:37.200
 like five, eight, 10, 15, 20, whatever number of hours

2:23:37.200 --> 2:23:39.000
 really trying to figure it out yourself.

2:23:39.000 --> 2:23:42.520
 Because in that process, you'll actually learn a lot more.

2:23:42.520 --> 2:23:44.600
 Googling is of course like a good way to solve it

2:23:44.600 --> 2:23:45.960
 when you need a quick answer.

2:23:45.960 --> 2:23:48.280
 But I think initially especially like when you're starting out

2:23:48.280 --> 2:23:51.840
 it's much nicer to like figure things out by yourself.

2:23:51.840 --> 2:23:52.960
 And I just say that from experience

2:23:52.960 --> 2:23:54.280
 because like when I started out,

2:23:54.280 --> 2:23:55.480
 there were not a lot of resources.

2:23:55.480 --> 2:23:57.880
 So we would like in the lab a lot of us

2:23:57.880 --> 2:23:59.680
 like we would look up to senior students

2:23:59.680 --> 2:24:01.360
 and the senior students were of course busy

2:24:01.360 --> 2:24:03.080
 and they would be like, hey, why don't you go figure it out

2:24:03.080 --> 2:24:04.320
 because I just don't have the time

2:24:04.320 --> 2:24:06.480
 I'm working on my dissertation or whatever.

2:24:06.480 --> 2:24:07.640
 I'll find a PhD students.

2:24:07.640 --> 2:24:08.760
 And so then we would sit down

2:24:08.760 --> 2:24:10.480
 and like just try to figure it out.

2:24:10.480 --> 2:24:12.440
 And that I think really helped me.

2:24:12.440 --> 2:24:15.080
 That has really helped me figure a lot of things out.

2:24:15.080 --> 2:24:18.720
 I think in general, if I were to generalize that,

2:24:18.720 --> 2:24:22.720
 I feel like persevering through any kind of struggle

2:24:22.720 --> 2:24:25.680
 on a thing you care about is good.

2:24:25.680 --> 2:24:28.160
 So you're basically, you try to make it seem like

2:24:28.160 --> 2:24:30.840
 it's good to spend time debugging

2:24:30.840 --> 2:24:33.680
 but really any kind of struggle, whatever form that takes

2:24:33.680 --> 2:24:36.080
 it could be just Googling a lot.

2:24:36.080 --> 2:24:38.760
 Just basically anything just sticking with it

2:24:38.760 --> 2:24:39.960
 and going through the hard thing

2:24:39.960 --> 2:24:43.240
 that could take a form of implementing stuff from scratch.

2:24:43.240 --> 2:24:45.640
 It could take the form of re implementing

2:24:45.640 --> 2:24:49.360
 with different libraries or different programming languages.

2:24:49.360 --> 2:24:50.600
 It could take a lot of different forms

2:24:50.600 --> 2:24:53.560
 but struggle is good for the soul.

2:24:53.560 --> 2:24:55.840
 So like in Pittsburgh, where I did my PhD,

2:24:55.840 --> 2:24:58.400
 the thing was it used to snow a lot, right?

2:24:58.400 --> 2:25:00.840
 And so when it was snowed, you really couldn't do much.

2:25:00.840 --> 2:25:03.720
 So the thing that a lot of people said was snow

2:25:03.720 --> 2:25:06.200
 builds character because when it's snowing,

2:25:06.200 --> 2:25:07.520
 you can't do anything else.

2:25:07.520 --> 2:25:09.080
 You focus on work.

2:25:09.080 --> 2:25:10.840
 Do you have advice in general for people

2:25:10.840 --> 2:25:13.440
 you've already exceptionally successful, you're young

2:25:13.440 --> 2:25:15.800
 but do you have advice for young people starting out

2:25:15.800 --> 2:25:18.160
 in college or maybe in high school?

2:25:18.160 --> 2:25:21.040
 Advice for their career, advice for their life,

2:25:21.040 --> 2:25:25.680
 how to pave a successful path in career and life.

2:25:25.680 --> 2:25:27.360
 I would say just be hungry,

2:25:27.360 --> 2:25:29.720
 like always be hungry for what you want.

2:25:29.720 --> 2:25:33.320
 And I think like I've been inspired by a lot of people

2:25:33.320 --> 2:25:35.800
 who are just like driven and who really like go

2:25:35.800 --> 2:25:38.440
 for what they want, no matter what like,

2:25:38.440 --> 2:25:40.520
 you shouldn't want it, you should need it.

2:25:40.520 --> 2:25:42.920
 So if you need something, you basically go towards

2:25:42.920 --> 2:25:44.360
 the ends to make it work.

2:25:44.360 --> 2:25:47.840
 How do you know when you come across a thing

2:25:47.840 --> 2:25:51.040
 that's like you need?

2:25:51.040 --> 2:25:53.080
 I think there's not going to be any single thing

2:25:53.080 --> 2:25:54.120
 that you're going to need, there are going to be

2:25:54.120 --> 2:25:55.360
 different types of things that you need,

2:25:55.360 --> 2:25:57.920
 but whenever you need something, you just go push for it.

2:25:57.920 --> 2:26:00.080
 And of course, once you may not get it

2:26:00.080 --> 2:26:01.960
 or you may find that this was not even the thing

2:26:01.960 --> 2:26:03.640
 that you were looking for, it might be a different thing.

2:26:03.640 --> 2:26:06.240
 But the point is like you're pushing through things

2:26:06.240 --> 2:26:08.960
 and that actually brings a lot of skills

2:26:08.960 --> 2:26:12.880
 and brings a lot of like build a certain kind of attitude

2:26:12.880 --> 2:26:15.680
 which will probably help you get the other thing.

2:26:15.680 --> 2:26:18.080
 Once you figure out what's really the thing that you want.

2:26:18.080 --> 2:26:20.520
 Yeah, I think a lot of people are,

2:26:20.520 --> 2:26:22.520
 I've noticed the kind of afraid of that

2:26:22.520 --> 2:26:24.880
 is because one, it's a fear of commitment.

2:26:24.880 --> 2:26:26.880
 And two, there's so many amazing things in this world.

2:26:26.880 --> 2:26:28.800
 You almost don't want to miss out on all the other

2:26:28.800 --> 2:26:31.080
 amazing things by committing to this one thing.

2:26:31.080 --> 2:26:33.840
 So I think a lot of it has to do with just allowing yourself

2:26:33.840 --> 2:26:37.960
 to like notice that thing.

2:26:37.960 --> 2:26:41.600
 And just go all the way with it.

2:26:41.600 --> 2:26:43.280
 I mean, also like failure, right?

2:26:43.280 --> 2:26:47.960
 So I know this is like super cheesy that failure is something

2:26:47.960 --> 2:26:49.800
 that you should be prepared for and so on.

2:26:49.800 --> 2:26:52.560
 But I do think, I mean, especially in research,

2:26:52.560 --> 2:26:54.800
 for example, failure is something that happens almost

2:26:54.800 --> 2:26:58.200
 like almost every day is like experiments failing

2:26:58.200 --> 2:26:59.160
 and not working.

2:26:59.160 --> 2:27:02.320
 And so you really need to be so used to it.

2:27:02.320 --> 2:27:03.920
 You need to have a thick skin.

2:27:03.920 --> 2:27:07.320
 But and only basically through, like when you get through it

2:27:07.320 --> 2:27:09.640
 is when you find the one thing that's actually working.

2:27:09.640 --> 2:27:11.880
 Like Thomas Edison was like one person like that, right?

2:27:11.880 --> 2:27:13.760
 So I really, like when I was a kid,

2:27:13.760 --> 2:27:17.200
 I used to really read about how he found like the filament,

2:27:17.200 --> 2:27:18.760
 the light bulb filament.

2:27:18.760 --> 2:27:20.680
 And then I think his thing was like,

2:27:20.680 --> 2:27:24.400
 he tried 990 things that didn't work or something of the sort.

2:27:24.400 --> 2:27:26.960
 And then they asked him like, so what did you learn?

2:27:26.960 --> 2:27:28.520
 Because all of these were failed experiments.

2:27:28.520 --> 2:27:31.640
 And then he says, oh, these 990 things don't work.

2:27:31.640 --> 2:27:32.240
 And I know that.

2:27:32.240 --> 2:27:34.120
 Did you know that?

2:27:34.120 --> 2:27:36.000
 I mean, that's really inspiring.

2:27:36.000 --> 2:27:38.440
 So you spent a few years on this earth

2:27:38.440 --> 2:27:44.000
 performing a self supervised kind of learning process.

2:27:44.000 --> 2:27:46.440
 Have you figured out the meaning of life yet?

2:27:46.440 --> 2:27:49.240
 I told you I'm doing this podcast to try to get the answer.

2:27:49.240 --> 2:27:50.760
 I'm hoping you could tell me.

2:27:50.760 --> 2:27:54.400
 What do you think the meaning of it all is?

2:27:54.400 --> 2:27:55.840
 I don't think I figured this out.

2:27:55.840 --> 2:27:59.000
 No, I have no idea.

2:27:59.000 --> 2:28:02.400
 Do you think AI will help us figure it out?

2:28:02.400 --> 2:28:03.920
 Or do you think there's no answer?

2:28:03.920 --> 2:28:05.520
 The whole point is to keep searching.

2:28:05.520 --> 2:28:08.840
 I think it's an endless sort of quest for us.

2:28:08.840 --> 2:28:10.600
 I don't think AI will help us there.

2:28:10.600 --> 2:28:13.600
 This is like a very hard, hard, hard question

2:28:13.600 --> 2:28:15.440
 which so many humans have tried to answer.

2:28:15.440 --> 2:28:17.440
 Well, that's the interesting thing about the difference

2:28:17.440 --> 2:28:19.560
 between AI and humans.

2:28:19.560 --> 2:28:21.880
 Humans don't seem to know what the hell they're doing.

2:28:21.880 --> 2:28:23.760
 And AI is almost always operating

2:28:23.760 --> 2:28:28.400
 under well defined objective functions.

2:28:28.400 --> 2:28:34.880
 And I wonder whether there are a lack of ability

2:28:34.880 --> 2:28:37.240
 to define good long term objective functions

2:28:37.240 --> 2:28:40.840
 or in retrospect, what is the objective function under which

2:28:40.840 --> 2:28:44.160
 we operate if that's a feature or a bug?

2:28:44.160 --> 2:28:46.480
 I would say it's a feature because then everyone actually

2:28:46.480 --> 2:28:48.440
 has very different kinds of objective functions

2:28:48.440 --> 2:28:49.400
 that they're optimizing.

2:28:49.400 --> 2:28:52.480
 And those objective functions evolve and change dramatically

2:28:52.480 --> 2:28:53.880
 through their course of their life.

2:28:53.880 --> 2:28:56.040
 That's actually what makes us interesting, right?

2:28:56.040 --> 2:28:59.120
 If otherwise, if everyone was doing the exact same thing,

2:28:59.120 --> 2:29:00.560
 that would be pretty boring.

2:29:00.560 --> 2:29:03.880
 We do want people with different kinds of perspectives.

2:29:03.880 --> 2:29:06.160
 Also, people evolve continuously.

2:29:06.160 --> 2:29:08.040
 That's like, I would say, the biggest

2:29:08.040 --> 2:29:09.320
 feature of being human.

2:29:09.320 --> 2:29:11.160
 And then we get to the ones that die

2:29:11.160 --> 2:29:12.560
 because they do something stupid.

2:29:12.560 --> 2:29:15.440
 We get to watch that, see it, and learn from it.

2:29:15.440 --> 2:29:20.400
 And as a species, we take that lesson

2:29:20.400 --> 2:29:23.880
 and become better and better because of all the dumb people

2:29:23.880 --> 2:29:29.080
 in the world that died doing something wild and beautiful.

2:29:29.080 --> 2:29:31.840
 Ishan, thank you so much for this incredible conversation.

2:29:31.840 --> 2:29:37.480
 We did a depth first search through the space of machine

2:29:37.480 --> 2:29:38.000
 learning.

2:29:38.000 --> 2:29:41.600
 And it was fun and fascinating.

2:29:41.600 --> 2:29:43.920
 So it's really an honor to meet you.

2:29:43.920 --> 2:29:45.720
 And it was a really awesome conversation.

2:29:45.720 --> 2:29:48.160
 Thanks for coming down today and talking with me.

2:29:48.160 --> 2:29:49.000
 Thanks, Lexi.

2:29:49.000 --> 2:29:50.200
 I mean, I've listened to you.

2:29:50.200 --> 2:29:52.960
 I told you it was unreal for me to actually meet you in person.

2:29:52.960 --> 2:29:54.080
 And I'm so happy to be here.

2:29:54.080 --> 2:29:55.000
 Thank you.

2:29:55.000 --> 2:29:56.680
 Thanks, man.

2:29:56.680 --> 2:29:59.360
 Thanks for listening to this conversation with Ishan Mizra.

2:29:59.360 --> 2:30:03.280
 And thank you to Anit, The Information, Grammarly,

2:30:03.280 --> 2:30:05.280
 and Athletic Greens.

2:30:05.280 --> 2:30:08.560
 Check them out in the description to support this podcast.

2:30:08.560 --> 2:30:12.480
 And now let me leave you with some words from Arthur C. Clark.

2:30:12.480 --> 2:30:14.920
 Any sufficiently advanced technology

2:30:14.920 --> 2:30:18.120
 is indistinguishable from magic.

2:30:18.120 --> 2:30:30.080
 Thank you for listening and hope to see you next time.

