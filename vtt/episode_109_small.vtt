WEBVTT

00:00.000 --> 00:07.500
 The following is a conversation with Brian Kernigan, a professor of computer science at Princeton University.

00:07.500 --> 00:16.200
 He was a key figure in the computer science community in the early Unix days alongside Unix creators Ken Thompson and Dennis Ritchie.

00:16.200 --> 00:21.400
 He coauthored the C programming language with Dennis Ritchie, the creator of C,

00:21.400 --> 00:26.300
 and has written a lot of books on programming, computers, and life,

00:26.300 --> 00:34.000
 including the practice of programming, the goal programming language, and his latest Unix history and a memoir.

00:34.000 --> 00:39.500
 He co created AUK, the text processing language used by Linux folks like myself.

00:39.500 --> 00:49.500
 He co designed Ample, an algebraic modeling language that I personally love and have used a lot in my life for large scale optimization.

00:49.500 --> 00:54.200
 I think I can keep going for a long time with this creations and accomplishments,

00:54.200 --> 01:01.700
 which is funny because given all that, he's one of the most humble and kind people I've spoken to on this podcast.

01:01.700 --> 01:13.200
 Quick summary of the ads, two new sponsors, the amazing self cooling 8 sleep mattress and Raycon earbuds.

01:13.200 --> 01:23.000
 Please consider supporting the podcast by going to 8sleep.com slash lex and going to buy a raycon.com slash lex.

01:23.000 --> 01:25.100
 Click the links by the stuff.

01:25.100 --> 01:29.600
 It really is the best way to support this podcast and the journey I'm on.

01:29.600 --> 01:34.200
 If you enjoy this thing, subscribe on YouTube, review it with 5,000 Apple podcasts,

01:34.200 --> 01:39.600
 support it on Patreon, or connect with me on Twitter at Lex Freedman.

01:39.600 --> 01:45.800
 As usual, I'll do a few minutes of ads now and never any ads in the middle that can break the flow of the conversation.

01:45.800 --> 01:57.300
 This show is sponsored by 8sleep and it's incredible pod pro mattress that you can check out at 8sleep.com slash lex to get $200 off.

01:57.300 --> 02:03.700
 The mattress controls temperature with an app and can cool down to as low as 55 degrees.

02:03.700 --> 02:11.200
 Research shows the temperature has a big impact on the quality of our sleep and it totally has been a game changer for me.

02:11.200 --> 02:12.200
 I love it.

02:12.200 --> 02:21.400
 The pod pro is packed with sensors that track heart rate, heart rate variability and respiratory rate showing it all on their app once you wake up.

02:21.400 --> 02:26.500
 Plus, if you have a partner, you can control the temperature of each side of the bed.

02:26.500 --> 02:32.000
 I don't happen to have one, but the 8sleep app reminds me that I should probably get on that.

02:32.000 --> 02:38.800
 So ladies, if a temperature controlled mattress isn't a good reason to apply, I don't know what is.

02:38.800 --> 02:44.300
 The app's health metrics are amazing, but the cooling alone is honestly worth the money.

02:44.300 --> 02:51.600
 As some of you know, I don't always sleep, but when I do, I choose the 8sleep pod pro mattress.

02:51.600 --> 02:57.400
 Check it out at 8sleep.com slash lex to get $200 off.

02:57.400 --> 03:01.500
 This show is also sponsored by Raycon earbuds.

03:01.500 --> 03:05.900
 Get them at buyraycon.com slash lex.

03:05.900 --> 03:10.400
 They've quickly become my main method of listening to podcasts, audio books and music.

03:10.400 --> 03:17.400
 When I run, do the pushups and pull ups that I've begun to hate at this point or just living life.

03:17.400 --> 03:22.200
 In fact, I often listen to brown noise with these when I'm thinking deeply about something.

03:22.200 --> 03:24.200
 It helps me focus the mind.

03:24.200 --> 03:30.100
 They're super comfortable, pair easily, great sound, great bass, six hours of playtime.

03:30.100 --> 03:36.300
 In fact, for fun, I have one of the earbuds in now and I'm listening to Europa by Santana,

03:36.300 --> 03:39.000
 probably one of my favorite guitar songs.

03:39.000 --> 03:41.500
 It kind of makes me feel like I'm in a music video.

03:41.500 --> 03:50.400
 So they told me to say that a bunch of celebrities use these like Snoop Dogg, Melissa Etheridge and Cardi B.

03:50.400 --> 03:55.500
 I don't even know who Cardi B is, but her earbud game is on point.

03:55.500 --> 04:01.100
 To mention celebrities actually care about, I'm sure if Richard Feynman was still with us,

04:01.100 --> 04:05.900
 he'd be listening to Joe Rogan's experience with Raycon earbuds.

04:05.900 --> 04:09.300
 Get them at buyraycon.com slash lex.

04:09.300 --> 04:14.700
 It's how they know I sent you and increases the chance that he'll support this podcast in the future.

04:14.700 --> 04:17.600
 So for all of the sponsors, click all of the links.

04:17.600 --> 04:19.900
 It really helps this podcast.

04:19.900 --> 04:25.000
 And now here's my conversation with Brian Kernigan.

04:25.000 --> 04:28.500
 UNIX started being developed 50 years ago.

04:28.500 --> 04:30.500
 It'd be more than 50 years ago.

04:30.500 --> 04:36.300
 Can you tell the story like you described in your new book of how UNIX was created?

04:36.300 --> 04:40.400
 If I can remember that far back, it was some while ago.

04:40.400 --> 04:48.200
 So I think the gist of it is that at Bell Labs in 1969, there were a group of people who had just finished

04:48.200 --> 04:54.200
 working on the Multix project, which was itself a follow on to CTSS.

04:54.200 --> 04:57.000
 So we can go back sort of an infinite regress in time.

04:57.000 --> 05:01.000
 But the CTSS was a very, very, very nice time sharing system.

05:01.000 --> 05:02.000
 It was very nice to use.

05:02.000 --> 05:06.800
 I actually used it as that summer I spent in Cambridge in 1966.

05:06.800 --> 05:08.500
 What was the hardware there?

05:08.500 --> 05:09.500
 So what's the operating system?

05:09.500 --> 05:10.300
 What's the hardware there?

05:10.300 --> 05:12.100
 What's the CTSS look like?

05:12.100 --> 05:17.000
 So CTSS looked like kind of like a standard time sharing system.

05:17.000 --> 05:19.400
 Certainly at the time, it was the only time sharing of note.

05:19.400 --> 05:20.700
 Let's go back to the basic.

05:20.700 --> 05:22.300
 What's the time sharing system?

05:22.300 --> 05:24.900
 Okay, in the beginning was the word and the word.

05:24.900 --> 05:27.000
 And then there was time sharing systems.

05:27.000 --> 05:27.400
 Yeah.

05:27.400 --> 05:34.700
 If we go back into, let's call it the 1950s and early 1960s, most computing was done on very big computers,

05:34.700 --> 05:42.100
 physically big, although not terribly powerful by today's standards that were maintained in very large rooms.

05:42.100 --> 05:47.400
 And you use things like punch cards to write your programs on, talk to them.

05:47.400 --> 05:51.900
 So you would take a deck of cards, write your program on it, send it over a counter,

05:51.900 --> 05:55.700
 hand it to an operator and some while later back would come something that said,

05:55.700 --> 05:58.000
 oh, you made a mistake and then you'd recycle.

05:58.000 --> 05:59.400
 And so it was very, very slow.

05:59.400 --> 06:04.200
 So the idea of time sharing was that you take basically that same computer,

06:04.200 --> 06:09.400
 but connect to it with something that looked like an electric typewriter.

06:09.400 --> 06:10.900
 That could be a long distance away.

06:10.900 --> 06:11.900
 It could be closed.

06:11.900 --> 06:18.100
 But fundamentally what the operating system did was to give each person who was connected to it

06:18.100 --> 06:24.900
 and wanting to do something a small slice of time to do a particular job.

06:24.900 --> 06:26.700
 So I might be editing a file.

06:26.700 --> 06:29.500
 So I would be typing and every time I hit a keystroke,

06:29.500 --> 06:32.200
 the operating system would wake up and said, oh, he typed a character.

06:32.200 --> 06:33.500
 Let me remember that.

06:33.500 --> 06:35.000
 Then it'd go back to doing something else.

06:35.000 --> 06:39.300
 So it'd be going around and around a group of people who were trying to get something done,

06:39.300 --> 06:47.600
 giving each a small slice of time and giving them each the illusion that they pretty much had the whole machine to themselves.

06:47.600 --> 06:49.200
 Enhanced time sharing.

06:49.200 --> 06:54.900
 That is sharing the computing time resource of the computer among a number of people who were doing it.

06:54.900 --> 06:58.600
 Without the individual people being aware that there's others in a sense.

06:58.600 --> 07:02.500
 The illusion, the feelings that you had, the machine is your own.

07:02.500 --> 07:04.000
 Pretty much that was the idea.

07:04.000 --> 07:09.800
 Yes, you had, if it were well done and if it were fast enough and other people weren't doing too much,

07:09.800 --> 07:13.000
 you did have the illusion that you had the whole machine to yourself

07:13.000 --> 07:16.600
 and it was very much better than the punch card model.

07:16.600 --> 07:22.500
 And so CTSS, the compatible time sharing system, was I think arguably the first of these.

07:22.500 --> 07:26.400
 It was done, I guess, technically in 64 or something like that.

07:26.400 --> 07:32.800
 It ran on an IBM 7094, slightly modified to have twice as much memory as the norm.

07:32.800 --> 07:37.500
 It had two banks of 32K words instead of one.

07:37.500 --> 07:40.600
 So 32K words.

07:40.600 --> 07:42.200
 Each word was 36 bits.

07:42.200 --> 07:46.400
 So call it, you know, about 150 kilobytes times two.

07:46.400 --> 07:49.500
 So by today's standards, that's down in the noise.

07:49.500 --> 07:53.200
 But at the time, that was a lot of memory and memory was expensive.

07:53.200 --> 07:56.800
 So CTSS was just a wonderful environment to work on.

07:56.800 --> 08:05.000
 It was done by the people at MIT, led by Fernando Corbettove, Corby, who died just earlier this year,

08:05.000 --> 08:06.500
 and a bunch of other folks.

08:06.500 --> 08:11.100
 And then so I spent the summer of 66 working on that, had a great time,

08:11.100 --> 08:17.600
 met a lot of really nice people, and indirectly knew of people at Bell Labs,

08:17.600 --> 08:24.000
 who were also working on a follow on to CTSS that was called Multix.

08:24.000 --> 08:27.600
 So Multix was meant to be the system that would do everything that CTSS did,

08:27.600 --> 08:31.600
 but do it better for a larger population, all the usual stuff.

08:31.600 --> 08:39.000
 Now, the actual time sharing, the scheduling, what's the algorithm that performs the scheduling?

08:39.000 --> 08:39.800
 What's that look like?

08:39.800 --> 08:40.900
 How much magic is there?

08:40.900 --> 08:42.600
 What are the metrics?

08:42.600 --> 08:44.600
 How does it all work in the beginning?

08:44.600 --> 08:46.100
 So the answer is I don't have a clue.

08:46.100 --> 08:50.500
 I think the basic idea was nothing more than who all wants to get something done.

08:50.500 --> 08:55.700
 Suppose that things are very quiet in the middle of the night, then I get all the time that I want.

08:55.700 --> 08:59.800
 Suppose that you and I are contending at high noon for something like that.

08:59.800 --> 09:03.600
 Then probably the simplest algorithm is around Robin one that gives you a bit of time,

09:03.600 --> 09:07.000
 gives me a bit of time, and then we could adapt to that.

09:07.000 --> 09:08.600
 Like, what are you trying to do?

09:08.600 --> 09:11.900
 Are you text editing or are you compiling or something?

09:11.900 --> 09:14.900
 And we might adjust the scheduler according to things like that.

09:14.900 --> 09:15.400
 It's okay.

09:15.400 --> 09:20.200
 So Multix was trying to just do some of the, clean it up a little bit.

09:20.200 --> 09:22.200
 Well, it was meant to be much more than that.

09:22.200 --> 09:25.400
 So Multix was the multiplexed information and computing service,

09:25.400 --> 09:29.900
 and it was meant to be a very large thing that would provide computing utility,

09:29.900 --> 09:35.000
 something that where you could actually think of it as just a plug in the wall service,

09:35.000 --> 09:37.100
 sort of like cloud computing today.

09:37.100 --> 09:38.300
 Same idea.

09:38.300 --> 09:40.700
 But 50 odd years earlier.

09:40.700 --> 09:47.000
 And so what Multix offered was a richer operating system environment,

09:47.000 --> 09:53.200
 piece of hardware that was better designed for doing the kind of sharing of resources,

09:53.200 --> 09:56.000
 and presumably lots of other things.

09:56.000 --> 10:01.100
 Do you think people at that time had the dream of what cloud computing is starting to become now,

10:01.100 --> 10:06.500
 which is computing is everywhere that you can just plug in almost, you know,

10:06.500 --> 10:09.000
 and you never know how the magic works.

10:09.000 --> 10:13.600
 You just kind of plug in at your little computation that you need to perform and it does it.

10:13.600 --> 10:14.900
 Was that the dream?

10:14.900 --> 10:16.000
 I don't know where that was the dream.

10:16.000 --> 10:17.400
 I wasn't part of it at that point.

10:17.400 --> 10:23.200
 I remember I was an intern for summer, but my sense is given that it was over 50 years ago.

10:23.200 --> 10:26.200
 Yeah, they had that idea that it was an information utility,

10:26.200 --> 10:31.600
 that it was something where if you had a computing task to do, you could just go into it.

10:31.600 --> 10:38.800
 Now, I'm betting that they didn't have the same view of computing for the masses, let's call it,

10:38.800 --> 10:43.200
 the idea that, you know, your grandmother would be shopping on Amazon.

10:43.200 --> 10:44.900
 I don't think that was part of it.

10:44.900 --> 10:51.400
 But if your grandmother were a programmer, it might be very easy for her to go and use this kind of utility.

10:51.400 --> 10:53.600
 What was your dream of computers at that time?

10:53.600 --> 10:55.600
 What did you see as the future of computers?

10:55.600 --> 10:59.500
 Because you have predicted what computers are today, in a sense.

10:59.500 --> 11:01.700
 Oh, short answer, absolutely not.

11:01.700 --> 11:02.600
 I have no clue.

11:02.600 --> 11:03.800
 I'm not sure I had a dream.

11:03.800 --> 11:07.400
 It was a dream job in the sense that I really enjoyed what I was doing.

11:07.400 --> 11:10.000
 I was surrounded by really, really nice people.

11:10.000 --> 11:14.200
 Cambridge is a very fine city to live in in the summer, less so in the winter when it snows.

11:14.200 --> 11:16.800
 But in the summer, it was a delightful time.

11:16.800 --> 11:20.500
 And so I really enjoyed all of that stuff and I learned things.

11:20.500 --> 11:28.400
 And I think the good fortune of being there for summer led me then to get a summer job at Bell Labs the following summer.

11:28.400 --> 11:31.700
 And that was quite useful for the future.

11:31.700 --> 11:36.000
 So this Bell Labs is this magical, legendary place.

11:36.000 --> 11:39.000
 So first of all, where is Bell Labs?

11:39.000 --> 11:46.500
 And can you start talking about that journey towards Unix at Bell Labs?

11:46.500 --> 11:52.300
 Yeah, so Bell Labs is physically scattered around at the time, scattered around New Jersey.

11:52.300 --> 12:03.400
 The primary location was in a town called Murray Hill, where a location called Murray Hill is actually that across the boundary between two small towns in New Jersey called New Providence and Berkeley Heights.

12:03.400 --> 12:11.600
 Think of it as about 15, 20 miles straight west of New York City and therefore about an hour north of here in Princeton.

12:11.600 --> 12:21.400
 And at that time, it had make up a number of 3,000, 4,000 people there, many of whom had PhDs and mostly doing physical sciences, chemistry,

12:21.400 --> 12:26.000
 physics, materials, kinds of things, but very strong math.

12:26.000 --> 12:35.300
 And it rapidly growing interest in computing as people realized you could do things with computers that you might not have been able to do before.

12:35.300 --> 12:41.300
 You could replace labs with computers that had worked on models of what was going on.

12:41.300 --> 12:44.100
 So that was the essence of Bell Labs.

12:44.100 --> 12:46.600
 And again, I wasn't a permanent employee there.

12:46.600 --> 12:47.900
 That was another internship.

12:47.900 --> 12:50.500
 I got lucky in internships.

12:50.500 --> 12:52.600
 I mean, if you could just linger on it a little bit.

12:52.600 --> 12:55.500
 What was the, what was in the air there?

12:55.500 --> 13:03.000
 Because some of this, the number of Nobel prizes, the number of touring awards and just legendary computer scientists that come from their inventions,

13:03.000 --> 13:07.900
 including developments, including UNIX, it's just unbelievable.

13:07.900 --> 13:11.600
 So was there something special about that place?

13:11.600 --> 13:14.600
 Oh, I think there was very definitely something special.

13:14.600 --> 13:19.100
 I mentioned the number of people, so very large number of people, very highly skilled.

13:19.100 --> 13:25.100
 And working in an environment where there was always something interesting to work on because the goal of Bell Labs,

13:25.100 --> 13:30.100
 which was a small part of AT&T, which provided basically the country's phone service.

13:30.100 --> 13:33.400
 The goal of AT&T was to provide service for everybody.

13:33.400 --> 13:38.000
 And the goal of Bell Labs was to try and make that service keep getting better.

13:38.000 --> 13:39.500
 So improving service.

13:39.500 --> 13:43.900
 And that meant doing research on a lot of different things,

13:43.900 --> 13:50.800
 physical devices like the transistor or fiber optical cables or microwave systems.

13:50.800 --> 13:53.200
 All of these things the labs worked on.

13:53.200 --> 13:58.000
 And it was kind of just the beginning of real boom times in computing as well.

13:58.000 --> 14:01.100
 Because when I was there, I went there first in 66.

14:01.100 --> 14:04.500
 So computing was at that point fairly young.

14:04.500 --> 14:08.700
 And so people were discovering that you could do lots of things with computers.

14:08.700 --> 14:10.800
 So how's UNIX born?

14:10.800 --> 14:15.500
 So in spite of having an enormous number of really good ideas,

14:15.500 --> 14:20.000
 lots of good people working on it fundamentally didn't live up at least in the short run.

14:20.000 --> 14:25.500
 And I think ultimately really ever to its goal of being this information utility.

14:25.500 --> 14:31.500
 It was too expensive and certainly what was promised was delivered much too late.

14:31.500 --> 14:37.100
 And so in roughly the beginning of 1969, Bell Labs pulled out of the project.

14:37.100 --> 14:44.000
 The project at that point had included MIT, Bell Labs and General Electric.

14:44.000 --> 14:45.400
 General Electric made computers.

14:45.400 --> 14:48.300
 So General Electric was the hardware operation.

14:48.300 --> 14:54.100
 So Bell Labs realizing this wasn't going anywhere on a timescale they cared about pulled out of the project.

14:54.100 --> 15:01.600
 And this left several people with an acquired taste for really, really nice computing environments,

15:01.600 --> 15:03.500
 but no computing environment.

15:03.500 --> 15:09.400
 And so they started thinking about what could you do if you're going to design a new operating system

15:09.400 --> 15:14.200
 that would provide the same kind of comfortable computing as CTSS had,

15:14.200 --> 15:19.400
 but also the facilities of something like Multics sort of brought forward.

15:19.400 --> 15:21.700
 And so they did a lot of paper design stuff.

15:21.700 --> 15:27.300
 And at the same time, Ken Thompson found what is characterized as a little used PDP 7

15:27.300 --> 15:35.000
 where he started to do experiments with file systems, just how do you store information on a computer in a deficient way.

15:35.000 --> 15:41.100
 And then this famous story that his wife went away to California for three weeks taking their one year old son

15:41.100 --> 15:47.500
 and three weeks and he sat down and wrote an operating system, which ultimately became Unix.

15:47.500 --> 15:50.300
 So software productivity is good in those days.

15:50.300 --> 15:52.100
 So PDP, what's a PDP 7?

15:52.100 --> 15:53.400
 So it's a piece of hardware.

15:53.400 --> 15:59.900
 Yeah, it's a piece of hardware. It was one of early machines made by Digital Equipment Corporation, DEC.

15:59.900 --> 16:07.500
 And it was a mini computer, so called it had, I would have to look up the numbers exactly,

16:07.500 --> 16:15.200
 but it had a very small amount of memory, maybe 16k, 16 bit words or something like that, relatively slow.

16:15.200 --> 16:17.100
 Probably not super expensive.

16:17.100 --> 16:21.800
 Maybe again, making this up, I'd have to look it up $100,000 or something like that,

16:21.800 --> 16:24.300
 which is not super expensive in those days, right?

16:24.300 --> 16:27.600
 It was expensive. It was enough that you and I probably wouldn't be able to buy one,

16:27.600 --> 16:30.800
 but a modest group of people could get together.

16:30.800 --> 16:34.800
 But in any case, it came out, if I recall, in 1964.

16:34.800 --> 16:41.400
 So by 1969, it was getting a little obsolete, and that's why it was little used.

16:41.400 --> 16:45.600
 If you can sort of comment, what do you think it's like to write an operating system like that?

16:45.600 --> 16:49.500
 So that process that Ken went through in three weeks,

16:49.500 --> 16:52.700
 because you were, I mean, you're part of that process.

16:52.700 --> 16:57.500
 You contributed a lot to UNIX's early development.

16:57.500 --> 17:05.400
 So what do you think it takes to do that first step, that first kind of from design to reality on the PDP?

17:05.400 --> 17:08.800
 Well, let me correct one thing. I had nothing to do with it.

17:08.800 --> 17:13.300
 So I did not write it. I have never written operating system code.

17:13.300 --> 17:21.300
 And so I don't know now an operating system is simply code. And this first one wasn't very big,

17:21.300 --> 17:27.300
 but it's something that lets you run processes of some, let you execute some kind of code that has been written.

17:27.300 --> 17:36.100
 It lets you store information for periods of time so that it doesn't go away when you turn the power off or reboot or something like that.

17:36.100 --> 17:40.900
 And there's a kind of a core set of tools that are technically not part of an operating system,

17:40.900 --> 17:46.700
 but you probably need them. In this case, Ken wrote an assembler for the PDP 7 that worked.

17:46.700 --> 17:49.800
 He did a text editor so that he could actually create text.

17:49.800 --> 17:52.100
 He had the file system stuff that he had been working on.

17:52.100 --> 17:55.700
 And then the rest of it was just a way to load things,

17:55.700 --> 18:00.000
 executable code from the file system into the memory, give it control,

18:00.000 --> 18:04.800
 and then recover control when it was finished or in some other way quit.

18:04.800 --> 18:09.200
 What was the code written in the primarily the programming language? Was it in assembly?

18:09.200 --> 18:13.700
 Yeah, PDP 7 assembler that Ken created.

18:13.700 --> 18:21.400
 These things were assembly language until probably the call it 1973 or 74, something like that.

18:21.400 --> 18:28.800
 Forgive me if it's a dumb question, but it feels like a daunting task to write any kind of complex system in assembly.

18:28.800 --> 18:31.300
 Absolutely.

18:31.300 --> 18:36.200
 It feels like impossible to do any kind of what we think of as software engineering with assembly,

18:36.200 --> 18:40.000
 to work on a big picture.

18:40.000 --> 18:43.600
 I think it's hard. It's been a long time since I wrote assembly language.

18:43.600 --> 18:47.100
 It is absolutely true that in assembly language, if you make a mistake, nobody tells you.

18:47.100 --> 18:51.700
 There are no training wheels whatsoever. And so stuff doesn't work. Now what?

18:51.700 --> 18:53.400
 There's no debuggers.

18:53.400 --> 18:56.800
 Well, there could be debuggers, but that's the same problem, right?

18:56.800 --> 19:00.400
 How do you actually get something that will help you debug it?

19:00.400 --> 19:05.600
 So part of it is an ability to see the big picture.

19:05.600 --> 19:08.600
 Now, these systems were not big in the sense that today's pictures are.

19:08.600 --> 19:11.800
 So the big picture was, in some sense, more manageable.

19:11.800 --> 19:17.500
 I mean, then realistically, there's an enormous variation in the capabilities of programmers.

19:17.500 --> 19:27.700
 And Ken Thompson, who did that first one, is kind of the singularity in my experience of programmers with no disrespect to you or even to me.

19:27.700 --> 19:29.400
 He's in denial.

19:29.400 --> 19:31.000
 Several leagues removed.

19:31.000 --> 19:40.900
 I know there's levels. It's a fascinating thing that there are unique stars in particular in the programming space and in a particular time.

19:40.900 --> 19:44.400
 You know, the time matters to the timing of when that person comes along.

19:44.400 --> 19:47.300
 And a wife does have to leave.

19:47.300 --> 19:52.300
 There's this weird timing that happens that in an all of a sudden something beautiful is created.

19:52.300 --> 19:58.300
 I mean, how does it make you feel that there's a system that was created in three weeks?

19:58.300 --> 20:02.000
 Or maybe you can even say on a whim, but not really.

20:02.000 --> 20:10.600
 But of course, quickly, that is now, you could think of most of the computers in the world run on a UNIX like system.

20:10.600 --> 20:12.400
 Right.

20:12.400 --> 20:18.400
 How do you, like, if you kind of zoom from the alien perspective, if you're just observing Earth,

20:18.400 --> 20:24.800
 that all of a sudden these computers took over the world and they started from this little initial seed of UNIX?

20:24.800 --> 20:26.600
 How does that make you feel?

20:26.600 --> 20:30.200
 It's quite surprising. And you asked earlier about prediction.

20:30.200 --> 20:33.900
 The answer is no. There's no way you could predict that kind of evolution.

20:33.900 --> 20:39.100
 And I don't know whether it was inevitable or just a whole sequence of blind luck.

20:39.100 --> 20:40.900
 I suspect more of the latter.

20:40.900 --> 20:47.700
 And so I look at it and think, gee, that's kind of neat.

20:47.700 --> 20:51.000
 I think the real question is what does Ken think about that?

20:51.000 --> 20:54.900
 Because he's the guy arguably from whom it really came.

20:54.900 --> 21:00.200
 You know, tremendous contributions from Dennis Ritchie and then others around in that Bell Labs environment.

21:00.200 --> 21:04.500
 But, you know, if you had to pick a single person, that would be Ken.

21:04.500 --> 21:08.300
 So you've written a new book, UNIX, A History and a Memoir.

21:08.300 --> 21:14.100
 Are there some memorable human stories, funny or profound from that time that just kind of stand out?

21:14.100 --> 21:15.700
 Oh, there's a lot of them, in a sense.

21:15.700 --> 21:21.800
 And again, it's a question of can you resurrect them in real time way as memory fails?

21:21.800 --> 21:27.100
 But I think part of it was that Bell Labs at the time was a very special kind of place to work

21:27.100 --> 21:31.700
 because there were a lot of interesting people and the environment was very, very open and free.

21:31.700 --> 21:34.400
 It was a very cooperative environment, very friendly environment.

21:34.400 --> 21:40.600
 And so if you had an interesting problem, you go and talk to somebody and they might help you with the solution.

21:40.600 --> 21:46.600
 And it was kind of a fun environment, too, in which people did strange things

21:46.600 --> 21:52.400
 and often tweaking the bureaucracy in one way or another.

21:52.400 --> 21:54.900
 So rebellious in certain kinds of ways.

21:54.900 --> 21:56.700
 In some ways, yeah, absolutely.

21:56.700 --> 21:59.700
 I think most people didn't take too kindly to the bureaucracy.

21:59.700 --> 22:05.900
 And I'm sure the bureaucracy put up with an enormous amount that they didn't really want to.

22:05.900 --> 22:09.500
 So maybe to linger on it a little bit.

22:09.500 --> 22:13.700
 Do you have a sense of what the philosophy that characterizes UNIX is?

22:13.700 --> 22:18.800
 The design, not just the initial, but just carry through the years.

22:18.800 --> 22:20.600
 Just being there, being around it.

22:20.600 --> 22:23.300
 What's the fundamental philosophy behind the system?

22:23.300 --> 22:29.100
 I think one aspect of fundamental philosophy was to provide an environment that made it easy to write

22:29.100 --> 22:31.900
 or easier productive to write programs.

22:31.900 --> 22:33.700
 So it was meant as a programmer environment.

22:33.700 --> 22:38.300
 It wasn't meant specifically as something to do some other kind of job.

22:38.300 --> 22:43.700
 For example, it was used extensively for word processing, but it wasn't designed as a word processing system.

22:43.700 --> 22:47.300
 It was used extensively for lab control, but it wasn't designed for that.

22:47.300 --> 22:52.400
 It was used extensively as a front end for big other systems, big dumb systems.

22:52.400 --> 22:53.700
 But it wasn't designed for that.

22:53.700 --> 22:57.900
 It was meant to be an environment where it was really easy to write programs.

22:57.900 --> 23:00.600
 So the programmers could be highly productive.

23:00.600 --> 23:03.100
 And part of that was to be a community.

23:03.100 --> 23:05.500
 And there's some observation from Dennis Ritchie.

23:05.500 --> 23:11.800
 I think at the end of the book, it says that from his standpoint, the real goal was to create a community

23:11.800 --> 23:17.100
 where people could work as programmers on a system.

23:17.100 --> 23:22.600
 And I think in that sense, certainly for many, many years, it succeeded quite well at that.

23:22.600 --> 23:27.500
 And part of that is the technical aspects of because it made it really easy to write programs.

23:27.500 --> 23:29.400
 People did write interesting programs.

23:29.400 --> 23:36.500
 Those programs tended to be used by other programmers, and so it was kind of a virtuous circle of more and more stuff coming out

23:36.500 --> 23:39.300
 that was really good for programmers.

23:39.300 --> 23:41.700
 And you were part of that community of programmers.

23:41.700 --> 23:45.700
 So what was it like writing programs on that early Unix?

23:45.700 --> 23:46.500
 It was a blast.

23:46.500 --> 23:49.900
 It really was.

23:49.900 --> 23:51.100
 You know, I like to program.

23:51.100 --> 23:55.200
 I'm not a terribly good programmer, but it was a lot of fun to write code.

23:55.200 --> 24:00.100
 And in the early days, there was an enormous amount of what you would today, I suppose, call low hanging fruit.

24:00.100 --> 24:02.500
 People hadn't done things before.

24:02.500 --> 24:09.700
 And this was this new environment and the whole combination of nice tools and very responsive system.

24:09.700 --> 24:13.600
 And tremendous colleagues made it possible to write code.

24:13.600 --> 24:16.400
 You could have an idea in the morning.

24:16.400 --> 24:19.100
 You could do an experiment with it.

24:19.100 --> 24:23.600
 You could have something limping along that night or the next day and people would react to it.

24:23.600 --> 24:27.800
 And they would say, oh, that's wonderful, but you're really screwed up here.

24:27.800 --> 24:31.700
 And the feedback loop was then very, very short and tight.

24:31.700 --> 24:39.900
 And so a lot of things got developed fairly quickly that in many cases still exist today.

24:39.900 --> 24:44.700
 And I think that was part of what made it fun because programming itself is fun.

24:44.700 --> 24:46.900
 It's puzzle solving in a variety of ways.

24:46.900 --> 24:52.300
 But I think it's even more fun when you do something that somebody else then uses.

24:52.300 --> 24:58.500
 Even if they whine about it not working, the fact that they used it is part of the reward mechanism.

24:58.500 --> 25:03.600
 And what was the method of interaction, the communication when you do that feedback loop?

25:03.600 --> 25:05.400
 I mean, this is before the internet.

25:05.400 --> 25:07.500
 Certainly before the internet.

25:07.500 --> 25:11.400
 It was mostly physical right there.

25:11.400 --> 25:13.700
 You know, somebody would come into your office and say something.

25:13.700 --> 25:16.700
 So these places are all close, but like offices are nearby.

25:16.700 --> 25:18.900
 So you're really lively into interaction.

25:18.900 --> 25:23.500
 Yeah, yeah, Bell Labs was fundamentally one giant building and most of the people were involved

25:23.500 --> 25:27.600
 in this unique stuff were in two or three quarters and there was a room.

25:27.600 --> 25:29.400
 Oh, how big was it?

25:29.400 --> 25:37.300
 Probably call it 50 feet by 50 feet, make up a number of that which had some access

25:37.300 --> 25:42.900
 to computers there as well as in offices and people hung out there and it had a coffee machine.

25:42.900 --> 25:46.300
 And so there was a, it was mostly very physical.

25:46.300 --> 25:54.100
 We did use email, of course, and, but it was fundamentally all for a long time, all on one machine.

25:54.100 --> 25:56.500
 So there was no need for internet.

25:56.500 --> 26:00.900
 It's fascinating to think about what computing would be today without Bell Labs.

26:00.900 --> 26:06.400
 It seems so many people being in the vicinity of each other.

26:06.400 --> 26:09.100
 It's sort of getting that quick feedback working together.

26:09.100 --> 26:11.100
 There's so many brilliant people.

26:11.100 --> 26:16.100
 I don't know where else that could have existed in the world and been given how that came together.

26:16.100 --> 26:23.300
 How does that make you feel that little element of history?

26:23.300 --> 26:28.500
 Well, I think that's very nice, but in a sense it's survivor bias and if it hadn't happened

26:28.500 --> 26:32.900
 at Bell Labs, there were other places that were doing really interesting work as well.

26:32.900 --> 26:35.100
 Xerox Park is perhaps the most obvious one.

26:35.100 --> 26:39.200
 Xerox Park contributed an enormous amount of good material and many of the things we

26:39.200 --> 26:43.300
 take for granted today in the same way came from Xerox Park experience.

26:43.300 --> 26:46.500
 I don't think they capitalized in the long run as much.

26:46.500 --> 26:51.900
 Their parent company was perhaps not as lucky in capitalizing on this.

26:51.900 --> 26:52.900
 Who knows?

26:52.900 --> 26:58.100
 But that would, that's certainly another place where there was a tremendous amount of influence.

26:58.100 --> 27:00.300
 There were a lot of good university activities.

27:00.300 --> 27:07.100
 MIT was obviously no slouch in this kind of thing and others as well.

27:07.100 --> 27:13.600
 So UNIX turned out to be open source because of the various ways that AT&T operated and

27:13.600 --> 27:18.900
 sort of had to, the focus was on telephones.

27:18.900 --> 27:21.700
 I think that's a mischaracterization in a sense.

27:21.700 --> 27:24.020
 It absolutely was not open source.

27:24.020 --> 27:30.780
 It was very definitely proprietary licensed, but it was licensed freely to universities

27:30.780 --> 27:33.900
 in source code form for many years.

27:33.900 --> 27:39.820
 And because of that, generations of university students and their faculty people grew up

27:39.820 --> 27:45.540
 knowing about UNIX and that there was enough expertise in the community that it then became

27:45.540 --> 27:49.100
 possible for people to kind of go off in their own direction and build something that looked

27:49.100 --> 27:51.620
 UNIX like.

27:51.620 --> 27:58.140
 The Berkeley version of UNIX started with that licensed code and gradually picked up

27:58.140 --> 28:06.500
 enough of its own code contributions, notably from people like Bill Joy, that eventually

28:06.500 --> 28:10.340
 it was able to become completely free of any AT&T code.

28:10.340 --> 28:15.980
 In other words, an enormous amount of legal jockeying around this in the late early to

28:15.980 --> 28:19.700
 late 80s, early 90s, something like that.

28:19.700 --> 28:27.100
 And then not some, I guess the open source movement might have started when Richard Stallman

28:27.100 --> 28:32.860
 started to think about this in the late 80s and by 1991, when Torvalds decided he was

28:32.860 --> 28:40.380
 going to do a UNIX like operating system, there was enough expertise that in the community

28:40.380 --> 28:42.140
 that first he had a target.

28:42.140 --> 28:48.100
 He could see what to do because the kind of the UNIX system call interface and the tools

28:48.100 --> 28:50.780
 and so on were there.

28:50.780 --> 28:56.460
 And so he was able to build an operating system that at this point, when you say UNIX in many

28:56.460 --> 28:58.500
 cases, what you're really thinking is Linux.

28:58.500 --> 28:59.500
 Linux, yeah.

28:59.500 --> 29:06.300
 But it's funny that from my distant perception, I felt that UNIX was open source without actually

29:06.300 --> 29:11.700
 knowing it, but what you're really saying, it was just freely licensed.

29:11.700 --> 29:12.700
 It was freely licensed.

29:12.700 --> 29:17.020
 So it felt open source because universities are not trying to make money.

29:17.020 --> 29:20.780
 So it felt open source in the sense that you can get access if you wanted.

29:20.780 --> 29:21.780
 Right.

29:21.780 --> 29:25.140
 And a very, very, very large number of universities had the license and they were able to talk

29:25.140 --> 29:27.540
 to all the other universities who had the license.

29:27.540 --> 29:34.940
 And so technically not open, technically belonging to AT&T pragmatically, pretty open.

29:34.940 --> 29:38.820
 And so there's a ripple effect that all the faculty and the students then all grew up

29:38.820 --> 29:45.500
 and then they went throughout the world and permeated in that kind of way.

29:45.500 --> 29:52.620
 So what kind of features do you think make for a good operating system?

29:52.620 --> 30:00.060
 If you take the lessons of UNIX, you said make it easy for programmers.

30:00.060 --> 30:04.020
 That seems to be an important one.

30:04.020 --> 30:08.740
 But also UNIX turned out to be exceptionally robust and efficient.

30:08.740 --> 30:14.700
 So is that an accident when you focus on the programmer or is that a natural outcome?

30:14.700 --> 30:20.940
 I think part of the reason for efficiency was that it began on extremely modest hardware.

30:20.940 --> 30:24.060
 Very, very, very tiny and so you couldn't get carried away.

30:24.060 --> 30:29.980
 You couldn't do a lot of complicated things because you just didn't have the resources,

30:29.980 --> 30:32.580
 either processor, speed or memory.

30:32.580 --> 30:39.940
 And so that enforced a certain minimality of mechanisms and maybe a search for generalizations

30:39.940 --> 30:43.660
 so that you would find one mechanism that's served for a lot of different things rather

30:43.660 --> 30:45.820
 than having lots of different special cases.

30:45.820 --> 30:50.420
 I think the file system in UNIX is a good example of that file system interface and

30:50.420 --> 30:53.940
 its fundamental form is extremely straightforward.

30:53.940 --> 30:59.100
 And that means that you can write code very, very effectively for the file system.

30:59.100 --> 31:04.780
 And then one of those idea, one of those generalizations is that gee, that file system interface works

31:04.780 --> 31:06.900
 for all kinds of other things as well.

31:06.900 --> 31:11.540
 And so in particular, the idea of reading and writing to devices is the same as reading

31:11.540 --> 31:14.820
 and writing to a disk that has a file system.

31:14.820 --> 31:21.740
 And then that gets carried further in other parts of the world, processes become in effect

31:21.740 --> 31:24.340
 files in a file system.

31:24.340 --> 31:27.780
 And the Plan 9 operating system, which came along, I guess in the late 80s or something

31:27.780 --> 31:33.940
 like that, took a lot of those ideas from the original UNIX and tried to push the generalization

31:33.940 --> 31:38.740
 even further so that in Plan 9 a lot of different resources are file systems, they all share

31:38.740 --> 31:39.740
 that interface.

31:39.740 --> 31:45.740
 So that would be one example where finding the right model of how to do something means

31:45.740 --> 31:48.180
 that an awful lot of things become simpler.

31:48.180 --> 31:51.980
 And it means therefore that more people can do useful, interesting things with them without

31:51.980 --> 31:54.580
 them to think as hard about it.

31:54.580 --> 31:57.100
 So you said you're not a very good programmer.

31:57.100 --> 31:58.100
 True.

31:58.100 --> 32:01.220
 You're the most modest human being.

32:01.220 --> 32:02.980
 Okay, but you'll continue saying that.

32:02.980 --> 32:07.860
 I understand how this works, but you do radiate a sort of love for programming.

32:07.860 --> 32:13.260
 So let me ask, do you think programming is more an art or a science?

32:13.260 --> 32:16.540
 Is it creativity or kind of rigor?

32:16.540 --> 32:20.980
 I think it's some of each, it's some combination.

32:20.980 --> 32:23.860
 Some of the art is figuring out what it is that you really want to do.

32:23.860 --> 32:26.020
 What should that program be?

32:26.020 --> 32:27.620
 What would make a good program?

32:27.620 --> 32:32.140
 And that's some understanding of what the task is, what the people who might use this

32:32.140 --> 32:33.140
 program want.

32:33.140 --> 32:37.820
 And I think that's art in many respects.

32:37.820 --> 32:40.620
 The science part is trying to figure out how to do it well.

32:40.620 --> 32:47.140
 And some of that is real computer science stuff, like what algorithm should we use at

32:47.140 --> 32:53.740
 some point, mostly in the sense of being careful to use algorithms that will actually work

32:53.740 --> 32:59.340
 properly, scale properly, avoiding quadratic algorithms when a linear algorithm should

32:59.340 --> 33:04.260
 be the right thing, that kind of more formal view of it.

33:04.260 --> 33:06.620
 Same thing for data structures.

33:06.620 --> 33:10.460
 But also it's, I think, an engineering field as well.

33:10.460 --> 33:15.420
 And engineering is not quite the same as science because engineering, you're working with constraints.

33:15.420 --> 33:21.100
 You have to figure out not only what is a good algorithm for this kind of thing, but

33:21.100 --> 33:26.340
 what's the most appropriate algorithm given the amount of time we have to compute, the

33:26.340 --> 33:31.020
 amount of time we have to program, what's likely to happen in the future with maintenance,

33:31.020 --> 33:35.180
 who's going to pick this up in the future, all of those kind of things that if you're

33:35.180 --> 33:37.460
 an engineer, you get to worry about.

33:37.460 --> 33:41.500
 Whereas if you think of yourself as a scientist, well, you can maybe push them over the horizon

33:41.500 --> 33:42.500
 in a way.

33:42.500 --> 33:45.500
 And if you're an artist, what's that?

33:45.500 --> 33:50.780
 So just on your own personal level, what's your process like of writing a program, say

33:50.780 --> 33:55.940
 a small and large sort of tinkering with stuff?

33:55.940 --> 34:03.100
 Do you just start coding right away and just kind of evolve iteratively with a loose notion?

34:03.100 --> 34:09.260
 Or do you plan on a sheet of paper first and then kind of design in what they teach you

34:09.260 --> 34:13.820
 in the kind of software engineering courses and undergrad or something like that?

34:13.820 --> 34:15.060
 What's your process like?

34:15.060 --> 34:17.500
 It's certainly much more the informal incremental.

34:17.500 --> 34:20.300
 First, I don't write big programs at this point.

34:20.300 --> 34:24.740
 It's been a long time since I wrote a program that was more than I call it a few hundred

34:24.740 --> 34:27.260
 or more lines, something like that.

34:27.260 --> 34:31.940
 Many of the programs I write are experiments for either something I'm curious about or

34:31.940 --> 34:34.660
 often for something that I want to talk about in a class.

34:34.660 --> 34:38.980
 And so those necessarily tend to be relatively small.

34:38.980 --> 34:44.340
 A lot of the kind of code I write these days tends to be for sort of exploratory data analysis,

34:44.340 --> 34:47.420
 where I've got some collection of data and I want to try and figure out what on earth

34:47.420 --> 34:49.380
 is going on in it.

34:49.380 --> 34:52.780
 And for that, those programs tend to be very small.

34:52.780 --> 34:58.020
 Sometimes you're not even programming, you're just using existing tools like counting things.

34:58.020 --> 35:02.700
 Or sometimes you're writing OX scripts because two or three lines will tell you something

35:02.700 --> 35:06.880
 about a piece of data and then when it gets bigger, well, then I will probably write something

35:06.880 --> 35:13.700
 in Python because that scales better up to call it a few hundred lines or something like

35:13.700 --> 35:14.700
 that.

35:14.700 --> 35:18.940
 And it's been a long time since I wrote programs that were much more than that.

35:18.940 --> 35:23.700
 Speaking of data exploration in OX, first, what is OX?

35:23.700 --> 35:30.340
 So OX is a scripting language that was done by myself, L Aho, and Peter Weinberger.

35:30.340 --> 35:32.820
 We did that originally in the late 70s.

35:32.820 --> 35:38.140
 It was a language that was meant to make it really easy to do quick and dirty tasks like

35:38.140 --> 35:45.220
 counting things or selecting interesting information from basically all text files,

35:45.220 --> 35:48.460
 rearranging it in some way or summarizing it.

35:48.460 --> 35:51.500
 Runs a command on each line or a file.

35:51.500 --> 35:55.420
 I mean, it's still exceptionally widely used today.

35:55.420 --> 35:56.420
 Oh, absolutely.

35:56.420 --> 35:57.420
 Yeah.

35:57.420 --> 36:03.140
 It's so simple and elegant, the way to explore data turns out you can just write a script

36:03.140 --> 36:09.300
 that does something seemingly trivial on a single line and that giving you that slice

36:09.300 --> 36:16.860
 of the data somehow reveals something fundamental about the data and that seems to work still.

36:16.860 --> 36:19.820
 Yeah, it's very good for that kind of thing.

36:19.820 --> 36:21.260
 It's sort of what it was meant for.

36:21.260 --> 36:25.860
 I think what we didn't appreciate was that the model was actually quite good for a lot

36:25.860 --> 36:30.900
 of data processing kinds of tasks and that it's kept going as long as it has because

36:30.900 --> 36:37.100
 at this point it's over 40 years old and it's still, I think, a useful tool and well, this

36:37.100 --> 36:41.220
 is paternal interest, I guess, but I think in terms of programming languages, you get

36:41.220 --> 36:46.860
 the most bang for the buck by learning OX and it doesn't scale to big programs, but

36:46.860 --> 36:51.980
 it does pretty darn well on these little things where you just want to see all the somethings

36:51.980 --> 36:52.980
 in something.

36:52.980 --> 36:58.740
 Yeah, I probably write more OX than anything else at this point.

36:58.740 --> 37:02.060
 So what kind of stuff do you love about OX?

37:02.060 --> 37:10.660
 If you can comment on things that give you joy when you can, in a simple program, reveal

37:10.660 --> 37:14.540
 something about the data, is there something that stands out from particular features?

37:14.540 --> 37:20.540
 I think it's mostly the selection of default behaviors that you sort of hinted at at a

37:20.540 --> 37:21.540
 moment ago.

37:21.540 --> 37:26.940
 What OX does is to read through a set of files and then within each file, it reads through

37:26.940 --> 37:32.460
 each of the lines and then on each of the lines, it has a set of patterns that it looks

37:32.460 --> 37:33.460
 for.

37:33.460 --> 37:38.740
 That's your OX program and if one of the patterns matches, there is a corresponding action that

37:38.740 --> 37:44.500
 you might perform and so it's kind of a quadruply nested loop or something like that.

37:44.500 --> 37:46.700
 And that's all completely automatic.

37:46.700 --> 37:48.260
 You don't have to say anything about it.

37:48.260 --> 37:52.500
 You just write the pattern in the action and then run the data by it.

37:52.500 --> 37:57.060
 And so that paradigm for programming is a very natural and effective one.

37:57.060 --> 38:01.620
 And I think we captured that reasonably well in OX and it does other things for free as

38:01.620 --> 38:02.620
 well.

38:02.620 --> 38:06.940
 It splits the data into fields so that on each line, there's fields separated by white space

38:06.940 --> 38:08.900
 or something and so it does that for free.

38:08.900 --> 38:11.540
 You don't have to say anything about it.

38:11.540 --> 38:15.940
 And it collects information as it goes along, like what line are we on, how many fields

38:15.940 --> 38:18.140
 are there on this line.

38:18.140 --> 38:22.940
 So lots of things that just make it so that a program which in another language, let's

38:22.940 --> 38:28.260
 say Python would be 5, 10, 20 lines in OX is one or two lines.

38:28.260 --> 38:31.260
 So because it's one or two lines, you can do it on the shell.

38:31.260 --> 38:33.780
 You don't have to open up another whole thing.

38:33.780 --> 38:39.020
 You can just do it right there in the interaction with the operatives directly.

38:39.020 --> 38:46.300
 Is there other shell commands that you love over the years like you really enjoy using?

38:46.300 --> 38:47.300
 Oh, Grapp.

38:47.300 --> 38:48.300
 Grapp?

38:48.300 --> 38:49.300
 Grapp's the only one.

38:49.300 --> 38:51.580
 Yeah, Grapp does everything.

38:51.580 --> 38:55.700
 So Grapp is a kind of a, what is it, a simpler version of OX, I would say?

38:55.700 --> 38:57.860
 In some sense, yeah, right.

38:57.860 --> 38:59.020
 Because what is Grapp?

38:59.020 --> 39:03.900
 So Grapp is, it basically searches the input for particular patterns, regular expressions

39:03.900 --> 39:06.300
 technically of a certain class.

39:06.300 --> 39:10.140
 And it has that same paradigm that OX does, it's a pattern action thing.

39:10.140 --> 39:13.740
 It reads through all the files and then all the lines in each file.

39:13.740 --> 39:17.180
 But it has a single pattern, which is the regular expression you're looking for, and

39:17.180 --> 39:20.340
 a single action printed if it matches.

39:20.340 --> 39:27.380
 So in that sense, it's a much simpler version and you could write Grapp in OX as a one liner.

39:27.380 --> 39:33.980
 And I use Grapp probably more than anything else at this point, just because it's so convenient

39:33.980 --> 39:34.980
 and natural.

39:34.980 --> 39:38.740
 Why do you think, it's such a powerful tool, Grapp and OX.

39:38.740 --> 39:44.980
 Why do you think operating systems like Windows, for example, don't have it?

39:44.980 --> 39:48.420
 Sort of, you can, of course, I use, which is amazing now.

39:48.420 --> 39:54.780
 There's Windows for Linux, like the, which you could basically use all the fun stuff

39:54.780 --> 39:57.540
 like Ock and Grapp inside of Windows.

39:57.540 --> 40:01.900
 But Windows naturally sort of, as part of the graphical interface, the simplicity of

40:01.900 --> 40:06.220
 Grapp, sort of searching through a bunch of files and just popping up naturally.

40:06.220 --> 40:10.860
 Why, why don't you think that, why do you think that's unique to the Unix and Linux

40:10.860 --> 40:11.860
 environment?

40:11.860 --> 40:12.860
 I don't know.

40:12.860 --> 40:16.580
 It's not strictly unique, but it's certainly focused there.

40:16.580 --> 40:22.660
 And I think some of it's the weight of history, that Windows came from MS DOS, MS DOS was

40:22.660 --> 40:27.420
 a pretty pathetic operating system, although common on an, you know, unboundedly large

40:27.420 --> 40:34.740
 number of machines, but somewhere in roughly the 90s, Windows became a graphical system.

40:34.740 --> 40:39.900
 And I think Microsoft spent a lot of their energy on making that graphical interface

40:39.900 --> 40:41.820
 what it is.

40:41.820 --> 40:43.780
 And that's a different model of computing.

40:43.780 --> 40:48.340
 And it's a model of computing that where you point and click and sort of experiment

40:48.340 --> 40:54.780
 with menus, it's a model of computing works right rather well for people who are not programmers.

40:54.780 --> 41:00.260
 Just want to get something done, whereas teaching something like the command line to non programmers

41:00.260 --> 41:02.900
 turns out to sometimes be an uphill struggle.

41:02.900 --> 41:05.900
 And so I think Microsoft probably was right in what they did.

41:05.900 --> 41:09.620
 Now you mentioned whistle or whatever it's called the Winix Linux.

41:09.620 --> 41:10.620
 What's that?

41:10.620 --> 41:11.620
 I wonder what's pronounced.

41:11.620 --> 41:13.460
 WSL is what never actually pronounced the whistle.

41:13.460 --> 41:14.460
 I like it.

41:14.460 --> 41:16.020
 I have no idea.

41:16.020 --> 41:17.740
 But there have been things like that for longest.

41:17.740 --> 41:22.300
 Sigwin, for example, which is a wonderful collection of take all your favorite tools

41:22.300 --> 41:25.500
 from Winix and Linux and just make them work perfectly on Windows.

41:25.500 --> 41:30.220
 And so that's something that's been going on for at least 20 years, if not longer.

41:30.220 --> 41:37.380
 And I use that on my one remaining Windows machine routinely because if you're doing

41:37.380 --> 41:42.380
 something that is batch computing, suitable for command line, that's the right way to

41:42.380 --> 41:46.660
 do it because the Windows equivalents are, if nothing else, not familiar to me.

41:46.660 --> 41:52.460
 But I would definitely recommend to people to, if they don't use Sigwin, to try whistle.

41:52.460 --> 41:53.460
 Yes.

41:53.460 --> 41:59.420
 I've been so excited that I could use batch, that would be batch, write scripts quickly

41:59.420 --> 42:00.420
 in Windows.

42:00.420 --> 42:02.740
 It's changed my life.

42:02.740 --> 42:03.740
 Okay.

42:03.740 --> 42:06.620
 What's your perfect programming setup?

42:06.620 --> 42:07.620
 What computer?

42:07.620 --> 42:08.620
 What operating system?

42:08.620 --> 42:09.620
 What keyboard?

42:09.620 --> 42:10.620
 What editor?

42:10.620 --> 42:11.620
 Yeah.

42:11.620 --> 42:12.620
 Perfect is too strong a word.

42:12.620 --> 42:15.540
 It's way too strong a word.

42:15.540 --> 42:22.420
 What I use by default, I have a, at this point, a 13 inch MacBook Air, which I use because

42:22.420 --> 42:25.220
 it's kind of a reasonable balance of the various things I need.

42:25.220 --> 42:26.660
 I can carry it around.

42:26.660 --> 42:31.220
 It's got enough computing, horsepower, screen's big enough, keyboard's okay.

42:31.220 --> 42:34.620
 And so I basically do most of my computing on that.

42:34.620 --> 42:39.940
 I have a big iMac in my office that I use from time to time as well, especially when

42:39.940 --> 42:47.220
 I need a big screen, but otherwise it tends not to be used that much.

42:47.220 --> 42:48.380
 Editor.

42:48.380 --> 42:55.580
 I use mostly SAM, which is an editor that Rob Pike wrote long ago at Bell Labs and.

42:55.580 --> 42:57.060
 Did that, sorry to interrupt it.

42:57.060 --> 42:58.060
 Does that precede VI?

42:58.060 --> 43:00.220
 Does that precede Mac?

43:00.220 --> 43:04.260
 It post dates both VI and Emacs.

43:04.260 --> 43:10.900
 It is derived from Rob's experience with ED and VI.

43:10.900 --> 43:11.900
 ED.

43:11.900 --> 43:14.460
 That's the original Unix editor.

43:14.460 --> 43:15.460
 Oh wow.

43:15.460 --> 43:19.700
 Dated probably before you were born.

43:19.700 --> 43:23.820
 So what's, actually, what's the history of editors?

43:23.820 --> 43:29.180
 Can you briefly, because it's such a fact, I use Emacs, I'm sorry to say, sorry to come

43:29.180 --> 43:30.420
 out with that.

43:30.420 --> 43:33.500
 But what's the kind of interplay there?

43:33.500 --> 43:39.900
 So in ancient times, like call it the first time sharing system is going back to what

43:39.900 --> 43:40.900
 we were talking about.

43:40.900 --> 43:45.140
 There were editors, there was an editor on CTSS that I don't even remember what it was

43:45.140 --> 43:46.140
 called.

43:46.140 --> 43:51.900
 It might have been edit, where you could type text, program text, and it would do something

43:51.900 --> 43:53.780
 or document text.

43:53.780 --> 43:55.020
 You could save the text.

43:55.020 --> 43:56.020
 Save it.

43:56.020 --> 43:57.020
 You could edit it.

43:57.020 --> 44:00.580
 The usual thing that you would get in an editor.

44:00.580 --> 44:06.140
 And Ken Thompson wrote an editor called QED, which was very, very powerful.

44:06.140 --> 44:11.020
 But these were all totally a command based, they were not most or cursor based because

44:11.020 --> 44:15.100
 it was before mice and even before cursors, because they were running on terminals that

44:15.100 --> 44:16.420
 printed on paper.

44:16.420 --> 44:17.420
 Okay.

44:17.420 --> 44:21.580
 No CRT type displays, little on the LEDs.

44:21.580 --> 44:28.940
 And so then when Unix came along, Ken took QED and stripped it way, way, way, way down.

44:28.940 --> 44:30.820
 And that became an editor that he called ED.

44:30.820 --> 44:33.980
 And it was very simple, but it was a line oriented editor.

44:33.980 --> 44:38.380
 And so you could load a file and then you could talk about the lines one through the

44:38.380 --> 44:41.660
 last line and you could print ranges of lines.

44:41.660 --> 44:46.060
 You could add text, you could delete text, you could change text, or you could do a substitute

44:46.060 --> 44:49.220
 command that would change things within a line or within groups of lines.

44:49.220 --> 44:51.220
 So you could work on a part of a file essentially.

44:51.220 --> 44:52.220
 Yeah.

44:52.220 --> 44:56.620
 You could work on any part of it, the whole thing or whatever, but it was entirely command

44:56.620 --> 45:01.660
 line based and it was entirely on paper, okay, paper.

45:01.660 --> 45:04.180
 And that meant that you changed, yeah, right, real paper.

45:04.180 --> 45:09.020
 And so if you changed the line, you had to print that line using up another line of paper

45:09.020 --> 45:13.100
 to see what the change caused, okay.

45:13.100 --> 45:19.940
 So when CRT displays came along, then you could start to use cursor control and you

45:19.940 --> 45:24.500
 could sort of move where you were on the screen in a...

45:24.500 --> 45:25.500
 Without reprinting.

45:25.500 --> 45:27.260
 Yeah, reprinting.

45:27.260 --> 45:29.900
 And there were a number of editors there.

45:29.900 --> 45:35.460
 The one that I was most familiar with and still use is VI, which was done by Bill Choy.

45:35.460 --> 45:41.460
 And so that dates from probably the late 70s as a guess.

45:41.460 --> 45:45.220
 And it took a full advantage of the cursor controls.

45:45.220 --> 45:49.020
 I suspect that Emacs was roughly at the same time, but I don't know.

45:49.020 --> 45:51.900
 I've never internalized Emacs.

45:51.900 --> 45:56.340
 So I use, at this point, I stopped using ED, although I still can.

45:56.340 --> 46:00.300
 I use VI sometimes and I use SAM when I can.

46:00.300 --> 46:02.700
 And SAM is available on most systems?

46:02.700 --> 46:04.420
 It was, it is available.

46:04.420 --> 46:08.660
 You have to download it yourself from typically the plan line operating system distribution.

46:08.660 --> 46:12.100
 It's been maintained by people there.

46:12.100 --> 46:13.100
 And so I...

46:13.100 --> 46:14.100
 I'll get home tonight.

46:14.100 --> 46:15.100
 I'll try it.

46:15.100 --> 46:16.100
 It's cool.

46:16.100 --> 46:18.100
 It sounds fascinating.

46:18.100 --> 46:23.100
 So my love is with Lisp and Emacs have went into that hippie world of...

46:23.100 --> 46:26.140
 I think it's a lot of things.

46:26.140 --> 46:27.900
 What religion were you brought up with?

46:27.900 --> 46:28.900
 Yeah, that's true.

46:28.900 --> 46:29.900
 That's true.

46:29.900 --> 46:36.340
 Most of the actual programming I do is CC++ and Python, but my weird sort of, yeah, my

46:36.340 --> 46:38.260
 religious upbringing is in Lisp.

46:38.260 --> 46:44.740
 So can you take on the impossible task and give a brief history of programming languages

46:44.740 --> 46:46.500
 from your perspective?

46:46.500 --> 46:51.180
 So I guess you could say programming languages started probably in what, the late 40s or

46:51.180 --> 46:52.180
 something like that.

46:52.180 --> 46:56.860
 People used to program computers by basically putting in zeros and ones using something

46:56.860 --> 47:05.100
 like switches on a console and then, or maybe holes in paper tapes, something like that.

47:05.100 --> 47:08.140
 So extremely tedious, awful, whatever.

47:08.140 --> 47:14.820
 And so I think the first programming languages were relatively crude assembly languages where

47:14.820 --> 47:23.500
 people would basically write a program that would convert mnemonics like add ADD into

47:23.500 --> 47:27.380
 whatever the bit pattern was that corresponded to an add instruction and they would do the

47:27.380 --> 47:32.060
 clerical work of figuring out where things were so you could put a name on a location

47:32.060 --> 47:36.940
 in a program and the assembler would figure out where that corresponded to when the thing

47:36.940 --> 47:41.060
 was all put together and dropped into memory.

47:41.060 --> 47:47.620
 And then early on, and this would be the late 40s and very early 50s, there were assemblers

47:47.620 --> 47:51.060
 written for the various machines that people used.

47:51.060 --> 47:54.260
 You may have seen in the paper just a couple of days ago, Tony Berker died.

47:54.260 --> 48:01.180
 He did this thing in Manchester called AutoCode, a language which I knew only by name.

48:01.180 --> 48:06.860
 But it sounds like it was a flavor of assembly language sort of a little higher in some ways.

48:06.860 --> 48:11.340
 And it replaced the language that Alan Turing wrote, which you put in zeros and ones, but

48:11.340 --> 48:14.820
 you put them in backwards order because that was a hardware word.

48:14.820 --> 48:15.820
 That's right.

48:15.820 --> 48:16.820
 Yeah, yeah.

48:16.820 --> 48:17.820
 That's right.

48:17.820 --> 48:18.820
 It's backwards.

48:18.820 --> 48:22.380
 So assembly language is when let's call that the early 1950s.

48:22.380 --> 48:25.820
 And so every different flavor of computer has its own assembly language.

48:25.820 --> 48:32.980
 So the Ed Sack had its and a Manchester had its and the IBM whatever 7090 or 704 or whatever

48:32.980 --> 48:33.980
 had its and so on.

48:33.980 --> 48:35.780
 So everybody had their own assembly language.

48:35.780 --> 48:40.700
 And assembly languages have a few commands, additions, subtraction and branching of some

48:40.700 --> 48:43.060
 kind if then type of situation.

48:43.060 --> 48:44.060
 Right.

48:44.060 --> 48:49.140
 They have exactly in their simplest form at least one instruction per or one assembly

48:49.140 --> 48:52.900
 language instruction per instruction in the machine's repertoire.

48:52.900 --> 48:56.940
 And so you have to know the machine intimately to be able to write programs in it.

48:56.940 --> 49:00.500
 And if you write an assembly language program for one kind of machine and then you say,

49:00.500 --> 49:01.500
 geez, it's nice.

49:01.500 --> 49:03.100
 I'd like a different machine.

49:03.100 --> 49:04.100
 Start over.

49:04.100 --> 49:05.100
 Okay.

49:05.100 --> 49:06.220
 Very bad.

49:06.220 --> 49:10.580
 And so what happened in the late fifties was people realized you could play this game

49:10.580 --> 49:16.340
 again and you could move up a level in writing or creating languages that were closer to

49:16.340 --> 49:21.100
 the way the real people might think about how to write code.

49:21.100 --> 49:25.700
 And there were, I guess, arguably three or four at that time period.

49:25.700 --> 49:30.700
 There was Fortran, which came from IBM, which was formula translation meant to make it easy

49:30.700 --> 49:32.860
 to do scientific and engineering computation.

49:32.860 --> 49:34.580
 I just know that formula translation.

49:34.580 --> 49:35.580
 That's what it stood for.

49:35.580 --> 49:39.500
 There was Kobal, which is the common business oriented language that Grace Hopper and others

49:39.500 --> 49:43.460
 worked on, which was aimed at business kinds of tasks.

49:43.460 --> 49:49.340
 There was Algol, which was mostly meant to describe algorithmic computations.

49:49.340 --> 49:51.300
 I guess you could argue basic was in there somewhere.

49:51.300 --> 49:54.420
 I think it's just a little later.

49:54.420 --> 49:56.540
 And so all of those moved the level up.

49:56.540 --> 50:01.140
 And so they were closer to what you and I might think of as we were trying to write

50:01.140 --> 50:08.220
 a program and they were focused on different domains, Fortran for formula translation,

50:08.220 --> 50:11.660
 engineering computations, let's say Kobal for business, that kind of thing.

50:11.660 --> 50:14.460
 I'm still used to today, at least Fortran probably.

50:14.460 --> 50:15.460
 Oh yeah.

50:15.460 --> 50:16.460
 Kobal too.

50:16.460 --> 50:17.460
 Kobal.

50:17.460 --> 50:21.060
 But the deal was that once you moved up that level, then you, let's call it Fortran, you

50:21.060 --> 50:26.260
 had a language that was not tied to a particular kind of hardware because a different compiler

50:26.260 --> 50:28.060
 would compile for different kind of hardware.

50:28.060 --> 50:30.060
 And that meant two things.

50:30.060 --> 50:33.940
 It meant you only had to write the program once, which was very important.

50:33.940 --> 50:38.500
 And it meant that you could, in fact, if you were a random engineer, physicist, whatever,

50:38.500 --> 50:39.780
 you could write that program yourself.

50:39.780 --> 50:42.380
 You didn't have to hire a programmer to do it for you.

50:42.380 --> 50:45.980
 It might not be as good as you'd get with a real programmer, but it was pretty good.

50:45.980 --> 50:51.540
 And so it democratized and made much more broadly available, the ability to write code.

50:51.540 --> 50:54.740
 So it puts the power of programming to the hands of people like you.

50:54.740 --> 50:55.740
 Yeah.

50:55.740 --> 50:59.300
 Anybody who wants, who is willing to invest some time in learning a programming language

50:59.300 --> 51:03.660
 and is not then tied to a particular kind of computer.

51:03.660 --> 51:09.060
 And then in the seventies, you get system programming languages of which C is the survivor.

51:09.060 --> 51:12.340
 And what, what, what does system programming languages mean?

51:12.340 --> 51:17.220
 Programs that programming languages that would take on the kinds of things that would necessary

51:17.220 --> 51:22.660
 to write so called system programs, things like text editors or assemblers or compilers

51:22.660 --> 51:26.940
 or operating systems themselves, those kinds of things.

51:26.940 --> 51:27.940
 And Fortran.

51:27.940 --> 51:29.220
 They have to be feature rich.

51:29.220 --> 51:33.540
 They have to be able to do a lot of stuff, a lot of memory management, access processes

51:33.540 --> 51:34.540
 and all that kind of stuff.

51:34.540 --> 51:37.260
 They have to, it's a different flavor of what they're doing.

51:37.260 --> 51:42.460
 They're much more in touch with the actual machine in a, but in a positive way.

51:42.460 --> 51:46.020
 That is you can talk about memory in a more controlled way.

51:46.020 --> 51:52.220
 You can talk about the different data types that the machine supports and the way they're

51:52.220 --> 51:55.060
 and more ways to structure and organize data.

51:55.060 --> 52:00.140
 And so the system programming languages, there was a lot of effort in that in the, call it

52:00.140 --> 52:02.380
 the late sixties, early seventies.

52:02.380 --> 52:06.420
 C is I think the only real survivor of that.

52:06.420 --> 52:12.100
 And then what happens after that, you get things like object oriented programming languages

52:12.100 --> 52:16.780
 because as you write programs in a language like C, at some point scale gets to, and it's

52:16.780 --> 52:21.380
 too hard to keep track of the pieces and there's no guardrails or training wheels or something

52:21.380 --> 52:24.460
 like that to prevent you from doing bad things.

52:24.460 --> 52:28.260
 So C plus plus comes out of that tradition.

52:28.260 --> 52:29.620
 And then it took off from there.

52:29.620 --> 52:33.300
 I mean, there's also a parallel, slightly parallel track with a little bit of functional

52:33.300 --> 52:35.340
 stuff with Lisbon and so on.

52:35.340 --> 52:38.460
 But I guess from that point is just an explosion of languages.

52:38.460 --> 52:39.460
 Yeah.

52:39.460 --> 52:40.460
 There's the Java story.

52:40.460 --> 52:42.100
 There's the JavaScript.

52:42.100 --> 52:48.420
 There's all the stuff that the cool kids these days are doing with Rust and all that.

52:48.420 --> 52:50.220
 So what's to use here?

52:50.220 --> 52:56.820
 You wrote a book, C programming language and C is probably one of the most important languages

52:56.820 --> 52:59.260
 in the history of programming languages.

52:59.260 --> 53:05.140
 If you kind of look at impact, what do you think is the most elegant or powerful part

53:05.140 --> 53:06.420
 of C?

53:06.420 --> 53:07.740
 Why did it survive?

53:07.740 --> 53:11.300
 Why did it have such a long lasting impact?

53:11.300 --> 53:17.980
 I think it found a sweet spot that in of expressiveness that you could really write things in a pretty

53:17.980 --> 53:23.820
 natural way and efficiency, which was particularly important when computers were not nearly as

53:23.820 --> 53:25.180
 powerful as they are today.

53:25.180 --> 53:31.300
 You've got to put yourself back 50 years almost in terms of what computers could do.

53:31.300 --> 53:37.660
 And that's roughly four or five generations, decades of Moore's law, right?

53:37.660 --> 53:44.220
 So expressiveness and efficiency and I don't know, perhaps the environment that it came

53:44.220 --> 53:46.460
 with as well, which was Unix.

53:46.460 --> 53:50.420
 So it meant if you wrote a program, it could be used on all those computers that ran Unix

53:50.420 --> 53:55.340
 and that was all of those computers because they were all written in C and that was Unix,

53:55.340 --> 53:58.220
 the operating system itself was portable as were all the tools.

53:58.220 --> 54:03.600
 So it all worked together again in one of these things where things fit on each other

54:03.600 --> 54:06.220
 in a positive cycle.

54:06.220 --> 54:11.820
 What did it take to write sort of a definitive book, probably definitive book on all of

54:11.820 --> 54:16.940
 them, like it's more definitive to a particular language than any other book on any other

54:16.940 --> 54:23.060
 language and did two really powerful things, which is popularized the language, at least

54:23.060 --> 54:25.140
 from my perspective, maybe you can correct me.

54:25.140 --> 54:33.740
 And second is created a standard of how this language is supposed to be used and applied.

54:33.740 --> 54:35.060
 So what did it take?

54:35.060 --> 54:38.380
 Did you have those kinds of ambitions in mind when working on that?

54:38.380 --> 54:40.180
 Is this some kind of joke?

54:40.180 --> 54:42.940
 No, of course not.

54:42.940 --> 54:48.180
 So it's an accident of timing skill and just luck.

54:48.180 --> 54:51.340
 A lot of it is, clearly, timing was good.

54:51.340 --> 54:53.740
 Now, Dennis and I wrote the book in 1977.

54:53.740 --> 54:54.740
 Dennis Reggie.

54:54.740 --> 54:56.620
 Yeah, right.

54:56.620 --> 54:58.900
 And at that point, Unix was starting to spread.

54:58.900 --> 55:03.780
 I don't know how many there were, but it would be dozens to hundreds of Unix systems

55:03.780 --> 55:08.580
 and C was also available on other kinds of computers that had nothing to do with Unix.

55:08.580 --> 55:13.860
 And so the language had some potential.

55:13.860 --> 55:20.460
 And there were no other books on C. And Bell Labs was really the only source for it.

55:20.460 --> 55:24.140
 And Dennis, of course, was authoritative because it was his language.

55:24.140 --> 55:28.420
 And he had written the reference manual, which is a marvelous example of how to write

55:28.420 --> 55:31.540
 a reference manual, really, really, very, very well done.

55:31.540 --> 55:35.740
 So I twisted his arm until he agreed to write a book, and then we wrote a book.

55:35.740 --> 55:41.020
 And the virtue or advantage, at least, I guess, of going first is that then other people have

55:41.020 --> 55:45.060
 to follow you if they're going to do anything.

55:45.060 --> 55:50.380
 And I think it worked well because Dennis was a superb writer.

55:50.380 --> 55:51.700
 I mean, he really, really did.

55:51.700 --> 55:55.020
 And the reference manual in that book is his period.

55:55.020 --> 55:58.820
 I had nothing to do with that at all.

55:58.820 --> 56:02.900
 So just crystal clear prose and very, very well expressed.

56:02.900 --> 56:08.100
 And then he and I, I wrote most of the expository material.

56:08.100 --> 56:13.500
 And then he and I sort of did the usual ping ponging back and forth, refining it.

56:13.500 --> 56:17.020
 But I spent a lot of time trying to find examples that would sort of hang together and that

56:17.020 --> 56:20.540
 would tell people what they might need to know at about the right time that they should

56:20.540 --> 56:23.820
 be thinking about needing it.

56:23.820 --> 56:28.260
 And I'm not sure it completely succeeded, but it mostly worked out fairly well.

56:28.260 --> 56:30.100
 What do you think is the power of example?

56:30.100 --> 56:36.980
 I mean, you're the creator, at least one of the first people to do the Hello World

56:36.980 --> 56:40.780
 program, which is like the example.

56:40.780 --> 56:45.100
 If aliens discover our civilization hundreds of years from now, it'll probably be Hello

56:45.100 --> 56:52.020
 World programs just to have broken robot communicating with them with the Hello World.

56:52.020 --> 56:53.540
 And that's a representative example.

56:53.540 --> 56:57.060
 So what do you find powerful about examples?

56:57.060 --> 57:01.780
 I think a good example will tell you how to do something.

57:01.780 --> 57:06.060
 And it will be representative of, you might not want to do exactly that, but you will

57:06.060 --> 57:10.860
 want to do something that's at least in that same general vein.

57:10.860 --> 57:16.180
 And so a lot of the examples in the C book were picked for these very, very simple straightforward

57:16.180 --> 57:19.660
 text processing problems that were typical of Unix.

57:19.660 --> 57:23.740
 I want to read input and write it out again.

57:23.740 --> 57:24.740
 There's a copy command.

57:24.740 --> 57:28.100
 I want to read input and do something to it and write it out again.

57:28.100 --> 57:29.100
 There's a grab.

57:29.100 --> 57:36.300
 And so that kind of find things that are representative of what people want to do and spell those

57:36.300 --> 57:46.060
 out so that they can then take those and see the core parts and modify them to their taste.

57:46.060 --> 57:51.580
 And I think that a lot of programming books that I don't look at programming books a tremendous

57:51.580 --> 57:54.540
 amount these days, but when I do, a lot of them don't do that.

57:54.540 --> 58:00.820
 They don't give you examples that are both realistic and something you might want to

58:00.820 --> 58:02.060
 do.

58:02.060 --> 58:03.980
 Some of them are pure syntax.

58:03.980 --> 58:05.220
 Here's how you add three numbers.

58:05.220 --> 58:07.420
 Well, come on, I could figure that out.

58:07.420 --> 58:11.500
 Tell me how I would get those three numbers into the computer and how I would do something

58:11.500 --> 58:15.700
 useful with them and then how I put them back out again neatly formatted.

58:15.700 --> 58:19.300
 And especially if you follow that example, there's something magical of doing something

58:19.300 --> 58:20.900
 that feels useful.

58:20.900 --> 58:21.900
 Yeah.

58:21.900 --> 58:22.900
 Right.

58:22.900 --> 58:28.700
 So the attempt, it's absolutely not perfect, but the attempt in all cases was to get something

58:28.700 --> 58:35.100
 that was going to be either directly useful or would be very representative of useful

58:35.100 --> 58:38.100
 things that a programmer might want to do.

58:38.100 --> 58:42.900
 But within that vein of fundamentally text processing, reading text, doing something,

58:42.900 --> 58:43.900
 writing text.

58:43.900 --> 58:47.420
 So you've also written a book on Go language.

58:47.420 --> 58:53.100
 I have to admit, so I worked at Google for a while and I've never used Go.

58:53.100 --> 58:54.500
 Well, you missed something.

58:54.500 --> 58:56.340
 Well, I know I missed something for sure.

58:56.340 --> 59:05.100
 I mean, so Go and Rust are two languages that I hear very spoken very highly of and I wish

59:05.100 --> 59:06.100
 I would like to try.

59:06.100 --> 59:07.100
 Well, there's a lot of them.

59:07.100 --> 59:08.100
 There's Julia.

59:08.100 --> 59:10.900
 There's all these incredible modern languages.

59:10.900 --> 59:16.460
 But if you can comment before, well, maybe comment on what do you find?

59:16.460 --> 59:19.780
 Where does Go sit in this broad spectrum of languages?

59:19.780 --> 59:26.380
 And also, how do you yourself feel about this wide range of powerful, interesting languages

59:26.380 --> 59:31.620
 that you may never even get to try to explore because of time?

59:31.620 --> 59:39.420
 So I think, so Go first comes from that same Bell Labs tradition in part, not exclusively,

59:39.420 --> 59:42.500
 but two of the three creators, Ken Thompson and Rob Pike.

59:42.500 --> 59:44.020
 So literally the people.

59:44.020 --> 59:45.700
 Yeah, the people.

59:45.700 --> 59:51.900
 And then with this very, very useful influence from the European school in particular, the

59:51.900 --> 59:58.220
 Klaus Speer influence through Robert Griezmer, who was, I guess, a second generation down

59:58.220 --> 1:00:01.260
 student at ETH.

1:00:01.260 --> 1:00:03.300
 And so that's an interesting combination of things.

1:00:03.300 --> 1:00:10.300
 And so some ways Go captures the good parts of C. It looks sort of like C. It's sometimes

1:00:10.300 --> 1:00:14.340
 characterized as C for the 21st century.

1:00:14.340 --> 1:00:19.700
 On the surface, it looks very, very much like C. But at the same time, it has some interesting

1:00:19.700 --> 1:00:22.020
 data structuring capabilities.

1:00:22.020 --> 1:00:27.460
 And then I think the part that I would say is particularly useful.

1:00:27.460 --> 1:00:33.100
 And again, I'm not a Go expert, in spite of coauthoring the book, about 90% of the work

1:00:33.100 --> 1:00:39.180
 was done by Alan Donovan, my coauthor, who is a Go expert.

1:00:39.180 --> 1:00:42.500
 But Go provides a very nice model of concurrency.

1:00:42.500 --> 1:00:48.620
 But basically, the cooperating, communicating sequential processes that Tony Horr set forth,

1:00:48.620 --> 1:00:52.740
 I don't know, 40 plus years ago.

1:00:52.740 --> 1:00:59.700
 And Go routines are, to my mind, a very natural way to talk about parallel computation.

1:00:59.700 --> 1:01:04.060
 And in the few experiments I've done with them, they're easy to write and typically

1:01:04.060 --> 1:01:07.380
 it's going to work and very efficient as well.

1:01:07.380 --> 1:01:13.060
 So I think that's one place where Go stands out that that model of parallel computation

1:01:13.060 --> 1:01:16.300
 is very, very easy and nice to work with.

1:01:16.300 --> 1:01:17.300
 Just a comment on that.

1:01:17.300 --> 1:01:26.020
 Do you think C for SAW or the early Unix days for SAW threads and massively parallel computation?

1:01:26.020 --> 1:01:27.660
 I would guess not really.

1:01:27.660 --> 1:01:32.660
 I mean, maybe it was seen but not at the level where it was something you had to do anything

1:01:32.660 --> 1:01:34.540
 about.

1:01:34.540 --> 1:01:41.980
 For a long time, processors got faster and then processors stopped getting faster because

1:01:41.980 --> 1:01:46.340
 of things like power consumption and heat generation.

1:01:46.340 --> 1:01:50.940
 And so what happened instead was that instead of processors getting faster, there started

1:01:50.940 --> 1:01:52.340
 to be more of them.

1:01:52.340 --> 1:01:57.060
 And that's where that parallel thread stuff comes in.

1:01:57.060 --> 1:02:02.740
 So if you can comment on all the other languages, is it break your heart that you'll never

1:02:02.740 --> 1:02:07.540
 get to explore them or how do you feel about the full variety?

1:02:07.540 --> 1:02:13.020
 It's not break my heart, but I would love to be able to try more of these languages.

1:02:13.020 --> 1:02:17.100
 The closest I've come is in class that I often teach in the spring here.

1:02:17.100 --> 1:02:24.540
 It's a programming class and I often give, I have one sort of small example that I will

1:02:24.540 --> 1:02:27.260
 write in as many languages as I possibly can.

1:02:27.260 --> 1:02:32.140
 I've got it in 20 languages at this point.

1:02:32.140 --> 1:02:36.460
 And that's so I do a minimal experiment with a language just to say, okay, I have this

1:02:36.460 --> 1:02:42.020
 trivial task which I understand the task and it should, it takes 15 lines in AUK and not

1:02:42.020 --> 1:02:44.500
 much more in a variety of other languages.

1:02:44.500 --> 1:02:45.500
 So how big is it?

1:02:45.500 --> 1:02:51.540
 How fast does it run and what pain did I go through to learn how to do it?

1:02:51.540 --> 1:02:55.580
 And that's a, it's like, anecdata, right?

1:02:55.580 --> 1:02:57.700
 It's very, very, very narrowly.

1:02:57.700 --> 1:02:58.700
 Ethic data.

1:02:58.700 --> 1:02:59.700
 I like that term.

1:02:59.700 --> 1:03:04.100
 Yeah, but still it's a little sample because you get the, I think the hardest step with

1:03:04.100 --> 1:03:06.860
 the programming language is probably the first step, right?

1:03:06.860 --> 1:03:08.860
 So there you're taking the first step.

1:03:08.860 --> 1:03:09.860
 Yeah.

1:03:09.860 --> 1:03:14.300
 And so my experience with some languages is very positive.

1:03:14.300 --> 1:03:20.140
 Like Lua, a scripting language I had never used and I took my little program, the program

1:03:20.140 --> 1:03:25.180
 is a trivial format or it just takes in lines of text of varying lengths and it puts them

1:03:25.180 --> 1:03:28.980
 out in lines that have no more than 60 characters on each line.

1:03:28.980 --> 1:03:34.620
 So think of it as just kind of the flow of process in a browser or something.

1:03:34.620 --> 1:03:41.220
 So it's a very short program and in Lua, I downloaded Lua and in an hour I had it working,

1:03:41.220 --> 1:03:44.900
 never having written Lua in my life, just going with online documentation.

1:03:44.900 --> 1:03:50.980
 I did the same thing in Scala, which you can think of as a flavor of Java, equally trivial.

1:03:50.980 --> 1:03:52.180
 I did it in Haskell.

1:03:52.180 --> 1:03:58.260
 It took me several weeks, but it did run like a turtle.

1:03:58.260 --> 1:04:06.580
 And I did it in Fortran 90 and it was painful, but it worked.

1:04:06.580 --> 1:04:11.220
 And I tried it in Rust and it took me several days to get it working because the model of

1:04:11.220 --> 1:04:14.140
 memory management was just a little unfamiliar to me.

1:04:14.140 --> 1:04:18.580
 And the problem I had with Rust, and it's back to what we were just talking about, I

1:04:18.580 --> 1:04:21.540
 couldn't find good consistent documentation on Rust.

1:04:21.540 --> 1:04:25.740
 Now this was several years ago and I'm sure things have stabilized, but at the time everything

1:04:25.740 --> 1:04:29.780
 in the Rust world seemed to be changing rapidly and so you would find what looked like a working

1:04:29.780 --> 1:04:34.900
 example and it wouldn't work with the version of the language that I had.

1:04:34.900 --> 1:04:37.780
 So it took longer than it should have.

1:04:37.780 --> 1:04:41.180
 Rust is a language I would like to get back to, but probably won't.

1:04:41.180 --> 1:04:44.500
 I think one of the issues, you have to have something you want to do and if you don't

1:04:44.500 --> 1:04:50.940
 have something that is the right combination of I want to do it and yet I have enough disposable

1:04:50.940 --> 1:04:56.660
 time, whatever, to make it worth learning a new language at the same time, it's never

1:04:56.660 --> 1:04:58.180
 going to happen.

1:04:58.180 --> 1:05:02.380
 So what do you think about another language of JavaScript?

1:05:02.380 --> 1:05:08.300
 That's this, well let me just sort of comment on what I said, when I was brought up, sort

1:05:08.300 --> 1:05:16.700
 of JavaScript was seen as probably like the ugliest language possible and yet it's quite

1:05:16.700 --> 1:05:21.740
 arguably quite possibly taking over and not just the front and the back end of the internet,

1:05:21.740 --> 1:05:26.140
 but possibly in the future taking over everything because they've now learned to make it very

1:05:26.140 --> 1:05:27.140
 efficient.

1:05:27.140 --> 1:05:28.140
 Yeah.

1:05:28.140 --> 1:05:29.460
 And so what do you think about this?

1:05:29.460 --> 1:05:32.260
 Yeah, well I think you've captured it in a lot of ways.

1:05:32.260 --> 1:05:36.380
 When it first came out, JavaScript was deemed to be fairly irregular in an ugly language

1:05:36.380 --> 1:05:39.620
 and certainly in the academy, if you said you were working on JavaScript, people would

1:05:39.620 --> 1:05:40.620
 ridicule you.

1:05:40.620 --> 1:05:43.740
 It was just not fit for academics to work on.

1:05:43.740 --> 1:05:49.660
 I think a lot of that has evolved, the language itself has evolved and certainly the technology

1:05:49.660 --> 1:05:56.500
 of compiling it is fantastically better than it was and so in that sense, it's absolutely

1:05:56.500 --> 1:06:01.460
 a viable solution on back ends as well as the front ends.

1:06:01.460 --> 1:06:03.460
 Used well, I think it's a pretty good language.

1:06:03.460 --> 1:06:09.380
 I've written a modest amount of it and I've played with JavaScript translators and things

1:06:09.380 --> 1:06:14.460
 like that, I'm not a real expert and it's hard to keep up even there with the new things

1:06:14.460 --> 1:06:17.980
 that come along with it.

1:06:17.980 --> 1:06:25.140
 So I don't know whether it will ever take over the world, I think not, but it's certainly

1:06:25.140 --> 1:06:29.460
 an important language and worth knowing more about.

1:06:29.460 --> 1:06:35.100
 There's maybe to get your comment on something which JavaScript and actually most languages

1:06:35.100 --> 1:06:41.500
 as a Python, such a big part of the experience of programming with those languages includes

1:06:41.500 --> 1:06:46.020
 libraries, sort of using building on top of the code that other people have built.

1:06:46.020 --> 1:06:49.780
 I think that's probably different from the experience that we just talked about from

1:06:49.780 --> 1:06:53.340
 Unix and CDays when you're building stuff from scratch.

1:06:53.340 --> 1:06:57.900
 What do you think about this world of essentially leveraging, building up libraries on top of

1:06:57.900 --> 1:06:59.940
 each other and leveraging them?

1:06:59.940 --> 1:07:04.180
 That's a very perceptive kind of question.

1:07:04.180 --> 1:07:08.060
 One of the reasons the programming was fun in the old days was that you were really building

1:07:08.060 --> 1:07:09.060
 it all yourself.

1:07:09.060 --> 1:07:13.020
 The number of libraries you had to deal with was quite small, maybe it was printf or the

1:07:13.020 --> 1:07:16.100
 standard library or something like that.

1:07:16.100 --> 1:07:21.700
 And that is not the case today and if you want to do something in, you mentioned Python

1:07:21.700 --> 1:07:26.700
 and JavaScript and those are the two finding examples, you have to typically download a

1:07:26.700 --> 1:07:31.220
 boatload of other stuff and you have no idea what you're getting, absolutely nothing.

1:07:31.220 --> 1:07:37.940
 I've been doing some playing with machine learning over the last couple of days and gee, something

1:07:37.940 --> 1:07:38.940
 doesn't work.

1:07:38.940 --> 1:07:44.500
 Well, you pip install this and down comes another gazillion megabytes of something and

1:07:44.500 --> 1:07:46.500
 you have no idea what it was.

1:07:46.500 --> 1:07:50.940
 And if you're lucky, it works and if it doesn't work, you have no recourse.

1:07:50.940 --> 1:07:55.380
 There's absolutely no way you could figure out which in these thousand different packages.

1:07:55.380 --> 1:08:00.420
 And I think it's worse in the NPM environment for JavaScript.

1:08:00.420 --> 1:08:02.620
 I think there's less discipline, less control there.

1:08:02.620 --> 1:08:08.020
 And there's aspects of not just not understanding how it worked, but there's security issues,

1:08:08.020 --> 1:08:12.900
 there's robustness issues, so you don't want to run a nuclear power plant using JavaScript,

1:08:12.900 --> 1:08:13.900
 essentially.

1:08:13.900 --> 1:08:14.900
 Probably not.

1:08:14.900 --> 1:08:21.540
 So speaking to the variety of languages, do you think that variety is good or do you

1:08:21.540 --> 1:08:27.460
 hope think that over time we should converge towards one, two, three programming languages

1:08:27.460 --> 1:08:33.020
 that you mentioned to the bell out days when people could sort of the community of it.

1:08:33.020 --> 1:08:36.900
 And the more languages you have, the more you separate the communities.

1:08:36.900 --> 1:08:42.780
 There's the Ruby community, there's the Python community, there's C++ community.

1:08:42.780 --> 1:08:47.660
 Do you hope that they'll unite one day to just one or two languages?

1:08:47.660 --> 1:08:48.820
 I certainly don't hope it.

1:08:48.820 --> 1:08:51.780
 I'm not sure that that's right, because I honestly don't think there is one language

1:08:51.780 --> 1:08:55.500
 that will suffice for all the programming needs of the world.

1:08:55.500 --> 1:08:56.980
 Are there too many at this point?

1:08:56.980 --> 1:08:58.820
 Well, arguably.

1:08:58.820 --> 1:09:05.060
 But I think if you look at the distribution of how they are used, there's something called

1:09:05.060 --> 1:09:11.260
 a dozen languages that probably account for 95% of all programming at this point, and

1:09:11.260 --> 1:09:13.940
 that doesn't seem unreasonable.

1:09:13.940 --> 1:09:20.660
 And then there's another, well, 2,000 languages that are still in use that nobody uses and

1:09:20.660 --> 1:09:23.420
 or at least don't use in any quantity.

1:09:23.420 --> 1:09:27.820
 But I think new languages are a good idea in many respects, because they're often a chance

1:09:27.820 --> 1:09:32.860
 to explore an idea of how a language might help.

1:09:32.860 --> 1:09:36.540
 I think that's one of the positive things about functional languages.

1:09:36.540 --> 1:09:43.580
 For example, they're a particularly good place where people have explored ideas that at the

1:09:43.580 --> 1:09:49.420
 time didn't seem feasible, but ultimately have wound up as part of mainstream languages

1:09:49.420 --> 1:09:50.420
 as well.

1:09:50.420 --> 1:09:55.340
 They just go back as early as recursion and lisp and then follow forward with functions

1:09:55.340 --> 1:10:02.140
 as first class citizens and pattern based languages and, gee, I don't know, closures

1:10:02.140 --> 1:10:05.180
 and just on and on and on lambdas.

1:10:05.180 --> 1:10:09.780
 Interesting ideas that showed up first in, let's call it broadly, the functional programming

1:10:09.780 --> 1:10:13.260
 community and then find their way into mainstream languages.

1:10:13.260 --> 1:10:15.660
 Yeah, it's a playground for rebels.

1:10:15.660 --> 1:10:18.140
 Yeah, exactly.

1:10:18.140 --> 1:10:23.340
 And so I think the languages in the playground themselves are probably not going to be the

1:10:23.340 --> 1:10:30.140
 mainstream, at least for some while, but the ideas that come from there are invaluable.

1:10:30.140 --> 1:10:35.260
 So let's go to something that when I found out recently, so I've known that you've done

1:10:35.260 --> 1:10:40.940
 a million things, but one of the things I wasn't aware of that you had a role in ample.

1:10:40.940 --> 1:10:43.900
 Before you interrupt me by minimizing your role in it.

1:10:43.900 --> 1:10:46.500
 Ample is for minimizing functions.

1:10:46.500 --> 1:10:51.100
 Yeah, minimizing functions, right, exactly.

1:10:51.100 --> 1:10:58.020
 Can I just say that the elegance and abstraction power of ample is incredible when I first

1:10:58.020 --> 1:11:01.460
 came to it about 10 years ago or so.

1:11:01.460 --> 1:11:04.220
 Can you describe what is the ample language?

1:11:04.220 --> 1:11:05.220
 Sure.

1:11:05.220 --> 1:11:10.700
 So ample is a language for mathematical programming, technical term, think of it as linear programming

1:11:10.700 --> 1:11:18.900
 that is setting up systems of linear equations that are of some sort of system of constraints.

1:11:18.900 --> 1:11:23.220
 So that you have a bunch of things that have to be less than this, greater than that, whatever,

1:11:23.220 --> 1:11:29.500
 and you're trying to find a set of values for some decision variables that will maximize

1:11:29.500 --> 1:11:32.380
 or minimize some objective function.

1:11:32.380 --> 1:11:38.900
 So it's a way of solving a particular kind of optimization problem, a very formal sort

1:11:38.900 --> 1:11:40.100
 of optimization problem.

1:11:40.100 --> 1:11:42.740
 But one that's exceptionally useful.

1:11:42.740 --> 1:11:48.100
 And it specifies that there's objective function constraints and variables that become separate

1:11:48.100 --> 1:11:50.860
 from the data it operates on.

1:11:50.860 --> 1:11:58.180
 So that kind of separation allows you to put on different hats.

1:11:58.180 --> 1:12:03.260
 One put the hat of an optimization person and then put another hat of a data person

1:12:03.260 --> 1:12:10.620
 and dance back and forth and also separate the actual solvers, the optimization systems

1:12:10.620 --> 1:12:14.900
 that do the solving, that you can have other people come to the table and then build their

1:12:14.900 --> 1:12:21.900
 solvers, whether it's linear or nonlinear, convex, nonconvex, that kind of stuff.

1:12:21.900 --> 1:12:31.980
 So what is the, maybe you can comment how you got into that world and what is the beautiful

1:12:31.980 --> 1:12:35.660
 or interesting idea to you from the world of optimization?

1:12:35.660 --> 1:12:36.660
 Sure.

1:12:36.660 --> 1:12:41.940
 So I preface it by saying I'm absolutely not an expert on this and most of the important

1:12:41.940 --> 1:12:47.780
 work in Ample comes from my two partners in crime on that, Bob Forer, who was a professor

1:12:47.780 --> 1:12:52.740
 of and in the industrial engineering and management science department at Northwestern and my

1:12:52.740 --> 1:12:59.100
 colleague at Bell Labs, Dave Gay, who is a numerical analyst and optimization person.

1:12:59.100 --> 1:13:02.660
 So the deal is linear programming.

1:13:02.660 --> 1:13:03.660
 Preface this by saying...

1:13:03.660 --> 1:13:05.220
 Well, let's stay with linear programming.

1:13:05.220 --> 1:13:07.700
 Yeah, linear programming is the simplest example of this.

1:13:07.700 --> 1:13:11.660
 So linear programming is taught in school is that you have a big matrix, which is always

1:13:11.660 --> 1:13:16.860
 called A and you say AX is less than or equal to B. So B is a set of constraints, X is the

1:13:16.860 --> 1:13:23.820
 decision variables, and A as to how the decision variables are combined to set up the various

1:13:23.820 --> 1:13:24.820
 constraints.

1:13:24.820 --> 1:13:30.100
 A is a matrix and X and B are vectors, and then there's an objective function, which

1:13:30.100 --> 1:13:34.300
 is just the sum of a bunch of X's and some coefficients on them, and yet that's the thing

1:13:34.300 --> 1:13:37.180
 you want to optimize.

1:13:37.180 --> 1:13:43.660
 The problem is that in the real world, that matrix A is a very, very, very intricate,

1:13:43.660 --> 1:13:49.100
 very large and very sparse matrix where the various components of the model are distributed

1:13:49.100 --> 1:13:55.580
 among the coefficients in a way that is totally unobvious to anybody.

1:13:55.580 --> 1:14:00.700
 And so what you need is some way to express the original model, which you and I would

1:14:00.700 --> 1:14:01.700
 write.

1:14:01.700 --> 1:14:04.980
 You know, we'd write mathematics on the board, the sum of this is greater than the sum of

1:14:04.980 --> 1:14:06.580
 that kind of thing.

1:14:06.580 --> 1:14:12.220
 So you need a language to write those kinds of constraints, and Bob Forer for a long time

1:14:12.220 --> 1:14:16.580
 had been interested in modeling languages, languages that made it possible to do this.

1:14:16.580 --> 1:14:21.380
 There was a modeling language around called GAMS, the General Algebraic Modeling System,

1:14:21.380 --> 1:14:24.860
 but it looked very much like Fortran, it was kind of clunky.

1:14:24.860 --> 1:14:32.260
 And so Bob spent a sabbatical year at Bell Labs in 1984, and he was in the office across

1:14:32.260 --> 1:14:38.500
 from me, and it's always geography, and he and Dave Gay and I started talking about this

1:14:38.500 --> 1:14:44.900
 kind of thing, and he wanted to design a language that would make it so that you could take these

1:14:44.900 --> 1:14:50.380
 algebraic specifications, you know, summation signs over sets, and that you would write

1:14:50.380 --> 1:14:57.820
 on the board and convert them into basically this A matrix, and then pass that off to a

1:14:57.820 --> 1:15:01.740
 solver, which is an entirely separate thing.

1:15:01.740 --> 1:15:06.460
 And so we talked about the design of the language, I don't remember any of the details

1:15:06.460 --> 1:15:11.140
 of this now, but it's kind of an obvious thing, you're just writing out mathematical expressions

1:15:11.140 --> 1:15:17.260
 in a Fortran like, sorry, an algebraic, but textual like language.

1:15:17.260 --> 1:15:25.140
 And I wrote the first version of this Ample program, my first C++ program.

1:15:25.140 --> 1:15:26.140
 And

1:15:26.140 --> 1:15:27.140
 That's written in C++?

1:15:27.140 --> 1:15:28.140
 Yeah.

1:15:28.140 --> 1:15:31.060
 And so I did that fairly quickly.

1:15:31.060 --> 1:15:35.100
 We wrote, it was, you know, 3,000 lines or something, so it wasn't very big, but it sort

1:15:35.100 --> 1:15:38.860
 of showed the feasibility of it that you could actually do something that was easy for people

1:15:38.860 --> 1:15:45.100
 to specify models and convert it into something that a solver could work with, at the same

1:15:45.100 --> 1:15:47.940
 time, as you say, the model and the data are separate things.

1:15:47.940 --> 1:15:52.060
 So one model would then work with all kinds of different data in the same way that lots

1:15:52.060 --> 1:15:54.500
 of programs do the same thing, but with different data.

1:15:54.500 --> 1:16:00.260
 So one of the really nice things is the specification of the models, human, just kind of like as

1:16:00.260 --> 1:16:06.100
 you say, it's human readable, like I literally, I remember on stuff I worked, I would send

1:16:06.100 --> 1:16:13.260
 it to colleagues that I'm pretty sure never programmed in their life, just to understand

1:16:13.260 --> 1:16:15.740
 what the optimization problem is.

1:16:15.740 --> 1:16:18.060
 I think how hard is it to convert that?

1:16:18.060 --> 1:16:22.280
 You said you there's a first prototype in C++ to convert that into something that could

1:16:22.280 --> 1:16:24.380
 actually be used by the solver.

1:16:24.380 --> 1:16:28.580
 It's not too bad because most of the solvers have some mechanism that lets them import

1:16:28.580 --> 1:16:30.500
 a model in a form.

1:16:30.500 --> 1:16:35.260
 It might be as simple as the matrix itself in just some representation.

1:16:35.260 --> 1:16:39.660
 Or if you're doing things that are not linear programming, then there may be some mechanism

1:16:39.660 --> 1:16:48.580
 that lets you provide things like functions to be called or other constraints on the model.

1:16:48.580 --> 1:16:53.700
 So all Ample does is to generate that kind of thing and then solver deals with all the

1:16:53.700 --> 1:16:54.700
 hard work.

1:16:54.700 --> 1:16:59.820
 And then when the solver comes back with numbers, Ample converts those back into your original

1:16:59.820 --> 1:17:04.300
 form so you know how much of each thing you should be buying or making or shipping or

1:17:04.300 --> 1:17:06.540
 whatever.

1:17:06.540 --> 1:17:12.700
 So we did that in 84 and I haven't had a lot to do with it since, except that we wrote

1:17:12.700 --> 1:17:14.300
 a couple of versions of a book on it.

1:17:14.300 --> 1:17:16.500
 Which is one of the greatest books ever written.

1:17:16.500 --> 1:17:17.500
 I love that book.

1:17:17.500 --> 1:17:20.100
 I don't know why.

1:17:20.100 --> 1:17:21.100
 It's an excellent book.

1:17:21.100 --> 1:17:23.980
 Bob Forer wrote most of it and so it's really, really well done.

1:17:23.980 --> 1:17:25.700
 He must have been a dynamite teacher.

1:17:25.700 --> 1:17:27.300
 And typeset in latex.

1:17:27.300 --> 1:17:28.300
 No, no, no.

1:17:28.300 --> 1:17:29.300
 Are you kidding?

1:17:29.300 --> 1:17:33.020
 I remember liking the typography, so I don't know.

1:17:33.020 --> 1:17:34.460
 We did it with TROF.

1:17:34.460 --> 1:17:35.540
 I don't even know what that is.

1:17:35.540 --> 1:17:36.540
 Yeah, exactly.

1:17:36.540 --> 1:17:37.540
 You're too young.

1:17:37.540 --> 1:17:38.540
 Oh boy.

1:17:38.540 --> 1:17:44.380
 I think of TROF as a predecessor to the tech family of things.

1:17:44.380 --> 1:17:50.100
 It's a formatter that was done at Bell Labs in this same period of the very early 70s that

1:17:50.100 --> 1:17:54.820
 predates tech and things like that by five to 10 years.

1:17:54.820 --> 1:17:59.500
 But it was nevertheless, I'm going by memories, I remember it being beautiful.

1:17:59.500 --> 1:18:02.060
 Yeah, it was nicely done.

1:18:02.060 --> 1:18:06.940
 Outside of Unix, Seaog, Golang, all the things we talked about, all the amazing work you've

1:18:06.940 --> 1:18:12.900
 done, you've also done work in graph theory.

1:18:12.900 --> 1:18:16.580
 Let me ask this crazy out there question.

1:18:16.580 --> 1:18:23.580
 If you had to make a bet and I had to force you to make a bet, do you think P equals NP?

1:18:23.580 --> 1:18:28.260
 The answer is no, although I've told that somebody asked Jeff Dean if that was under

1:18:28.260 --> 1:18:34.420
 what conditions P would equal NP, and he said either P is zero or N is one, or vice first

1:18:34.420 --> 1:18:35.420
 I've forgotten.

1:18:35.420 --> 1:18:36.420
 P is zero, N is one.

1:18:36.420 --> 1:18:40.420
 Jeff Dean is a lot smarter than I am.

1:18:40.420 --> 1:18:42.420
 But your intuition is...

1:18:42.420 --> 1:18:47.060
 I have no intuition, but I've got a lot of colleagues who've got intuition and their

1:18:47.060 --> 1:18:48.380
 betting is no.

1:18:48.380 --> 1:18:52.820
 That's the popular bet.

1:18:52.820 --> 1:18:55.860
 What is computational complexity theory?

1:18:55.860 --> 1:19:00.940
 Do you think these kinds of complexity classes, especially as you've taught in this modern

1:19:00.940 --> 1:19:05.940
 world, are still a useful way to understand the hardness of problems?

1:19:05.940 --> 1:19:07.420
 I don't do that stuff.

1:19:07.420 --> 1:19:13.860
 The last time I touched anything to do with that was before it was invented, because it's

1:19:13.860 --> 1:19:14.860
 literally true.

1:19:14.860 --> 1:19:17.780
 I did my PhD thesis on graph...

1:19:17.780 --> 1:19:18.940
 Before big O notation.

1:19:18.940 --> 1:19:19.940
 Oh, absolutely.

1:19:19.940 --> 1:19:26.820
 Before, I did this in 1968, and I worked on graph partitioning, which is this question.

1:19:26.820 --> 1:19:31.780
 You've got a graph that is nodes and edges kind of graph, and the edges have weights,

1:19:31.780 --> 1:19:36.300
 and you just want to divide the nodes into two piles of equal size, so that the number

1:19:36.300 --> 1:19:41.700
 of edges that goes from one side to the other is as small as possible.

1:19:41.700 --> 1:19:45.580
 You developed, so that problem is hard.

1:19:45.580 --> 1:19:51.380
 Well, as it turns out, I worked with Shen Lin at Bell Labs on this, and we were never

1:19:51.380 --> 1:19:54.220
 able to come up with anything that was guaranteed to give the right answer.

1:19:54.220 --> 1:20:00.260
 We came up with heuristics that worked pretty darn well, and I peeled off some special cases

1:20:00.260 --> 1:20:02.460
 for my thesis, but it was just hard.

1:20:02.460 --> 1:20:06.380
 That was just about the time that Steve Cook was showing that there were classes of problems

1:20:06.380 --> 1:20:11.340
 that appeared to be really hard, of which graph partitioning was one.

1:20:11.340 --> 1:20:16.340
 My expertise, such as it was, totally predates that development.

1:20:16.340 --> 1:20:17.340
 Oh, interesting.

1:20:17.340 --> 1:20:23.260
 So the heuristic, which now cares the two of yours names for the traveling salesman

1:20:23.260 --> 1:20:28.180
 problem and for the graph partitioning, that was like, how did you, you weren't even thinking

1:20:28.180 --> 1:20:29.180
 in terms of classes.

1:20:29.180 --> 1:20:34.500
 You were just trying to find a heuristic that kind of does the job pretty well.

1:20:34.500 --> 1:20:38.420
 You were trying to find something that did the job, and there was nothing that you would

1:20:38.420 --> 1:20:43.300
 call, let's say, a closed form or algorithmic thing that would give you a guaranteed right

1:20:43.300 --> 1:20:44.300
 answer.

1:20:44.300 --> 1:20:50.460
 I mean, compare graph partitioning to Max Flowman cut or something like that.

1:20:50.460 --> 1:20:54.180
 That's the same problem, except there's no constraint on the number of nodes on one

1:20:54.180 --> 1:20:59.940
 side or the other of the cut, and that means it's an easy problem, at least as I understand

1:20:59.940 --> 1:21:03.780
 it, whereas the constraint that says the two have to be constrained in size makes it a

1:21:03.780 --> 1:21:04.780
 hard problem.

1:21:04.780 --> 1:21:09.340
 Yeah, so the Robert Frost has that poem where you have to choose two paths.

1:21:09.340 --> 1:21:16.140
 So why did you, is there another alternate universe in which you pursued the Don Knuth

1:21:16.140 --> 1:21:20.060
 path of algorithm design sort of?

1:21:20.060 --> 1:21:21.060
 Not smart enough.

1:21:21.060 --> 1:21:25.660
 Not smart enough.

1:21:25.660 --> 1:21:30.260
 You're infinitely modest, but so you pursued your kind of love of programming.

1:21:30.260 --> 1:21:35.740
 I mean, when you look back to those, I mean, just looking into that world, does that just

1:21:35.740 --> 1:21:40.540
 seem like a distant world of theoretical computer science?

1:21:40.540 --> 1:21:43.980
 Then is it fundamentally different from the world of programming?

1:21:43.980 --> 1:21:45.380
 I don't know.

1:21:45.380 --> 1:21:49.620
 I mean, certainly in all seriousness, I just didn't have the talent for it.

1:21:49.620 --> 1:21:54.100
 When I got here as a grad student at Princeton and I started to think about research at the

1:21:54.100 --> 1:21:58.980
 end of my, I don't know, first year or something like that, I worked briefly with John Hopcroft

1:21:58.980 --> 1:22:04.180
 who was an absolutely, you know, he mentioned during award winner, et cetera, a great guy.

1:22:04.180 --> 1:22:09.820
 And it became crystal clear I was not cut out for this stuff, period, okay.

1:22:09.820 --> 1:22:15.660
 And so I moved into things where I was more cut out for it and that tended to be things

1:22:15.660 --> 1:22:20.860
 like writing programs and then ultimately writing books.

1:22:20.860 --> 1:22:26.340
 You said that in Toronto as an undergrad, you did a senior thesis or a literature survey

1:22:26.340 --> 1:22:28.860
 on artificial intelligence.

1:22:28.860 --> 1:22:31.180
 This was 1964.

1:22:31.180 --> 1:22:32.380
 Correct.

1:22:32.380 --> 1:22:37.140
 What was the AI landscape, ideas, dreams at that time?

1:22:37.140 --> 1:22:40.500
 I think that was one of the, well, you've heard of AI winters.

1:22:40.500 --> 1:22:43.100
 This is whatever the opposite was, AI summer or something.

1:22:43.100 --> 1:22:49.180
 It was one of these things where people thought that, boy, we could do anything with computers

1:22:49.180 --> 1:22:52.740
 that all these hard problems, computers will solve them.

1:22:52.740 --> 1:22:54.460
 They will do machine translation.

1:22:54.460 --> 1:23:02.220
 They will play games like chess at, they will do machine, you know, prove theorems in geometry.

1:23:02.220 --> 1:23:07.140
 There are all kinds of examples like that where people thought, boy, we could really

1:23:07.140 --> 1:23:10.300
 do those sorts of things.

1:23:10.300 --> 1:23:16.820
 And you know, I read the Kool Aid in some sense, there's a wonderful collection of papers

1:23:16.820 --> 1:23:22.580
 called computers and thought that was published in about that era and people were very optimistic.

1:23:22.580 --> 1:23:26.940
 And then of course it turned out that what people thought was just a few years down the

1:23:26.940 --> 1:23:31.700
 pike was more than a few years down the pike.

1:23:31.700 --> 1:23:36.460
 And some parts of that are more or less now sort of under control.

1:23:36.460 --> 1:23:41.300
 We finally do play games like go and chess and so on better than people do.

1:23:41.300 --> 1:23:45.260
 But there are others and machine translation is a lot better than it used to be.

1:23:45.260 --> 1:23:51.180
 But that's, you know, 50 close to 60 years of progress and a lot of evolution in hardware

1:23:51.180 --> 1:23:57.420
 and a tremendous amount more data upon which you can build systems that actually can learn

1:23:57.420 --> 1:23:59.140
 from some of that.

1:23:59.140 --> 1:24:05.660
 And the infrastructure to support developers working together, like an open source movement,

1:24:05.660 --> 1:24:08.940
 the internet period is also an empowering.

1:24:08.940 --> 1:24:14.860
 But what lesson do you draw from that, the opposite of winter, that optimism?

1:24:14.860 --> 1:24:23.460
 Well, I guess the lesson is that in the short run, it's pretty easy to be too pessimistic

1:24:23.460 --> 1:24:27.140
 or maybe too optimistic and in the long run, you probably shouldn't be too pessimistic.

1:24:27.140 --> 1:24:28.900
 I'm not saying that very well.

1:24:28.900 --> 1:24:34.740
 It reminds me of this remark from Arthur Clark, a science fiction author who says, you know,

1:24:34.740 --> 1:24:40.460
 when some distinguished but elderly person says that something is possible, he's probably

1:24:40.460 --> 1:24:41.460
 right.

1:24:41.460 --> 1:24:44.420
 And if he says it's impossible, he's almost surely wrong.

1:24:44.420 --> 1:24:45.820
 But you don't know what the time scale is.

1:24:45.820 --> 1:24:48.420
 The time scale is critical, right?

1:24:48.420 --> 1:24:54.220
 So what are your thoughts on this new summer of AI now in the work with machine learning

1:24:54.220 --> 1:24:55.220
 and neural networks?

1:24:55.220 --> 1:24:59.580
 You've kind of mentioned that you started to try to explore and look into this world

1:24:59.580 --> 1:25:06.660
 that seems fundamentally different from the world of heuristics and algorithms like search,

1:25:06.660 --> 1:25:12.380
 it's now purely sort of trying to take huge amounts of data and learn from that data,

1:25:12.380 --> 1:25:14.500
 create programs from the data.

1:25:14.500 --> 1:25:15.500
 Yeah.

1:25:15.500 --> 1:25:16.940
 Look, I think it's very interesting.

1:25:16.940 --> 1:25:19.940
 I am incredibly far from an expert.

1:25:19.940 --> 1:25:24.900
 Most of what I know I've learned from my students and they're probably disappointed in how little

1:25:24.900 --> 1:25:26.540
 I've learned from them.

1:25:26.540 --> 1:25:30.660
 But I think it has tremendous potential for certain kinds of things.

1:25:30.660 --> 1:25:35.900
 I mean, games is one where it obviously has had any effect on some of the others as well.

1:25:35.900 --> 1:25:41.220
 I think there's, and this is speaking from definitely not expertise, I think there are

1:25:41.220 --> 1:25:47.100
 serious problems in certain kinds of machine learning, at least because what they're learning

1:25:47.100 --> 1:25:49.300
 from is the data that we give them.

1:25:49.300 --> 1:25:53.260
 And if the data we give them has something wrong with it, then what they learned from

1:25:53.260 --> 1:25:54.860
 it is probably wrong too.

1:25:54.860 --> 1:26:00.660
 And the obvious thing is some kind of bias in the data, that the data has stuff in it

1:26:00.660 --> 1:26:05.620
 like, I don't know, women aren't as good as men as men at something, okay?

1:26:05.620 --> 1:26:07.620
 That's just flat wrong.

1:26:07.620 --> 1:26:13.420
 But if it's in the data because of historical treatment, then that machine learning stuff

1:26:13.420 --> 1:26:15.140
 will propagate that.

1:26:15.140 --> 1:26:18.180
 And that is a serious worry.

1:26:18.180 --> 1:26:24.580
 The positive part of that is what machine learning does is reveal the bias in the data

1:26:24.580 --> 1:26:26.740
 and puts a mirror to our own society.

1:26:26.740 --> 1:26:35.420
 And in so doing helps us remove the bias, helps us work on ourselves, puts a mirror to ourselves.

1:26:35.420 --> 1:26:36.420
 Yeah.

1:26:36.420 --> 1:26:37.700
 That's an optimistic point of view.

1:26:37.700 --> 1:26:40.300
 And if it works that way, that would be absolutely great.

1:26:40.300 --> 1:26:46.700
 And what I don't know is whether it does work that way or whether the AI mechanisms or machine

1:26:46.700 --> 1:26:52.700
 learning mechanisms reinforce and amplify things that have been wrong in the past.

1:26:52.700 --> 1:26:58.860
 And I don't know, but I think that's a serious thing that we have to be concerned about.

1:26:58.860 --> 1:27:00.500
 Let me ask you an outdoor question.

1:27:00.500 --> 1:27:01.500
 Okay.

1:27:01.500 --> 1:27:06.620
 I know nobody knows, but what do you think it takes to build a system of human level

1:27:06.620 --> 1:27:07.620
 intelligence?

1:27:07.620 --> 1:27:09.940
 That's been the dream from the 60s.

1:27:09.940 --> 1:27:16.420
 We talk about games, about language, about image recognition, but really the dream is

1:27:16.420 --> 1:27:19.700
 to create human level or super human level intelligence.

1:27:19.700 --> 1:27:21.340
 What do you think it takes to do that?

1:27:21.340 --> 1:27:23.060
 And are we close?

1:27:23.060 --> 1:27:26.020
 I haven't a clue and I don't know, roughly speaking.

1:27:26.020 --> 1:27:29.500
 I mean, this was trying to trick you into a high class assessment.

1:27:29.500 --> 1:27:34.460
 Yeah, I mean, Turing talked about this in his paper on machine intelligence back in,

1:27:34.460 --> 1:27:36.740
 jeez, I don't know, early fifties or something like that.

1:27:36.740 --> 1:27:40.700
 And he had the idea of the Turing test and I don't know what the Turing test is.

1:27:40.700 --> 1:27:41.700
 It's a good test of intelligence.

1:27:41.700 --> 1:27:42.700
 I don't know.

1:27:42.700 --> 1:27:43.700
 It's an interesting test.

1:27:43.700 --> 1:27:48.380
 At least it's in some vague sense objective, whether you can read anything into the conclusions

1:27:48.380 --> 1:27:50.500
 is a different story.

1:27:50.500 --> 1:27:57.020
 Do you have worries, concerns, excitement about the future of artificial intelligence?

1:27:57.020 --> 1:27:59.100
 So there's a lot of people who are worried.

1:27:59.100 --> 1:28:04.580
 And you can speak broadly than just artificial intelligence is basically computing, taking

1:28:04.580 --> 1:28:06.780
 over the world in various forms.

1:28:06.780 --> 1:28:12.500
 Are you excited by this future, this possibility of computing being everywhere?

1:28:12.500 --> 1:28:14.740
 Or are you worried?

1:28:14.740 --> 1:28:16.380
 It's some combination of those.

1:28:16.380 --> 1:28:24.500
 I think almost all technologies over the long run are for good, but there's plenty of examples

1:28:24.500 --> 1:28:29.580
 where they haven't been good either over a long run for some people or over a short

1:28:29.580 --> 1:28:36.940
 run and computing is one of those and AI within it is going to be one of those as well.

1:28:36.940 --> 1:28:45.340
 But computing broadly for just a today example is privacy, that the use of things like social

1:28:45.340 --> 1:28:50.420
 media and so on means that and the commercial surveillance means that there's an enormous

1:28:50.420 --> 1:28:57.660
 amount more known about us by people, other businesses, government, whatever, than perhaps

1:28:57.660 --> 1:28:59.660
 one ought to feel comfortable with.

1:28:59.660 --> 1:29:01.660
 So that's an example.

1:29:01.660 --> 1:29:10.260
 So that's an example of a possible negative effect of computing being everywhere.

1:29:10.260 --> 1:29:16.300
 It's an interesting one because it could also be a positive if leveraged correctly.

1:29:16.300 --> 1:29:18.220
 There's a big if there.

1:29:18.220 --> 1:29:25.060
 So I have a deep interest in human psychology and humans there seem to be very paranoid

1:29:25.060 --> 1:29:31.420
 about this data thing that varies depending on age group.

1:29:31.420 --> 1:29:36.380
 It seems like the younger folks, so it's exciting to me to see what society looks like 50 years

1:29:36.380 --> 1:29:42.020
 from now that the concerns about privacy might be flipped on their head based purely on human

1:29:42.020 --> 1:29:47.900
 psychology versus actual concerns or not.

1:29:47.900 --> 1:29:49.980
 What do you think about Moore's law?

1:29:49.980 --> 1:29:55.660
 You said a lot of stuff we've talked about with programming languages in their design

1:29:55.660 --> 1:30:00.540
 and their ideas are come from the constraints and the systems they operate in.

1:30:00.540 --> 1:30:09.740
 Do you think Moore's law, the exponential improvement of systems will continue indefinitely?

1:30:09.740 --> 1:30:12.540
 There's mix of opinions on that currently.

1:30:12.540 --> 1:30:18.540
 Or do you think there'll be a plateau?

1:30:18.540 --> 1:30:26.300
 Well, the frivolous answer is no exponential can go on forever, run out of something.

1:30:26.300 --> 1:30:27.780
 Just as we said, time scale matters.

1:30:27.780 --> 1:30:30.940
 So if it goes on long enough, that might be all we need.

1:30:30.940 --> 1:30:31.940
 Yeah, right.

1:30:31.940 --> 1:30:33.420
 It won't matter to us.

1:30:33.420 --> 1:30:34.420
 So I don't know.

1:30:34.420 --> 1:30:35.980
 We've seen places where Moore's law has changed.

1:30:35.980 --> 1:30:42.860
 For example, mentioned earlier, processors don't get faster anymore, but you use that

1:30:42.860 --> 1:30:49.580
 same growth of the ability to put more things in a given area to grow them horizontally

1:30:49.580 --> 1:30:51.180
 instead of vertically as it were.

1:30:51.180 --> 1:30:55.700
 So you can get more and more processors or memory or whatever on the same chip.

1:30:55.700 --> 1:31:01.620
 Is that going to run into a limitation, presumably, because at some point you get down to the

1:31:01.620 --> 1:31:03.460
 individual atoms.

1:31:03.460 --> 1:31:05.780
 And so you've got to find some way around that.

1:31:05.780 --> 1:31:07.340
 Will we find some way around that?

1:31:07.340 --> 1:31:08.340
 I don't know.

1:31:08.340 --> 1:31:11.980
 I just said that if I say it won't, I'll be wrong.

1:31:11.980 --> 1:31:12.980
 Perhaps we will.

1:31:12.980 --> 1:31:16.980
 So I just talked to Jim Keller and he says, he actually describes, he argues that the

1:31:16.980 --> 1:31:21.900
 Moore's law will continue for a long, long time because you mentioned the atom.

1:31:21.900 --> 1:31:29.300
 We actually have, I think, a thousand fold increase, still decrease in transit size,

1:31:29.300 --> 1:31:32.140
 still possible before we get to the quantum level.

1:31:32.140 --> 1:31:36.540
 There's still a lot of possibilities, so he thinks he'll continue indefinitely, which

1:31:36.540 --> 1:31:40.820
 is an interesting optimistic viewpoint.

1:31:40.820 --> 1:31:45.660
 But how do you think the programming languages will change with this increase?

1:31:45.660 --> 1:31:49.900
 Whether we hit a wall or not, what do you think?

1:31:49.900 --> 1:31:54.500
 Do you think there'll be a fundamental change in the way programming languages are designed?

1:31:54.500 --> 1:31:55.500
 I don't know about that.

1:31:55.500 --> 1:32:02.140
 I think what will happen is continuation of what we see in some areas, at least, which

1:32:02.140 --> 1:32:10.860
 is that more programming will be done by programs than by people and that more will be done

1:32:10.860 --> 1:32:17.460
 by sort of declarative rather than procedural mechanisms where I say, I want this to happen.

1:32:17.460 --> 1:32:20.420
 You figure out how.

1:32:20.420 --> 1:32:28.860
 And that is, in many cases, this point, domain of specialized languages for narrow domains,

1:32:28.860 --> 1:32:31.980
 but you can imagine that broadening out.

1:32:31.980 --> 1:32:36.140
 And so I don't have to say so much in so much detail.

1:32:36.140 --> 1:32:41.900
 Some collection of software, let's call it languages or programs or something, will figure

1:32:41.900 --> 1:32:45.460
 out how to do what I want to do.

1:32:45.460 --> 1:32:49.020
 So increased levels of abstraction.

1:32:49.020 --> 1:32:54.660
 And one day, getting to the human level, we're going to just use natural language.

1:32:54.660 --> 1:33:00.500
 So you taught, still teach, of course, computers in our world here at Princeton that introduces

1:33:00.500 --> 1:33:05.820
 computing and programming to nonmajors.

1:33:05.820 --> 1:33:09.340
 Just from that experience, what advice do you have for people who don't know anything

1:33:09.340 --> 1:33:14.220
 about programming but are kind of curious about this world or programming seems to become

1:33:14.220 --> 1:33:18.260
 more and more of a fundamental skill that people need to be at least aware of?

1:33:18.260 --> 1:33:19.260
 Yeah.

1:33:19.260 --> 1:33:20.260
 Well, I could recommend a good book.

1:33:20.260 --> 1:33:21.260
 What's that?

1:33:21.260 --> 1:33:24.300
 The book I wrote for the course.

1:33:24.300 --> 1:33:28.540
 I think this is one of these questions of, should everybody know how to program?

1:33:28.540 --> 1:33:32.900
 And I think the answer is probably not, but I think everybody should at least understand

1:33:32.900 --> 1:33:37.340
 sort of what it is so that if you say to somebody, I'm a programmer, they have a notion of what

1:33:37.340 --> 1:33:38.340
 that might be.

1:33:38.340 --> 1:33:43.500
 Or if you say, this is a program, or this was decided by a computer running a program

1:33:43.500 --> 1:33:50.300
 that they have some vague, intuitive understanding, an accurate understanding of what that might

1:33:50.300 --> 1:33:52.700
 imply.

1:33:52.700 --> 1:33:56.900
 So part of what I'm doing in this course, which is very definitely for non technical

1:33:56.900 --> 1:34:03.140
 people and a typical person in it is a history or English major, try and explain how computers

1:34:03.140 --> 1:34:09.660
 work, how they do their thing, what programming is, how you write a program, and how computers

1:34:09.660 --> 1:34:14.700
 talk to each other, and what do they do when they're talking to each other.

1:34:14.700 --> 1:34:22.220
 And then I would say nobody, very rarely, does anybody in that course go on to become

1:34:22.220 --> 1:34:27.780
 a real serious programmer, but at least they've got a somewhat better idea of what all this

1:34:27.780 --> 1:34:32.700
 stuff is about, not just the programming, but the technology behind computers and communications.

1:34:32.700 --> 1:34:35.620
 Do they try and write a program themselves?

1:34:35.620 --> 1:34:36.620
 Oh yeah.

1:34:36.620 --> 1:34:37.620
 Yeah.

1:34:37.620 --> 1:34:38.620
 A very small amount.

1:34:38.620 --> 1:34:43.060
 And we introduced them to how machines work at a level below high level language.

1:34:43.060 --> 1:34:47.860
 So we have a kind of a toy machine that has a very small repertoire, a dozen instructions,

1:34:47.860 --> 1:34:51.140
 and they write trivial assembly language programs for that.

1:34:51.140 --> 1:34:52.140
 Really?

1:34:52.140 --> 1:34:53.140
 Wow.

1:34:53.140 --> 1:34:54.140
 That's interesting.

1:34:54.140 --> 1:34:57.900
 So can you just, if you were to give a flavor to people of the programming world, of the

1:34:57.900 --> 1:35:01.980
 computing world, what are the examples they should go with?

1:35:01.980 --> 1:35:07.380
 So a little bit of assembly to get a sense at the lowest level of what the program is

1:35:07.380 --> 1:35:08.860
 really doing.

1:35:08.860 --> 1:35:09.860
 Yeah.

1:35:09.860 --> 1:35:13.340
 I mean, in some sense, there's no such thing as the lowest level because you can keep going

1:35:13.340 --> 1:35:15.660
 down, but that's the place where I drew the line.

1:35:15.660 --> 1:35:21.100
 So the idea that computers have a fairly small repertoire of very simple instructions that

1:35:21.100 --> 1:35:27.900
 they can do, like add and subtract and branch and so on, as you mentioned earlier.

1:35:27.900 --> 1:35:33.420
 And that you can write code at that level and it will get things done.

1:35:33.420 --> 1:35:38.140
 And then you have the levels of abstraction that we get with higher level languages, like

1:35:38.140 --> 1:35:43.140
 Fortran or C or whatever, and that makes it easier to write the code and less dependent

1:35:43.140 --> 1:35:46.100
 on particular architectures.

1:35:46.100 --> 1:35:50.540
 And then we talk about a lot of the different kinds of programs that they use all the time

1:35:50.540 --> 1:35:57.540
 that they don't probably realize are programs like they're running macOS on their computers

1:35:57.540 --> 1:36:01.740
 or maybe Windows, and they're downloading apps on their phones, and all of those things

1:36:01.740 --> 1:36:07.740
 are programs that are just what we just talked about except at a grand scale.

1:36:07.740 --> 1:36:08.740
 Yeah.

1:36:08.740 --> 1:36:11.980
 It's easy to forget that they're actual programs, that people program.

1:36:11.980 --> 1:36:14.140
 There's engineers that wrote those things.

1:36:14.140 --> 1:36:15.140
 Yeah.

1:36:15.140 --> 1:36:16.140
 Right.

1:36:16.140 --> 1:36:21.740
 And so in a way, I'm expecting them to make an enormous conceptual leap from their five

1:36:21.740 --> 1:36:28.900
 or 10 line toy assembly language thing that adds two or three numbers to something that

1:36:28.900 --> 1:36:33.700
 is a browser on their phone or whatever, but it's really the same thing.

1:36:33.700 --> 1:36:39.940
 So if you look at the broad strokes of history, what do you think the world, like how do you

1:36:39.940 --> 1:36:42.980
 think the world changed because of computers?

1:36:42.980 --> 1:36:47.940
 It's hard to sometimes see the big picture when you're in it, but I guess I'm asking

1:36:47.940 --> 1:36:54.580
 if there's something you've noticed over the years that, like you were mentioning, the

1:36:54.580 --> 1:36:58.780
 students are more distracted looking at their, now there's a device to look at.

1:36:58.780 --> 1:37:03.340
 Well, I think computing has changed a tremendous amount, obviously, but I think one aspect

1:37:03.340 --> 1:37:09.180
 of that is the way that people interact with each other, both locally and far away.

1:37:09.180 --> 1:37:15.660
 And when I was the age of those kids, making a phone call to somewhere was a big deal because

1:37:15.660 --> 1:37:20.780
 it cost serious money, and this was in the 60s, right?

1:37:20.780 --> 1:37:25.800
 And today, people don't make phone calls, they send texts or something like that.

1:37:25.800 --> 1:37:29.740
 So there's up and down in what people do.

1:37:29.740 --> 1:37:37.020
 People think nothing of having correspondence, regular meetings, video, whatever with friends

1:37:37.020 --> 1:37:41.700
 or family or whatever in any other part of the world, and they don't think about that

1:37:41.700 --> 1:37:43.380
 at all.

1:37:43.380 --> 1:37:48.380
 And so that's just the communication aspect of it.

1:37:48.380 --> 1:37:57.180
 Do you think that brings us closer together or does it make us, does it take us away from

1:37:57.180 --> 1:37:59.100
 the closeness of human to human contact?

1:37:59.100 --> 1:38:02.940
 I think it depends a lot on all kinds of things.

1:38:02.940 --> 1:38:07.540
 So I trade mail with my brother and sister in Canada much more often than I used to talk

1:38:07.540 --> 1:38:08.940
 to them on the phone.

1:38:08.940 --> 1:38:14.780
 So probably every two or three days, I get something or send something to them.

1:38:14.780 --> 1:38:20.300
 Because 20 years ago, I probably wouldn't have talked to them on the phone nearly as

1:38:20.300 --> 1:38:21.300
 much.

1:38:21.300 --> 1:38:24.180
 So in that sense, that's brought my brother and sister and I closer together.

1:38:24.180 --> 1:38:25.860
 That's a good thing.

1:38:25.860 --> 1:38:31.460
 I watch the kids on campus and they're mostly walking around with their heads down, fooling

1:38:31.460 --> 1:38:34.900
 with their phones to the point where I have to duck them.

1:38:34.900 --> 1:38:40.700
 I don't know that that has brought them closer together in some ways.

1:38:40.700 --> 1:38:45.380
 There's sociological research that says people are in fact not as close together as they

1:38:45.380 --> 1:38:46.380
 used to be.

1:38:46.380 --> 1:38:52.460
 I don't know whether that's really true, but I can see potential downsides and kids

1:38:52.460 --> 1:38:56.900
 where you think, come on, wake up and just smell the coffee or whatever.

1:38:56.900 --> 1:38:57.900
 That's right.

1:38:57.900 --> 1:39:03.220
 But if you look at, again, nobody can predict the future, but are you excited, kind of touched

1:39:03.220 --> 1:39:08.780
 this a little bit with AI, but are you excited by the future in the next 10, 20 years that

1:39:08.780 --> 1:39:11.860
 computing will bring?

1:39:11.860 --> 1:39:16.060
 You were there when there was no computers really.

1:39:16.060 --> 1:39:22.500
 And now computers are everywhere, all over the world and Africa and Asia and just every

1:39:22.500 --> 1:39:25.660
 person, almost every person in the world has a device.

1:39:25.660 --> 1:39:30.940
 So are you hopeful, optimistic about that future?

1:39:30.940 --> 1:39:32.380
 It's mixed, if the truth be told.

1:39:32.380 --> 1:39:34.860
 I mean, I think there are some things about that that are good.

1:39:34.860 --> 1:39:39.220
 I think there's the potential for people to improve their lives all over the place and

1:39:39.220 --> 1:39:41.340
 that's obviously good.

1:39:41.340 --> 1:39:46.260
 And at the same time, at least in the short run, you can see lots and lots of bad as people

1:39:46.260 --> 1:39:51.940
 become more tribalistic or parochial in their interests and there's an enormous amount more

1:39:51.940 --> 1:39:58.020
 us than them and people are using computers in all kinds of ways to mislead or misrepresent

1:39:58.020 --> 1:40:03.020
 or flat out lie about what's going on and that is affecting politics locally and I think

1:40:03.020 --> 1:40:05.620
 everywhere in the world.

1:40:05.620 --> 1:40:10.780
 Yeah, the long term effect on political systems and so on, who knows.

1:40:10.780 --> 1:40:15.620
 Who knows indeed.

1:40:15.620 --> 1:40:18.860
 People now have a voice, which is a powerful thing.

1:40:18.860 --> 1:40:24.820
 People who are oppressed have a voice, but also everybody has a voice and the chaos that

1:40:24.820 --> 1:40:27.700
 emerges from that is fascinating to watch.

1:40:27.700 --> 1:40:29.500
 It's kind of scary.

1:40:29.500 --> 1:40:35.940
 If you can go back and relive a moment in your life, one that made you truly happy outside

1:40:35.940 --> 1:40:40.100
 of family or was profoundly transformative.

1:40:40.100 --> 1:40:46.100
 Is there a moment or moments that jump out at you from memory?

1:40:46.100 --> 1:40:47.980
 I don't think specific moments.

1:40:47.980 --> 1:40:51.340
 I think there were lots and lots and lots of good times at Bell Labs where you would

1:40:51.340 --> 1:40:54.900
 build something and it worked.

1:40:54.900 --> 1:40:55.900
 Huh.

1:40:55.900 --> 1:40:56.900
 Did I say it worked?

1:40:56.900 --> 1:40:57.900
 So the moment it worked.

1:40:57.900 --> 1:40:58.900
 Yeah.

1:40:58.900 --> 1:41:01.340
 And somebody used it and they said, gee, that's neat.

1:41:01.340 --> 1:41:07.980
 Those kinds of things happened quite often in that sort of golden era in the 70s when

1:41:07.980 --> 1:41:13.100
 Unix was young and there was all this low hanging fruit and interesting things to work

1:41:13.100 --> 1:41:18.940
 on and a group of people who kind of, we were all together in this and if you did something,

1:41:18.940 --> 1:41:20.820
 they would try it out for you.

1:41:20.820 --> 1:41:24.620
 And I think that was in some sense a really, really good time.

1:41:24.620 --> 1:41:29.500
 And AUK was AUK an example of that, when you built it and people used it.

1:41:29.500 --> 1:41:30.500
 Yeah, absolutely.

1:41:30.500 --> 1:41:32.780
 And now millions of people use it.

1:41:32.780 --> 1:41:36.540
 And all your stupid mistakes are right there for them to look at, right?

1:41:36.540 --> 1:41:37.540
 So it's mixed.

1:41:37.540 --> 1:41:38.540
 Yeah.

1:41:38.540 --> 1:41:42.540
 It's terrifying, vulnerable, but it's beautiful because it does have a positive impact on

1:41:42.540 --> 1:41:43.900
 so, so many people.

1:41:43.900 --> 1:41:47.340
 So I think there's no better way to end it.

1:41:47.340 --> 1:41:48.340
 Brian, thank you so much for talking.

1:41:48.340 --> 1:41:49.340
 It was an honor.

1:41:49.340 --> 1:41:50.340
 Okay.

1:41:50.340 --> 1:41:51.340
 My pleasure.

1:41:51.340 --> 1:41:53.900
 Good fun.

1:41:53.900 --> 1:41:56.660
 Thank you for listening to this conversation with Brian Kernigan.

1:41:56.660 --> 1:42:02.500
 And thank you to our sponsors, Aidsleep Mattress and Raycon Earbuds.

1:42:02.500 --> 1:42:09.380
 Please consider supporting this podcast by going to Aidsleep.com slash Lex and to buy

1:42:09.380 --> 1:42:12.340
 Raycon.com slash Lex.

1:42:12.340 --> 1:42:14.700
 Click the links, buy the stuff.

1:42:14.700 --> 1:42:16.860
 These both are amazing products.

1:42:16.860 --> 1:42:21.260
 It really is the best way to support this podcast and the journey I'm on.

1:42:21.260 --> 1:42:23.660
 It's how they know I sent you.

1:42:23.660 --> 1:42:27.740
 It increases the chance that they'll actually support this podcast in the future.

1:42:27.740 --> 1:42:33.020
 If you enjoy this thing, subscribe on YouTube, review it with Firestars and Apple Podcasts.

1:42:33.020 --> 1:42:39.940
 Support on Patreon or connect with me on Twitter at Lex Freedman, spelled somehow miraculously

1:42:39.940 --> 1:42:44.340
 without the letter E, just F R I D M A N.

1:42:44.340 --> 1:42:49.140
 Because when we immigrated to this country, we were not so good at spelling.

1:42:49.140 --> 1:42:53.540
 And now let me leave you with some words from Brian Kernigan.

1:42:53.540 --> 1:42:57.620
 And comment bad code, rewrite it.

1:42:57.620 --> 1:43:24.380
 Thank you for listening and hope to see you next time.

